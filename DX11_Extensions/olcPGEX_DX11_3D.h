/*TODO
	olcPGEX_DX11_3D.h

	+-------------------------------------------------------------+
	|         OneLoneCoder Pixel Game Engine Extension            |
	|                DX11 3d extension v0.28   	                  |
	+-------------------------------------------------------------+

	What is this?
	~~~~~~~~~~~~~
	This is an extension to the olcPixelGameEngine, which provides
	basic 3d with DX11... YAY - more DX for all! - maybe I'll even add FSR :smile:

	Use of this extension requires the olcPixelGameEngine-DX11-Fork's olcPixelGameEngine header

	ALSO: for FBX export from blender, turn off normals and uv, ect if not needed - these are extra duplicate verticies normally

	It also requires tinyobjloader.h

	License (OLC-3)
	~~~~~~~~~~~~~~~

	Copyright 2018 - 2019 OneLoneCoder.com

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	1. Redistributions or derivations of source code must retain the above
	copyright notice, this list of conditions and the following disclaimer.

	2. Redistributions or derivative works in binary form must reproduce
	the above copyright notice. This list of conditions and the following
	disclaimer must be reproduced in the documentation and/or other
	materials provided with the distribution.

	3. Neither the name of the copyright holder nor the names of its
	contributors may be used to endorse or promote products derived
	from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	Links
	~~~~~
	https://github.com/16-Bit-Dog

	Author
	~~~~~~
	16_Bit_Dog


//3dgep - Jeremiah - has a very good read on lights! - big thanks! - most of the light logic is derived from or is diectly utilized from him
// ^^ specifically https://www.3dgep.com/forward-plus/#Experiment_Setup_and_Performance_Results
*/
// z axis is x axis in size for pge math
//everything is radians, no angles - convert to them if you want!
// 

/*
#my python program to static get fbx v data
s = str'''

'''
#str from v studio debugger v get of M3DR
s = s.replace("DirectX::XMFLOAT3",",")
s = s.replace("x=","")
s = s.replace("y=",",")
s = s.replace("z=",",")

s= s.replace("]	","")
s= s.replace("[","")
s= s.replace("]","")
s= s.replace("+		","")

for x in range(0,10):
	for i in range(0,10):
		s= s.replace(str(i)+"{","{")

print(s)



*/

//TODO: 	bool DepthPrePass = false;     --- then do prepass depth calc on models, 

//TODO: seperate transparent and Opaque renderpass

// TODO: Tiled Forward Rendering for light, depth, ext -- toggled option
// 
// TODO: bloom
//
// TODO: recreate texture on resize screen
//  
// TODO: depth fog clip world bool --- adds string to PS output and recompiles:
//				-need extra CBuf for "view distance start fog at* (ratio from min to max depth - 0-1 [1 is max to clip at]*
//				-takes oDepth in PS to calculate depth - based on the ratio - add color to pixel [cbuf controls this] by: clamp to 0 while subtracting out the cbuf fog start, no if statment needed, just:
//					"ToReturn ToReturnColor+ CBuf_Fog.color*clamp(0,oDepth-CBuf_Fog_Start)" // adds nothing if 
// 
// TODO: fixing Directional light debug is not done yet* - due to broken rotation?
// 
// TOOO: try a slower more accurate 9attempt of light with tune options of toggle
// 
// TODO: Texture LOD's
// 
// TODO: cycle through animation function - with toggle bool for update bone dat, which then updates bone data accordingly
// 
// TODO: test and fix MSRBone
// 
// TODO: documentation
// 
//TODO: add boolean pointer to lerp functions that toggles false when done lerping for that bool if not nullptr, else true if running <-- add run through animation function - same as lerp but does animation funny buissness
// 
//
//TODO: blend state options for models - individual - then make billboard?!?!
//TODO: particle systems again?
//TODO: chain lerp function for linking lerps
//TODO: make tex work with animated decals

#pragma once

#define TINYOBJLOADER_IMPLEMENTATION
//#include "tiny_obj_loader.h"
#include "ofbxMini.h"
#include <algorithm>
#include <functional>

#if defined(OLC_PGEX_DIRECTX11_3D)

namespace DOLC11 {

	
	enum { DIRECTIONAL_LIGHT = 0, POINT_LIGHT = 1, SPOT_LIGHT = 2 };

	enum { AMBIENT_TEX = 0, EMISSIVE_TEX = 1, DIFFUSE_TEX = 2, SPECULAR_TEX = 3, SPECULAR_POWER_TEX = 4
	, NORMAL_TEX = 5
	, BUMP_TEX = 6
	, OPACITY_TEX = 7
	};


	using namespace DirectX;


	struct VertexBoneData {
		std::vector<float> IDs; //float for predictable shader pass
		std::vector<float> weights;

		VertexBoneData() {

			IDs.reserve(5);
			weights.reserve(5);

		}

	};

	struct TopBoneIDs {


		INT32 id[4] = { 0,0,0,0 };

		void ZeroID() {
			for (int i = 0; i < sizeof(id) / sizeof(INT32); i++) {
				id[i] = 0;
			}
		}
	};

	struct TopBoneWeight {
		float w[4] = { 0,0,0,0 };

		void ZeroW() {
			for (int i = 0; i < sizeof(w) / sizeof(float); i++) {
				w[i] = 0;
			}
		}
	};

	struct VNT
	{
		XMFLOAT3 Position;
		XMFLOAT3 Normal;
		XMFLOAT3 BiNormal;
		XMFLOAT3 Tangent;

		XMFLOAT2 Tex;

		TopBoneIDs tbi; //uint 4
		TopBoneWeight tbw; //float 4

	};

	std::vector<VNT> DirectionLightVNT;
	std::vector<VNT> PointLightVNT;
	std::vector<VNT> SpotLightVNT;

	void fillBlank(std::vector<VNT>* TF, XMFLOAT3* V, int i) {

		(*TF)[i].Position = *V;
		(*TF)[i].Normal = *V;
		(*TF)[i].Tex = { 0,0 };

	}

	//Don't worry - I copied these quickly with a program - the CS way
	void LoadDirectionLightVNT() {
#pragma region vDat
		std::vector <XMFLOAT3> dat = { {-0.626745582 ,-0.643076360 ,-1.36163163 },
{-0.626745582 ,-0.643076360 ,-0.108140528 },
{-0.626745582 ,0.610414803 ,-0.108140528 },
{-0.626745582 ,-0.643076360 ,-1.36163163 },
{-0.626745582 ,0.610414803 ,-0.108140528 },
{-0.626745582 ,0.610414803 ,-1.36163163 },
{-0.626745582 ,0.610414803 ,-1.36163163 },
{-0.626745582 ,0.610414803 ,-0.108140528 },
{0.626745582 ,0.610414803 ,-0.108140528 },
{-0.626745582 ,0.610414803 ,-1.36163163 },
{0.626745582 ,0.610414803 ,-0.108140528 },
{0.626745582 ,0.610414803 ,-1.36163163 },
{0.626745582 ,0.610414803 ,-1.36163163 },
{0.626745582 ,0.610414803 ,-0.108140528 },
{0.626745582 ,-0.643076360 ,-0.108140528 },
{0.626745582 ,0.610414803 ,-1.36163163 },
{0.626745582 ,-0.643076360 ,-0.108140528 },
{0.626745582 ,-0.643076360 ,-1.36163163 },
{0.626745582 ,-0.643076360 ,-1.36163163 },
{0.626745582 ,-0.643076360 ,-0.108140528 },
{-0.626745582 ,-0.643076360 ,-0.108140528 },
{0.626745582 ,-0.643076360 ,-1.36163163 },
{-0.626745582 ,-0.643076360 ,-0.108140528 },
{-0.626745582 ,-0.643076360 ,-1.36163163 },
{-0.626745582 ,0.610414803 ,-1.36163163 },
{0.626745582 ,0.610414803 ,-1.36163163 },
{0.626745582 ,-0.643076360 ,-1.36163163 },
{-0.626745582 ,0.610414803 ,-1.36163163 },
{0.626745582 ,-0.643076360 ,-1.36163163 },
{-0.626745582 ,-0.643076360 ,-1.36163163 },
{0.626745582 ,0.610414803 ,-0.108140528 },
{-0.626745582 ,0.610414803 ,-0.108140528 },
{-0.626745582 ,-0.643076360 ,-0.108140528 },
{0.626745582 ,0.610414803 ,-0.108140528 },
{-0.626745582 ,-0.643076360 ,-0.108140528 },
{0.626745582 ,-0.643076360 ,-0.108140528 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.195090309 ,-0.996942699 ,0.00399082899 },
{0.195090309 ,-0.996942699 ,0.00399082899 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.382683426 ,-0.940037012 ,0.00398099422 },
{0.382683426 ,-0.940037012 ,0.00398099422 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.555570185 ,-0.847627044 ,0.00396496058 },
{0.555570185 ,-0.847627044 ,0.00396496058 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.707106709 ,-0.723264277 ,0.00394344330 },
{0.707106709 ,-0.723264277 ,0.00394344330 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.831469595 ,-0.571727753 ,0.00391721725 },
{0.831469595 ,-0.571727753 ,0.00391721725 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.923879445 ,-0.398840964 ,0.00388729572 },
{0.923879445 ,-0.398840964 ,0.00388729572 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.980785131 ,-0.211247966 ,0.00385475159 },
{0.980785131 ,-0.211247966 ,0.00385475159 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.999999940 ,-0.0161576942 ,0.00382101536 },
{0.999999940 ,-0.0161576942 ,0.00382101536 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.980785191 ,0.178932577 ,0.00378721952 },
{0.980785191 ,0.178932577 ,0.00378721952 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.923879445 ,0.366525590 ,0.00375473499 },
{0.923879445 ,0.366525590 ,0.00375473499 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.831469595 ,0.539412558 ,0.00372475386 },
{0.831469595 ,0.539412558 ,0.00372475386 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.707106709 ,0.690949142 ,0.00369852781 },
{0.707106709 ,0.690949142 ,0.00369852781 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.555570126 ,0.815312028 ,0.00367701054 },
{0.555570126 ,0.815312028 ,0.00367701054 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.382683218 ,0.907721996 ,0.00366103649 },
{0.382683218 ,0.907721996 ,0.00366103649 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{0.195090070 ,0.964627683 ,0.00365120173 },
{0.195090070 ,0.964627683 ,0.00365120173 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-3.25841341e-07 ,0.983842373 ,0.00364780426 },
{-3.25841341e-07 ,0.983842373 ,0.00364780426 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.195090696 ,0.964627564 ,0.00365120173 },
{-0.195090696 ,0.964627564 ,0.00365120173 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.382683814 ,0.907721698 ,0.00366103649 },
{-0.382683814 ,0.907721698 ,0.00366103649 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.555570662 ,0.815311611 ,0.00367701054 },
{-0.555570662 ,0.815311611 ,0.00367701054 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.707107186 ,0.690948725 ,0.00369852781 },
{-0.707107186 ,0.690948725 ,0.00369852781 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.831469953 ,0.539412022 ,0.00372475386 },
{-0.831469953 ,0.539412022 ,0.00372475386 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.923879743 ,0.366524994 ,0.00375473499 },
{-0.923879743 ,0.366524994 ,0.00375473499 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.980785370 ,0.178931832 ,0.00378721952 },
{-0.980785370 ,0.178931832 ,0.00378721952 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.999999940 ,-0.0161585808 ,0.00382101536 },
{-0.999999940 ,-0.0161585808 ,0.00382101536 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.980785012 ,-0.211248949 ,0.00385475159 },
{-0.980785012 ,-0.211248949 ,0.00385475159 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.923879027 ,-0.398842037 ,0.00388729572 },
{-0.923879027 ,-0.398842037 ,0.00388729572 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.831468880 ,-0.571728826 ,0.00391721725 },
{-0.831468880 ,-0.571728826 ,0.00391721725 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.707105815 ,-0.723265171 ,0.00394344330 },
{-0.707105815 ,-0.723265171 ,0.00394344330 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.555569053 ,-0.847627878 ,0.00396496058 },
{-0.555569053 ,-0.847627878 ,0.00396496058 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.382682055 ,-0.940037608 ,0.00398099422 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.195090309 ,-0.996942699 ,0.00399082899 },
{0.382683426 ,-0.940037012 ,0.00398099422 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.382683426 ,-0.940037012 ,0.00398099422 },
{0.555570185 ,-0.847627044 ,0.00396496058 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.555570185 ,-0.847627044 ,0.00396496058 },
{0.707106709 ,-0.723264277 ,0.00394344330 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.707106709 ,-0.723264277 ,0.00394344330 },
{0.831469595 ,-0.571727753 ,0.00391721725 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.831469595 ,-0.571727753 ,0.00391721725 },
{0.923879445 ,-0.398840964 ,0.00388729572 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.923879445 ,-0.398840964 ,0.00388729572 },
{0.980785131 ,-0.211247966 ,0.00385475159 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.980785131 ,-0.211247966 ,0.00385475159 },
{0.999999940 ,-0.0161576942 ,0.00382101536 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.999999940 ,-0.0161576942 ,0.00382101536 },
{0.980785191 ,0.178932577 ,0.00378721952 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.980785191 ,0.178932577 ,0.00378721952 },
{0.923879445 ,0.366525590 ,0.00375473499 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.923879445 ,0.366525590 ,0.00375473499 },
{0.831469595 ,0.539412558 ,0.00372475386 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.831469595 ,0.539412558 ,0.00372475386 },
{0.707106709 ,0.690949142 ,0.00369852781 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.707106709 ,0.690949142 ,0.00369852781 },
{0.555570126 ,0.815312028 ,0.00367701054 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.555570126 ,0.815312028 ,0.00367701054 },
{0.382683218 ,0.907721996 ,0.00366103649 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.382683218 ,0.907721996 ,0.00366103649 },
{0.195090070 ,0.964627683 ,0.00365120173 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{0.195090070 ,0.964627683 ,0.00365120173 },
{-3.25841341e-07 ,0.983842373 ,0.00364780426 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-3.25841341e-07 ,0.983842373 ,0.00364780426 },
{-0.195090696 ,0.964627564 ,0.00365120173 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.195090696 ,0.964627564 ,0.00365120173 },
{-0.382683814 ,0.907721698 ,0.00366103649 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.382683814 ,0.907721698 ,0.00366103649 },
{-0.555570662 ,0.815311611 ,0.00367701054 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.555570662 ,0.815311611 ,0.00367701054 },
{-0.707107186 ,0.690948725 ,0.00369852781 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.707107186 ,0.690948725 ,0.00369852781 },
{-0.831469953 ,0.539412022 ,0.00372475386 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.831469953 ,0.539412022 ,0.00372475386 },
{-0.923879743 ,0.366524994 ,0.00375473499 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.923879743 ,0.366524994 ,0.00375473499 },
{-0.980785370 ,0.178931832 ,0.00378721952 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.980785370 ,0.178931832 ,0.00378721952 },
{-0.999999940 ,-0.0161585808 ,0.00382101536 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.999999940 ,-0.0161585808 ,0.00382101536 },
{-0.980785012 ,-0.211248949 ,0.00385475159 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.980785012 ,-0.211248949 ,0.00385475159 },
{-0.923879027 ,-0.398842037 ,0.00388729572 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.923879027 ,-0.398842037 ,0.00388729572 },
{-0.831468880 ,-0.571728826 ,0.00391721725 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.831468880 ,-0.571728826 ,0.00391721725 },
{-0.707105815 ,-0.723265171 ,0.00394344330 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.707105815 ,-0.723265171 ,0.00394344330 },
{-0.555569053 ,-0.847627878 ,0.00396496058 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.555569053 ,-0.847627878 ,0.00396496058 },
{-0.382682055 ,-0.940037608 ,0.00398099422 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 },
{-0.382682055 ,-0.940037608 ,0.00398099422 },
{-0.195088789 ,-0.996943057 ,0.00399082899 },
{-0.382682055 ,-0.940037608 ,0.00398099422 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{-0.195088789 ,-0.996943057 ,0.00399082899 },
{-0.195088789 ,-0.996943057 ,0.00399082899 },
{-2.21157656e-16 ,-0.0165039748 ,-1.99617887 },
{2.22854474e-16 ,-1.01615751 ,0.00399416685 } };
#pragma endregion vDat
		DirectionLightVNT.resize(dat.size());
		for (int i = 0; i < dat.size(); i++) {
			fillBlank(&DirectionLightVNT, &dat[i], i);
		}
	}
	void LoadPointLightVNT() {
#pragma region vDat
		std::vector <XMFLOAT3> dat = {
{0.00000000 ,1.97941256 ,1.49441490e-07 }	,
{0.00000000 ,1.94137859 ,0.386164308 }	,
{0.378744304 ,1.90407550 ,0.386164308 }	,
{0.00000000 ,1.97941256 ,1.49441490e-07 }	,
{0.378744304 ,1.90407550 ,0.386164308 }	,
{0.386164367 ,1.94137859 ,1.49441490e-07 }	,
{0.00000000 ,0.386164248 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.0753370300 ,0.378744185 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{2.99677652e-08 ,0.386163443 ,-1.94137871 }	,
{0.0753369406 ,0.378743708 ,-1.94137871 }	,
{0.00000000 ,1.94137871 ,-0.386164010 }	,
{0.00000000 ,1.97941256 ,1.49441490e-07 }	,
{0.386164367 ,1.94137859 ,1.49441490e-07 }	,
{0.00000000 ,1.94137871 ,-0.386164010 }	,
{0.386164367 ,1.94137859 ,1.49441490e-07 }	,
{0.378744334 ,1.90407562 ,-0.386164010 }	,
{0.00000000 ,0.757488430 ,1.82873869 }	,
{0.00000000 ,0.386164248 ,1.94137859 }	,
{0.0753370300 ,0.378744185 ,1.94137859 }	,
{0.00000000 ,0.757488430 ,1.82873869 }	,
{0.0753370300 ,0.378744185 ,1.94137859 }	,
{0.147778809 ,0.742933512 ,1.82873869 }	,
{1.25828294e-07 ,1.82873774 ,-0.757488072 }	,
{0.00000000 ,1.94137871 ,-0.386164010 }	,
{0.378744334 ,1.90407562 ,-0.386164010 }	,
{1.25828294e-07 ,1.82873774 ,-0.757488072 }	,
{0.378744334 ,1.90407562 ,-0.386164010 }	,
{0.356769353 ,1.79360008 ,-0.757488072 }	,
{0.00000000 ,1.09970272 ,1.64582133 }	,
{0.00000000 ,0.757488430 ,1.82873869 }	,
{0.147778809 ,0.742933512 ,1.82873869 }	,
{0.00000000 ,1.09970272 ,1.64582133 }	,
{0.147778809 ,0.742933512 ,1.82873869 }	,
{0.214541495 ,1.07857227 ,1.64582133 }	,
{5.38765960e-07 ,1.64581966 ,-1.09970260 }	,
{1.25828294e-07 ,1.82873774 ,-0.757488072 }	,
{0.356769353 ,1.79360008 ,-0.757488072 }	,
{5.38765960e-07 ,1.64581966 ,-1.09970260 }	,
{0.356769353 ,1.79360008 ,-0.757488072 }	,
{0.321083963 ,1.61419737 ,-1.09970260 }	,
{0.00000000 ,1.39965606 ,1.39965606 }	,
{0.00000000 ,1.09970272 ,1.64582133 }	,
{0.214541495 ,1.07857227 ,1.64582133 }	,
{0.00000000 ,1.39965606 ,1.39965606 }	,
{0.214541495 ,1.07857227 ,1.64582133 }	,
{0.273059458 ,1.37276196 ,1.39965606 }	,
{3.02801567e-07 ,1.39965522 ,-1.39965606 }	,
{5.38765960e-07 ,1.64581966 ,-1.09970260 }	,
{0.321083963 ,1.61419737 ,-1.09970260 }	,
{3.02801567e-07 ,1.39965522 ,-1.39965606 }	,
{0.321083963 ,1.61419737 ,-1.09970260 }	,
{0.273059458 ,1.37276196 ,-1.39965606 }	,
{0.00000000 ,1.64582145 ,1.09970260 }	,
{0.00000000 ,1.39965606 ,1.39965606 }	,
{0.273059458 ,1.37276196 ,1.39965606 }	,
{0.00000000 ,1.64582145 ,1.09970260 }	,
{0.273059458 ,1.37276196 ,1.39965606 }	,
{0.321083963 ,1.61419737 ,1.09970260 }	,
{0.00000000 ,1.09970260 ,-1.64582145 }	,
{3.02801567e-07 ,1.39965522 ,-1.39965606 }	,
{0.273059458 ,1.37276196 ,-1.39965606 }	,
{0.00000000 ,1.09970260 ,-1.64582145 }	,
{0.273059458 ,1.37276196 ,-1.39965606 }	,
{0.214541465 ,1.07857215 ,-1.64582145 }	,
{0.00000000 ,1.82873869 ,0.757488370 }	,
{0.00000000 ,1.64582145 ,1.09970260 }	,
{0.321083963 ,1.61419737 ,1.09970260 }	,
{0.00000000 ,1.82873869 ,0.757488370 }	,
{0.321083963 ,1.61419737 ,1.09970260 }	,
{0.356769323 ,1.79359996 ,0.757488370 }	,
{1.55323832e-07 ,0.757487357 ,-1.82873893 }	,
{0.00000000 ,1.09970260 ,-1.64582145 }	,
{0.214541465 ,1.07857215 ,-1.64582145 }	,
{1.55323832e-07 ,0.757487357 ,-1.82873893 }	,
{0.214541465 ,1.07857215 ,-1.64582145 }	,
{0.147778735 ,0.742933154 ,-1.82873893 }	,
{0.00000000 ,1.94137859 ,0.386164308 }	,
{0.00000000 ,1.82873869 ,0.757488370 }	,
{0.356769323 ,1.79359996 ,0.757488370 }	,
{0.00000000 ,1.94137859 ,0.386164308 }	,
{0.356769323 ,1.79359996 ,0.757488370 }	,
{0.378744304 ,1.90407550 ,0.386164308 }	,
{2.99677652e-08 ,0.386163443 ,-1.94137871 }	,
{1.55323832e-07 ,0.757487357 ,-1.82873893 }	,
{0.147778735 ,0.742933154 ,-1.82873893 }	,
{2.99677652e-08 ,0.386163443 ,-1.94137871 }	,
{0.147778735 ,0.742933154 ,-1.82873893 }	,
{0.0753369406 ,0.378743708 ,-1.94137871 }	,
{0.147778735 ,0.742933154 ,-1.82873893 }	,
{0.214541465 ,1.07857215 ,-1.64582145 }	,
{0.420838207 ,1.01599264 ,-1.64582145 }	,
{0.147778735 ,0.742933154 ,-1.82873893 }	,
{0.420838207 ,1.01599264 ,-1.64582145 }	,
{0.289878398 ,0.699827731 ,-1.82873893 }	,
{0.378744304 ,1.90407550 ,0.386164308 }	,
{0.356769323 ,1.79359996 ,0.757488370 }	,
{0.699828207 ,1.68953407 ,0.757488370 }	,
{0.378744304 ,1.90407550 ,0.386164308 }	,
{0.699828207 ,1.68953407 ,0.757488370 }	,
{0.742933691 ,1.79359984 ,0.386164308 }	,
{0.0753369406 ,0.378743708 ,-1.94137871 }	,
{0.147778735 ,0.742933154 ,-1.82873893 }	,
{0.289878398 ,0.699827731 ,-1.82873893 }	,
{0.0753369406 ,0.378743708 ,-1.94137871 }	,
{0.289878398 ,0.699827731 ,-1.82873893 }	,
{0.147778720 ,0.356768727 ,-1.94137871 }	,
{0.386164367 ,1.94137859 ,1.49441490e-07 }	,
{0.378744304 ,1.90407550 ,0.386164308 }	,
{0.742933691 ,1.79359984 ,0.386164308 }	,
{0.386164367 ,1.94137859 ,1.49441490e-07 }	,
{0.742933691 ,1.79359984 ,0.386164308 }	,
{0.757488608 ,1.82873857 ,1.49441490e-07 }	,
{0.0753370300 ,0.378744185 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.147778913 ,0.356769204 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.0753369406 ,0.378743708 ,-1.94137871 }	,
{0.147778720 ,0.356768727 ,-1.94137871 }	,
{0.378744334 ,1.90407562 ,-0.386164010 }	,
{0.386164367 ,1.94137859 ,1.49441490e-07 }	,
{0.757488608 ,1.82873857 ,1.49441490e-07 }	,
{0.378744334 ,1.90407562 ,-0.386164010 }	,
{0.757488608 ,1.82873857 ,1.49441490e-07 }	,
{0.742933691 ,1.79359984 ,-0.386164010 }	,
{0.147778809 ,0.742933512 ,1.82873869 }	,
{0.0753370300 ,0.378744185 ,1.94137859 }	,
{0.147778913 ,0.356769204 ,1.94137859 }	,
{0.147778809 ,0.742933512 ,1.82873869 }	,
{0.147778913 ,0.356769204 ,1.94137859 }	,
{0.289878517 ,0.699828088 ,1.82873869 }	,
{0.356769353 ,1.79360008 ,-0.757488072 }	,
{0.378744334 ,1.90407562 ,-0.386164010 }	,
{0.742933691 ,1.79359984 ,-0.386164010 }	,
{0.356769353 ,1.79360008 ,-0.757488072 }	,
{0.742933691 ,1.79359984 ,-0.386164010 }	,
{0.699828267 ,1.68953419 ,-0.757488072 }	,
{0.214541495 ,1.07857227 ,1.64582133 }	,
{0.147778809 ,0.742933512 ,1.82873869 }	,
{0.289878517 ,0.699828088 ,1.82873869 }	,
{0.214541495 ,1.07857227 ,1.64582133 }	,
{0.289878517 ,0.699828088 ,1.82873869 }	,
{0.420838267 ,1.01599276 ,1.64582133 }	,
{0.321083963 ,1.61419737 ,-1.09970260 }	,
{0.356769353 ,1.79360008 ,-0.757488072 }	,
{0.699828267 ,1.68953419 ,-0.757488072 }	,
{0.321083963 ,1.61419737 ,-1.09970260 }	,
{0.699828267 ,1.68953419 ,-0.757488072 }	,
{0.629828811 ,1.52054060 ,-1.09970260 }	,
{0.273059458 ,1.37276196 ,1.39965606 }	,
{0.214541495 ,1.07857227 ,1.64582133 }	,
{0.420838267 ,1.01599276 ,1.64582133 }	,
{0.273059458 ,1.37276196 ,1.39965606 }	,
{0.420838267 ,1.01599276 ,1.64582133 }	,
{0.535625398 ,1.29311335 ,1.39965606 }	,
{0.273059458 ,1.37276196 ,-1.39965606 }	,
{0.321083963 ,1.61419737 ,-1.09970260 }	,
{0.629828811 ,1.52054060 ,-1.09970260 }	,
{0.273059458 ,1.37276196 ,-1.39965606 }	,
{0.629828811 ,1.52054060 ,-1.09970260 }	,
{0.535625398 ,1.29311335 ,-1.39965606 }	,
{0.321083963 ,1.61419737 ,1.09970260 }	,
{0.273059458 ,1.37276196 ,1.39965606 }	,
{0.535625398 ,1.29311335 ,1.39965606 }	,
{0.321083963 ,1.61419737 ,1.09970260 }	,
{0.535625398 ,1.29311335 ,1.39965606 }	,
{0.629828811 ,1.52054060 ,1.09970260 }	,
{0.214541465 ,1.07857215 ,-1.64582145 }	,
{0.273059458 ,1.37276196 ,-1.39965606 }	,
{0.535625398 ,1.29311335 ,-1.39965606 }	,
{0.214541465 ,1.07857215 ,-1.64582145 }	,
{0.535625398 ,1.29311335 ,-1.39965606 }	,
{0.420838207 ,1.01599264 ,-1.64582145 }	,
{0.356769323 ,1.79359996 ,0.757488370 }	,
{0.321083963 ,1.61419737 ,1.09970260 }	,
{0.629828811 ,1.52054060 ,1.09970260 }	,
{0.356769323 ,1.79359996 ,0.757488370 }	,
{0.629828811 ,1.52054060 ,1.09970260 }	,
{0.699828207 ,1.68953407 ,0.757488370 }	,
{0.629828811 ,1.52054060 ,-1.09970260 }	,
{0.699828267 ,1.68953419 ,-0.757488072 }	,
{1.01599312 ,1.52054060 ,-0.757488072 }	,
{0.629828811 ,1.52054060 ,-1.09970260 }	,
{1.01599312 ,1.52054060 ,-0.757488072 }	,
{0.914369702 ,1.36845028 ,-1.09970260 }	,
{0.535625398 ,1.29311335 ,1.39965606 }	,
{0.420838267 ,1.01599276 ,1.64582133 }	,
{0.610962391 ,0.914369226 ,1.64582133 }	,
{0.535625398 ,1.29311335 ,1.39965606 }	,
{0.610962391 ,0.914369226 ,1.64582133 }	,
{0.777607560 ,1.16377127 ,1.39965606 }	,
{0.535625398 ,1.29311335 ,-1.39965606 }	,
{0.629828811 ,1.52054060 ,-1.09970260 }	,
{0.914369702 ,1.36845028 ,-1.09970260 }	,
{0.535625398 ,1.29311335 ,-1.39965606 }	,
{0.914369702 ,1.36845028 ,-1.09970260 }	,
{0.777607560 ,1.16377127 ,-1.39965606 }	,
{0.629828811 ,1.52054060 ,1.09970260 }	,
{0.535625398 ,1.29311335 ,1.39965606 }	,
{0.777607560 ,1.16377127 ,1.39965606 }	,
{0.629828811 ,1.52054060 ,1.09970260 }	,
{0.777607560 ,1.16377127 ,1.39965606 }	,
{0.914369702 ,1.36845028 ,1.09970260 }	,
{0.420838207 ,1.01599264 ,-1.64582145 }	,
{0.535625398 ,1.29311335 ,-1.39965606 }	,
{0.777607560 ,1.16377127 ,-1.39965606 }	,
{0.420838207 ,1.01599264 ,-1.64582145 }	,
{0.777607560 ,1.16377127 ,-1.39965606 }	,
{0.610962331 ,0.914369106 ,-1.64582145 }	,
{0.699828207 ,1.68953407 ,0.757488370 }	,
{0.629828811 ,1.52054060 ,1.09970260 }	,
{0.914369702 ,1.36845028 ,1.09970260 }	,
{0.699828207 ,1.68953407 ,0.757488370 }	,
{0.914369702 ,1.36845028 ,1.09970260 }	,
{1.01599312 ,1.52054048 ,0.757488370 }	,
{0.289878398 ,0.699827731 ,-1.82873893 }	,
{0.420838207 ,1.01599264 ,-1.64582145 }	,
{0.610962331 ,0.914369106 ,-1.64582145 }	,
{0.289878398 ,0.699827731 ,-1.82873893 }	,
{0.610962331 ,0.914369106 ,-1.64582145 }	,
{0.420838207 ,0.629828215 ,-1.82873893 }	,
{0.742933691 ,1.79359984 ,0.386164308 }	,
{0.699828207 ,1.68953407 ,0.757488370 }	,
{1.01599312 ,1.52054048 ,0.757488370 }	,
{0.742933691 ,1.79359984 ,0.386164308 }	,
{1.01599312 ,1.52054048 ,0.757488370 }	,
{1.07857251 ,1.61419702 ,0.386164308 }	,
{0.147778720 ,0.356768727 ,-1.94137871 }	,
{0.289878398 ,0.699827731 ,-1.82873893 }	,
{0.420838207 ,0.629828215 ,-1.82873893 }	,
{0.147778720 ,0.356768727 ,-1.94137871 }	,
{0.420838207 ,0.629828215 ,-1.82873893 }	,
{0.214541435 ,0.321083337 ,-1.94137871 }	,
{0.757488608 ,1.82873857 ,1.49441490e-07 }	,
{0.742933691 ,1.79359984 ,0.386164308 }	,
{1.07857251 ,1.61419702 ,0.386164308 }	,
{0.757488608 ,1.82873857 ,1.49441490e-07 }	,
{1.07857251 ,1.61419702 ,0.386164308 }	,
{1.09970307 ,1.64582109 ,1.49441490e-07 }	,
{0.147778913 ,0.356769204 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.214541733 ,0.321083724 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.147778720 ,0.356768727 ,-1.94137871 }	,
{0.214541435 ,0.321083337 ,-1.94137871 }	,
{0.742933691 ,1.79359984 ,-0.386164010 }	,
{0.757488608 ,1.82873857 ,1.49441490e-07 }	,
{1.09970307 ,1.64582109 ,1.49441490e-07 }	,
{0.742933691 ,1.79359984 ,-0.386164010 }	,
{1.09970307 ,1.64582109 ,1.49441490e-07 }	,
{1.07857251 ,1.61419702 ,-0.386164010 }	,
{0.289878517 ,0.699828088 ,1.82873869 }	,
{0.147778913 ,0.356769204 ,1.94137859 }	,
{0.214541733 ,0.321083724 ,1.94137859 }	,
{0.289878517 ,0.699828088 ,1.82873869 }	,
{0.214541733 ,0.321083724 ,1.94137859 }	,
{0.420838386 ,0.629828513 ,1.82873869 }	,
{0.699828267 ,1.68953419 ,-0.757488072 }	,
{0.742933691 ,1.79359984 ,-0.386164010 }	,
{1.07857251 ,1.61419702 ,-0.386164010 }	,
{0.699828267 ,1.68953419 ,-0.757488072 }	,
{1.07857251 ,1.61419702 ,-0.386164010 }	,
{1.01599312 ,1.52054060 ,-0.757488072 }	,
{0.420838267 ,1.01599276 ,1.64582133 }	,
{0.289878517 ,0.699828088 ,1.82873869 }	,
{0.420838386 ,0.629828513 ,1.82873869 }	,
{0.420838267 ,1.01599276 ,1.64582133 }	,
{0.420838386 ,0.629828513 ,1.82873869 }	,
{0.610962391 ,0.914369226 ,1.64582133 }	,
{0.214541435 ,0.321083337 ,-1.94137871 }	,
{0.420838207 ,0.629828215 ,-1.82873893 }	,
{0.535625398 ,0.535624802 ,-1.82873893 }	,
{0.214541435 ,0.321083337 ,-1.94137871 }	,
{0.535625398 ,0.535624802 ,-1.82873893 }	,
{0.273059428 ,0.273058861 ,-1.94137871 }	,
{1.09970307 ,1.64582109 ,1.49441490e-07 }	,
{1.07857251 ,1.61419702 ,0.386164308 }	,
{1.37276232 ,1.37276161 ,0.386164308 }	,
{1.09970307 ,1.64582109 ,1.49441490e-07 }	,
{1.37276232 ,1.37276161 ,0.386164308 }	,
{1.39965653 ,1.39965570 ,1.49441490e-07 }	,
{0.214541733 ,0.321083724 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.273059815 ,0.273059160 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.214541435 ,0.321083337 ,-1.94137871 }	,
{0.273059428 ,0.273058861 ,-1.94137871 }	,
{1.07857251 ,1.61419702 ,-0.386164010 }	,
{1.09970307 ,1.64582109 ,1.49441490e-07 }	,
{1.39965653 ,1.39965570 ,1.49441490e-07 }	,
{1.07857251 ,1.61419702 ,-0.386164010 }	,
{1.39965653 ,1.39965570 ,1.49441490e-07 }	,
{1.37276232 ,1.37276161 ,-0.386164010 }	,
{0.420838386 ,0.629828513 ,1.82873869 }	,
{0.214541733 ,0.321083724 ,1.94137859 }	,
{0.273059815 ,0.273059160 ,1.94137859 }	,
{0.420838386 ,0.629828513 ,1.82873869 }	,
{0.273059815 ,0.273059160 ,1.94137859 }	,
{0.535625637 ,0.535624981 ,1.82873869 }	,
{1.01599312 ,1.52054060 ,-0.757488072 }	,
{1.07857251 ,1.61419702 ,-0.386164010 }	,
{1.37276232 ,1.37276161 ,-0.386164010 }	,
{1.01599312 ,1.52054060 ,-0.757488072 }	,
{1.37276232 ,1.37276161 ,-0.386164010 }	,
{1.29311383 ,1.29311335 ,-0.757488072 }	,
{0.610962391 ,0.914369226 ,1.64582133 }	,
{0.420838386 ,0.629828513 ,1.82873869 }	,
{0.535625637 ,0.535624981 ,1.82873869 }	,
{0.610962391 ,0.914369226 ,1.64582133 }	,
{0.535625637 ,0.535624981 ,1.82873869 }	,
{0.777607620 ,0.777607024 ,1.64582133 }	,
{0.914369702 ,1.36845028 ,-1.09970260 }	,
{1.01599312 ,1.52054060 ,-0.757488072 }	,
{1.29311383 ,1.29311335 ,-0.757488072 }	,
{0.914369702 ,1.36845028 ,-1.09970260 }	,
{1.29311383 ,1.29311335 ,-0.757488072 }	,
{1.16377187 ,1.16377115 ,-1.09970260 }	,
{0.777607560 ,1.16377127 ,1.39965606 }	,
{0.610962391 ,0.914369226 ,1.64582133 }	,
{0.777607620 ,0.777607024 ,1.64582133 }	,
{0.777607560 ,1.16377127 ,1.39965606 }	,
{0.777607620 ,0.777607024 ,1.64582133 }	,
{0.989706635 ,0.989706039 ,1.39965606 }	,
{0.777607560 ,1.16377127 ,-1.39965606 }	,
{0.914369702 ,1.36845028 ,-1.09970260 }	,
{1.16377187 ,1.16377115 ,-1.09970260 }	,
{0.777607560 ,1.16377127 ,-1.39965606 }	,
{1.16377187 ,1.16377115 ,-1.09970260 }	,
{0.989706635 ,0.989706039 ,-1.39965606 }	,
{0.914369702 ,1.36845028 ,1.09970260 }	,
{0.777607560 ,1.16377127 ,1.39965606 }	,
{0.989706635 ,0.989706039 ,1.39965606 }	,
{0.914369702 ,1.36845028 ,1.09970260 }	,
{0.989706635 ,0.989706039 ,1.39965606 }	,
{1.16377187 ,1.16377115 ,1.09970260 }	,
{0.610962331 ,0.914369106 ,-1.64582145 }	,
{0.777607560 ,1.16377127 ,-1.39965606 }	,
{0.989706635 ,0.989706039 ,-1.39965606 }	,
{0.610962331 ,0.914369106 ,-1.64582145 }	,
{0.989706635 ,0.989706039 ,-1.39965606 }	,
{0.777607560 ,0.777606905 ,-1.64582145 }	,
{1.01599312 ,1.52054048 ,0.757488370 }	,
{0.914369702 ,1.36845028 ,1.09970260 }	,
{1.16377187 ,1.16377115 ,1.09970260 }	,
{1.01599312 ,1.52054048 ,0.757488370 }	,
{1.16377187 ,1.16377115 ,1.09970260 }	,
{1.29311383 ,1.29311323 ,0.757488370 }	,
{0.420838207 ,0.629828215 ,-1.82873893 }	,
{0.610962331 ,0.914369106 ,-1.64582145 }	,
{0.777607560 ,0.777606905 ,-1.64582145 }	,
{0.420838207 ,0.629828215 ,-1.82873893 }	,
{0.777607560 ,0.777606905 ,-1.64582145 }	,
{0.535625398 ,0.535624802 ,-1.82873893 }	,
{1.07857251 ,1.61419702 ,0.386164308 }	,
{1.01599312 ,1.52054048 ,0.757488370 }	,
{1.29311383 ,1.29311323 ,0.757488370 }	,
{1.07857251 ,1.61419702 ,0.386164308 }	,
{1.29311383 ,1.29311323 ,0.757488370 }	,
{1.37276232 ,1.37276161 ,0.386164308 }	,
{0.989706635 ,0.989706039 ,1.39965606 }	,
{0.777607620 ,0.777607024 ,1.64582133 }	,
{0.914369822 ,0.610961735 ,1.64582133 }	,
{0.989706635 ,0.989706039 ,1.39965606 }	,
{0.914369822 ,0.610961735 ,1.64582133 }	,
{1.16377187 ,0.777606905 ,1.39965606 }	,
{0.989706635 ,0.989706039 ,-1.39965606 }	,
{1.16377187 ,1.16377115 ,-1.09970260 }	,
{1.36845088 ,0.914368987 ,-1.09970260 }	,
{0.989706635 ,0.989706039 ,-1.39965606 }	,
{1.36845088 ,0.914368987 ,-1.09970260 }	,
{1.16377187 ,0.777606905 ,-1.39965606 }	,
{1.16377187 ,1.16377115 ,1.09970260 }	,
{0.989706635 ,0.989706039 ,1.39965606 }	,
{1.16377187 ,0.777606905 ,1.39965606 }	,
{1.16377187 ,1.16377115 ,1.09970260 }	,
{1.16377187 ,0.777606905 ,1.39965606 }	,
{1.36845088 ,0.914368987 ,1.09970260 }	,
{0.777607560 ,0.777606905 ,-1.64582145 }	,
{0.989706635 ,0.989706039 ,-1.39965606 }	,
{1.16377187 ,0.777606905 ,-1.39965606 }	,
{0.777607560 ,0.777606905 ,-1.64582145 }	,
{1.16377187 ,0.777606905 ,-1.39965606 }	,
{0.914369702 ,0.610961676 ,-1.64582145 }	,
{1.29311383 ,1.29311323 ,0.757488370 }	,
{1.16377187 ,1.16377115 ,1.09970260 }	,
{1.36845088 ,0.914368987 ,1.09970260 }	,
{1.29311383 ,1.29311323 ,0.757488370 }	,
{1.36845088 ,0.914368987 ,1.09970260 }	,
{1.52054107 ,1.01599252 ,0.757488370 }	,
{0.535625398 ,0.535624802 ,-1.82873893 }	,
{0.777607560 ,0.777606905 ,-1.64582145 }	,
{0.914369702 ,0.610961676 ,-1.64582145 }	,
{0.535625398 ,0.535624802 ,-1.82873893 }	,
{0.914369702 ,0.610961676 ,-1.64582145 }	,
{0.629828870 ,0.420837611 ,-1.82873893 }	,
{1.37276232 ,1.37276161 ,0.386164308 }	,
{1.29311383 ,1.29311323 ,0.757488370 }	,
{1.52054107 ,1.01599252 ,0.757488370 }	,
{1.37276232 ,1.37276161 ,0.386164308 }	,
{1.52054107 ,1.01599252 ,0.757488370 }	,
{1.61419761 ,1.07857168 ,0.386164308 }	,
{0.273059428 ,0.273058861 ,-1.94137871 }	,
{0.535625398 ,0.535624802 ,-1.82873893 }	,
{0.629828870 ,0.420837611 ,-1.82873893 }	,
{0.273059428 ,0.273058861 ,-1.94137871 }	,
{0.629828870 ,0.420837611 ,-1.82873893 }	,
{0.321083933 ,0.214540824 ,-1.94137871 }	,
{1.39965653 ,1.39965570 ,1.49441490e-07 }	,
{1.37276232 ,1.37276161 ,0.386164308 }	,
{1.61419761 ,1.07857168 ,0.386164308 }	,
{1.39965653 ,1.39965570 ,1.49441490e-07 }	,
{1.61419761 ,1.07857168 ,0.386164308 }	,
{1.64582181 ,1.09970224 ,1.49441490e-07 }	,
{0.273059815 ,0.273059160 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.321084350 ,0.214541078 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.273059428 ,0.273058861 ,-1.94137871 }	,
{0.321083933 ,0.214540824 ,-1.94137871 }	,
{1.37276232 ,1.37276161 ,-0.386164010 }	,
{1.39965653 ,1.39965570 ,1.49441490e-07 }	,
{1.64582181 ,1.09970224 ,1.49441490e-07 }	,
{1.37276232 ,1.37276161 ,-0.386164010 }	,
{1.64582181 ,1.09970224 ,1.49441490e-07 }	,
{1.61419761 ,1.07857168 ,-0.386164010 }	,
{0.535625637 ,0.535624981 ,1.82873869 }	,
{0.273059815 ,0.273059160 ,1.94137859 }	,
{0.321084350 ,0.214541078 ,1.94137859 }	,
{0.535625637 ,0.535624981 ,1.82873869 }	,
{0.321084350 ,0.214541078 ,1.94137859 }	,
{0.629829109 ,0.420837760 ,1.82873869 }	,
{1.29311383 ,1.29311335 ,-0.757488072 }	,
{1.37276232 ,1.37276161 ,-0.386164010 }	,
{1.61419761 ,1.07857168 ,-0.386164010 }	,
{1.29311383 ,1.29311335 ,-0.757488072 }	,
{1.61419761 ,1.07857168 ,-0.386164010 }	,
{1.52054107 ,1.01599264 ,-0.757488072 }	,
{0.777607620 ,0.777607024 ,1.64582133 }	,
{0.535625637 ,0.535624981 ,1.82873869 }	,
{0.629829109 ,0.420837760 ,1.82873869 }	,
{0.777607620 ,0.777607024 ,1.64582133 }	,
{0.629829109 ,0.420837760 ,1.82873869 }	,
{0.914369822 ,0.610961735 ,1.64582133 }	,
{1.16377187 ,1.16377115 ,-1.09970260 }	,
{1.29311383 ,1.29311335 ,-0.757488072 }	,
{1.52054107 ,1.01599264 ,-0.757488072 }	,
{1.16377187 ,1.16377115 ,-1.09970260 }	,
{1.52054107 ,1.01599264 ,-0.757488072 }	,
{1.36845088 ,0.914368987 ,-1.09970260 }	,
{1.64582181 ,1.09970224 ,1.49441490e-07 }	,
{1.61419761 ,1.07857168 ,0.386164308 }	,
{1.79360020 ,0.742932737 ,0.386164308 }	,
{1.64582181 ,1.09970224 ,1.49441490e-07 }	,
{1.79360020 ,0.742932737 ,0.386164308 }	,
{1.82873917 ,0.757487833 ,1.49441490e-07 }	,
{0.321084350 ,0.214541078 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.356769800 ,0.147778243 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.321083933 ,0.214540824 ,-1.94137871 }	,
{0.356769323 ,0.147778094 ,-1.94137871 }	,
{1.61419761 ,1.07857168 ,-0.386164010 }	,
{1.64582181 ,1.09970224 ,1.49441490e-07 }	,
{1.82873917 ,0.757487833 ,1.49441490e-07 }	,
{1.61419761 ,1.07857168 ,-0.386164010 }	,
{1.82873917 ,0.757487833 ,1.49441490e-07 }	,
{1.79360020 ,0.742932737 ,-0.386164010 }	,
{0.629829109 ,0.420837760 ,1.82873869 }	,
{0.321084350 ,0.214541078 ,1.94137859 }	,
{0.356769800 ,0.147778243 ,1.94137859 }	,
{0.629829109 ,0.420837760 ,1.82873869 }	,
{0.356769800 ,0.147778243 ,1.94137859 }	,
{0.699828625 ,0.289877892 ,1.82873869 }	,
{1.52054107 ,1.01599264 ,-0.757488072 }	,
{1.61419761 ,1.07857168 ,-0.386164010 }	,
{1.79360020 ,0.742932737 ,-0.386164010 }	,
{1.52054107 ,1.01599264 ,-0.757488072 }	,
{1.79360020 ,0.742932737 ,-0.386164010 }	,
{1.68953454 ,0.699827731 ,-0.757488072 }	,
{0.914369822 ,0.610961735 ,1.64582133 }	,
{0.629829109 ,0.420837760 ,1.82873869 }	,
{0.699828625 ,0.289877892 ,1.82873869 }	,
{0.914369822 ,0.610961735 ,1.64582133 }	,
{0.699828625 ,0.289877892 ,1.82873869 }	,
{1.01599336 ,0.420837611 ,1.64582133 }	,
{1.36845088 ,0.914368987 ,-1.09970260 }	,
{1.52054107 ,1.01599264 ,-0.757488072 }	,
{1.68953454 ,0.699827731 ,-0.757488072 }	,
{1.36845088 ,0.914368987 ,-1.09970260 }	,
{1.68953454 ,0.699827731 ,-0.757488072 }	,
{1.52054119 ,0.629828036 ,-1.09970260 }	,
{1.16377187 ,0.777606905 ,1.39965606 }	,
{0.914369822 ,0.610961735 ,1.64582133 }	,
{1.01599336 ,0.420837611 ,1.64582133 }	,
{1.16377187 ,0.777606905 ,1.39965606 }	,
{1.01599336 ,0.420837611 ,1.64582133 }	,
{1.29311395 ,0.535624743 ,1.39965606 }	,
{1.16377187 ,0.777606905 ,-1.39965606 }	,
{1.36845088 ,0.914368987 ,-1.09970260 }	,
{1.52054119 ,0.629828036 ,-1.09970260 }	,
{1.16377187 ,0.777606905 ,-1.39965606 }	,
{1.52054119 ,0.629828036 ,-1.09970260 }	,
{1.29311395 ,0.535624743 ,-1.39965606 }	,
{1.36845088 ,0.914368987 ,1.09970260 }	,
{1.16377187 ,0.777606905 ,1.39965606 }	,
{1.29311395 ,0.535624743 ,1.39965606 }	,
{1.36845088 ,0.914368987 ,1.09970260 }	,
{1.29311395 ,0.535624743 ,1.39965606 }	,
{1.52054119 ,0.629828036 ,1.09970260 }	,
{0.914369702 ,0.610961676 ,-1.64582145 }	,
{1.16377187 ,0.777606905 ,-1.39965606 }	,
{1.29311395 ,0.535624743 ,-1.39965606 }	,
{0.914369702 ,0.610961676 ,-1.64582145 }	,
{1.29311395 ,0.535624743 ,-1.39965606 }	,
{1.01599324 ,0.420837492 ,-1.64582145 }	,
{1.52054107 ,1.01599252 ,0.757488370 }	,
{1.36845088 ,0.914368987 ,1.09970260 }	,
{1.52054119 ,0.629828036 ,1.09970260 }	,
{1.52054107 ,1.01599252 ,0.757488370 }	,
{1.52054119 ,0.629828036 ,1.09970260 }	,
{1.68953454 ,0.699827611 ,0.757488370 }	,
{0.629828870 ,0.420837611 ,-1.82873893 }	,
{0.914369702 ,0.610961676 ,-1.64582145 }	,
{1.01599324 ,0.420837492 ,-1.64582145 }	,
{0.629828870 ,0.420837611 ,-1.82873893 }	,
{1.01599324 ,0.420837492 ,-1.64582145 }	,
{0.699828327 ,0.289877802 ,-1.82873893 }	,
{1.61419761 ,1.07857168 ,0.386164308 }	,
{1.52054107 ,1.01599252 ,0.757488370 }	,
{1.68953454 ,0.699827611 ,0.757488370 }	,
{1.61419761 ,1.07857168 ,0.386164308 }	,
{1.68953454 ,0.699827611 ,0.757488370 }	,
{1.79360020 ,0.742932737 ,0.386164308 }	,
{0.321083933 ,0.214540824 ,-1.94137871 }	,
{0.629828870 ,0.420837611 ,-1.82873893 }	,
{0.699828327 ,0.289877802 ,-1.82873893 }	,
{0.321083933 ,0.214540824 ,-1.94137871 }	,
{0.699828327 ,0.289877802 ,-1.82873893 }	,
{0.356769323 ,0.147778094 ,-1.94137871 }	,
{1.29311395 ,0.535624743 ,-1.39965606 }	,
{1.52054119 ,0.629828036 ,-1.09970260 }	,
{1.61419773 ,0.321083218 ,-1.09970260 }	,
{1.29311395 ,0.535624743 ,-1.39965606 }	,
{1.61419773 ,0.321083218 ,-1.09970260 }	,
{1.37276244 ,0.273058832 ,-1.39965606 }	,
{1.52054119 ,0.629828036 ,1.09970260 }	,
{1.29311395 ,0.535624743 ,1.39965606 }	,
{1.37276244 ,0.273058832 ,1.39965606 }	,
{1.52054119 ,0.629828036 ,1.09970260 }	,
{1.37276244 ,0.273058832 ,1.39965606 }	,
{1.61419773 ,0.321083218 ,1.09970260 }	,
{1.01599324 ,0.420837492 ,-1.64582145 }	,
{1.29311395 ,0.535624743 ,-1.39965606 }	,
{1.37276244 ,0.273058832 ,-1.39965606 }	,
{1.01599324 ,0.420837492 ,-1.64582145 }	,
{1.37276244 ,0.273058832 ,-1.39965606 }	,
{1.07857263 ,0.214540750 ,-1.64582145 }	,
{1.68953454 ,0.699827611 ,0.757488370 }	,
{1.52054119 ,0.629828036 ,1.09970260 }	,
{1.61419773 ,0.321083218 ,1.09970260 }	,
{1.68953454 ,0.699827611 ,0.757488370 }	,
{1.61419773 ,0.321083218 ,1.09970260 }	,
{1.79360032 ,0.356768727 ,0.757488370 }	,
{0.699828327 ,0.289877802 ,-1.82873893 }	,
{1.01599324 ,0.420837492 ,-1.64582145 }	,
{1.07857263 ,0.214540750 ,-1.64582145 }	,
{0.699828327 ,0.289877802 ,-1.82873893 }	,
{1.07857263 ,0.214540750 ,-1.64582145 }	,
{0.742933750 ,0.147778109 ,-1.82873893 }	,
{1.79360020 ,0.742932737 ,0.386164308 }	,
{1.68953454 ,0.699827611 ,0.757488370 }	,
{1.79360032 ,0.356768727 ,0.757488370 }	,
{1.79360020 ,0.742932737 ,0.386164308 }	,
{1.79360032 ,0.356768727 ,0.757488370 }	,
{1.90407574 ,0.378743440 ,0.386164308 }	,
{0.356769323 ,0.147778094 ,-1.94137871 }	,
{0.699828327 ,0.289877802 ,-1.82873893 }	,
{0.742933750 ,0.147778109 ,-1.82873893 }	,
{0.356769323 ,0.147778094 ,-1.94137871 }	,
{0.742933750 ,0.147778109 ,-1.82873893 }	,
{0.378744274 ,0.0753363147 ,-1.94137871 }	,
{1.82873917 ,0.757487833 ,1.49441490e-07 }	,
{1.79360020 ,0.742932737 ,0.386164308 }	,
{1.90407574 ,0.378743440 ,0.386164308 }	,
{1.82873917 ,0.757487833 ,1.49441490e-07 }	,
{1.90407574 ,0.378743440 ,0.386164308 }	,
{1.94137907 ,0.386163592 ,1.49441490e-07 }	,
{0.356769800 ,0.147778243 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.378744781 ,0.0753363743 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.356769323 ,0.147778094 ,-1.94137871 }	,
{0.378744274 ,0.0753363147 ,-1.94137871 }	,
{1.79360020 ,0.742932737 ,-0.386164010 }	,
{1.82873917 ,0.757487833 ,1.49441490e-07 }	,
{1.94137907 ,0.386163592 ,1.49441490e-07 }	,
{1.79360020 ,0.742932737 ,-0.386164010 }	,
{1.94137907 ,0.386163592 ,1.49441490e-07 }	,
{1.90407574 ,0.378743440 ,-0.386164010 }	,
{0.699828625 ,0.289877892 ,1.82873869 }	,
{0.356769800 ,0.147778243 ,1.94137859 }	,
{0.378744781 ,0.0753363743 ,1.94137859 }	,
{0.699828625 ,0.289877892 ,1.82873869 }	,
{0.378744781 ,0.0753363743 ,1.94137859 }	,
{0.742934048 ,0.147778139 ,1.82873869 }	,
{1.68953454 ,0.699827731 ,-0.757488072 }	,
{1.79360020 ,0.742932737 ,-0.386164010 }	,
{1.90407574 ,0.378743440 ,-0.386164010 }	,
{1.68953454 ,0.699827731 ,-0.757488072 }	,
{1.90407574 ,0.378743440 ,-0.386164010 }	,
{1.79360032 ,0.356768847 ,-0.757488072 }	,
{1.01599336 ,0.420837611 ,1.64582133 }	,
{0.699828625 ,0.289877892 ,1.82873869 }	,
{0.742934048 ,0.147778139 ,1.82873869 }	,
{1.01599336 ,0.420837611 ,1.64582133 }	,
{0.742934048 ,0.147778139 ,1.82873869 }	,
{1.07857275 ,0.214540839 ,1.64582133 }	,
{1.52054119 ,0.629828036 ,-1.09970260 }	,
{1.68953454 ,0.699827731 ,-0.757488072 }	,
{1.79360032 ,0.356768847 ,-0.757488072 }	,
{1.52054119 ,0.629828036 ,-1.09970260 }	,
{1.79360032 ,0.356768847 ,-0.757488072 }	,
{1.61419773 ,0.321083218 ,-1.09970260 }	,
{1.29311395 ,0.535624743 ,1.39965606 }	,
{1.01599336 ,0.420837611 ,1.64582133 }	,
{1.07857275 ,0.214540839 ,1.64582133 }	,
{1.29311395 ,0.535624743 ,1.39965606 }	,
{1.07857275 ,0.214540839 ,1.64582133 }	,
{1.37276244 ,0.273058832 ,1.39965606 }	,
{0.378744781 ,0.0753363743 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.386164784 ,-6.46547278e-07 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.378744274 ,0.0753363147 ,-1.94137871 }	,
{0.386164337 ,-6.09677841e-07 ,-1.94137871 }	,
{1.90407574 ,0.378743440 ,-0.386164010 }	,
{1.94137907 ,0.386163592 ,1.49441490e-07 }	,
{1.97941303 ,-7.49781691e-07 ,1.49441490e-07 }	,
{1.90407574 ,0.378743440 ,-0.386164010 }	,
{1.97941303 ,-7.49781691e-07 ,1.49441490e-07 }	,
{1.94137859 ,-7.79277229e-07 ,-0.386164010 }	,
{0.742934048 ,0.147778139 ,1.82873869 }	,
{0.378744781 ,0.0753363743 ,1.94137859 }	,
{0.386164784 ,-6.46547278e-07 ,1.94137859 }	,
{0.742934048 ,0.147778139 ,1.82873869 }	,
{0.386164784 ,-6.46547278e-07 ,1.94137859 }	,
{0.757488906 ,-6.31799480e-07 ,1.82873869 }	,
{1.79360032 ,0.356768847 ,-0.757488072 }	,
{1.90407574 ,0.378743440 ,-0.386164010 }	,
{1.94137859 ,-7.79277229e-07 ,-0.386164010 }	,
{1.79360032 ,0.356768847 ,-0.757488072 }	,
{1.94137859 ,-7.79277229e-07 ,-0.386164010 }	,
{1.82873905 ,-4.54826221e-07 ,-0.757488072 }	,
{1.07857275 ,0.214540839 ,1.64582133 }	,
{0.742934048 ,0.147778139 ,1.82873869 }	,
{0.757488906 ,-6.31799480e-07 ,1.82873869 }	,
{1.07857275 ,0.214540839 ,1.64582133 }	,
{0.757488906 ,-6.31799480e-07 ,1.82873869 }	,
{1.09970319 ,-6.17051683e-07 ,1.64582133 }	,
{1.61419773 ,0.321083218 ,-1.09970260 }	,
{1.79360032 ,0.356768847 ,-0.757488072 }	,
{1.82873905 ,-4.54826221e-07 ,-0.757488072 }	,
{1.61419773 ,0.321083218 ,-1.09970260 }	,
{1.82873905 ,-4.54826221e-07 ,-0.757488072 }	,
{1.64582169 ,-6.61295019e-07 ,-1.09970260 }	,
{1.37276244 ,0.273058832 ,1.39965606 }	,
{1.07857275 ,0.214540839 ,1.64582133 }	,
{1.09970319 ,-6.17051683e-07 ,1.64582133 }	,
{1.37276244 ,0.273058832 ,1.39965606 }	,
{1.09970319 ,-6.17051683e-07 ,1.64582133 }	,
{1.39965641 ,-6.31799480e-07 ,1.39965606 }	,
{1.37276244 ,0.273058832 ,-1.39965606 }	,
{1.61419773 ,0.321083218 ,-1.09970260 }	,
{1.64582169 ,-6.61295019e-07 ,-1.09970260 }	,
{1.37276244 ,0.273058832 ,-1.39965606 }	,
{1.64582169 ,-6.61295019e-07 ,-1.09970260 }	,
{1.39965641 ,-6.31799480e-07 ,-1.39965606 }	,
{1.61419773 ,0.321083218 ,1.09970260 }	,
{1.37276244 ,0.273058832 ,1.39965606 }	,
{1.39965641 ,-6.31799480e-07 ,1.39965606 }	,
{1.61419773 ,0.321083218 ,1.09970260 }	,
{1.39965641 ,-6.31799480e-07 ,1.39965606 }	,
{1.64582169 ,-6.61295019e-07 ,1.09970260 }	,
{1.07857263 ,0.214540750 ,-1.64582145 }	,
{1.37276244 ,0.273058832 ,-1.39965606 }	,
{1.39965641 ,-6.31799480e-07 ,-1.39965606 }	,
{1.07857263 ,0.214540750 ,-1.64582145 }	,
{1.39965641 ,-6.31799480e-07 ,-1.39965606 }	,
{1.09970295 ,-6.76042816e-07 ,-1.64582145 }	,
{1.79360032 ,0.356768727 ,0.757488370 }	,
{1.61419773 ,0.321083218 ,1.09970260 }	,
{1.64582169 ,-6.61295019e-07 ,1.09970260 }	,
{1.79360032 ,0.356768727 ,0.757488370 }	,
{1.64582169 ,-6.61295019e-07 ,1.09970260 }	,
{1.82873905 ,-5.43312865e-07 ,0.757488370 }	,
{0.742933750 ,0.147778109 ,-1.82873893 }	,
{1.07857263 ,0.214540750 ,-1.64582145 }	,
{1.09970295 ,-6.76042816e-07 ,-1.64582145 }	,
{0.742933750 ,0.147778109 ,-1.82873893 }	,
{1.09970295 ,-6.76042816e-07 ,-1.64582145 }	,
{0.757488608 ,-6.02303942e-07 ,-1.82873893 }	,
{1.90407574 ,0.378743440 ,0.386164308 }	,
{1.79360032 ,0.356768727 ,0.757488370 }	,
{1.82873905 ,-5.43312865e-07 ,0.757488370 }	,
{1.90407574 ,0.378743440 ,0.386164308 }	,
{1.82873905 ,-5.43312865e-07 ,0.757488370 }	,
{1.94137859 ,-7.79277229e-07 ,0.386164308 }	,
{0.378744274 ,0.0753363147 ,-1.94137871 }	,
{0.742933750 ,0.147778109 ,-1.82873893 }	,
{0.757488608 ,-6.02303942e-07 ,-1.82873893 }	,
{0.378744274 ,0.0753363147 ,-1.94137871 }	,
{0.757488608 ,-6.02303942e-07 ,-1.82873893 }	,
{0.386164337 ,-6.09677841e-07 ,-1.94137871 }	,
{1.94137907 ,0.386163592 ,1.49441490e-07 }	,
{1.90407574 ,0.378743440 ,0.386164308 }	,
{1.94137859 ,-7.79277229e-07 ,0.386164308 }	,
{1.94137907 ,0.386163592 ,1.49441490e-07 }	,
{1.94137859 ,-7.79277229e-07 ,0.386164308 }	,
{1.97941303 ,-7.49781691e-07 ,1.49441490e-07 }	,
{1.64582169 ,-6.61295019e-07 ,1.09970260 }	,
{1.39965641 ,-6.31799480e-07 ,1.39965606 }	,
{1.37276232 ,-0.273060024 ,1.39965606 }	,
{1.64582169 ,-6.61295019e-07 ,1.09970260 }	,
{1.37276232 ,-0.273060024 ,1.39965606 }	,
{1.61419761 ,-0.321084529 ,1.09970260 }	,
{1.09970295 ,-6.76042816e-07 ,-1.64582145 }	,
{1.39965641 ,-6.31799480e-07 ,-1.39965606 }	,
{1.37276232 ,-0.273060024 ,-1.39965606 }	,
{1.09970295 ,-6.76042816e-07 ,-1.64582145 }	,
{1.37276232 ,-0.273060024 ,-1.39965606 }	,
{1.07857251 ,-0.214542091 ,-1.64582145 }	,
{1.82873905 ,-5.43312865e-07 ,0.757488370 }	,
{1.64582169 ,-6.61295019e-07 ,1.09970260 }	,
{1.61419761 ,-0.321084529 ,1.09970260 }	,
{1.82873905 ,-5.43312865e-07 ,0.757488370 }	,
{1.61419761 ,-0.321084529 ,1.09970260 }	,
{1.79360032 ,-0.356769830 ,0.757488370 }	,
{0.757488608 ,-6.02303942e-07 ,-1.82873893 }	,
{1.09970295 ,-6.76042816e-07 ,-1.64582145 }	,
{1.07857251 ,-0.214542091 ,-1.64582145 }	,
{0.757488608 ,-6.02303942e-07 ,-1.82873893 }	,
{1.07857251 ,-0.214542091 ,-1.64582145 }	,
{0.742933691 ,-0.147779301 ,-1.82873893 }	,
{1.94137859 ,-7.79277229e-07 ,0.386164308 }	,
{1.82873905 ,-5.43312865e-07 ,0.757488370 }	,
{1.79360032 ,-0.356769830 ,0.757488370 }	,
{1.94137859 ,-7.79277229e-07 ,0.386164308 }	,
{1.79360032 ,-0.356769830 ,0.757488370 }	,
{1.90407550 ,-0.378744960 ,0.386164308 }	,
{0.386164337 ,-6.09677841e-07 ,-1.94137871 }	,
{0.757488608 ,-6.02303942e-07 ,-1.82873893 }	,
{0.742933691 ,-0.147779301 ,-1.82873893 }	,
{0.386164337 ,-6.09677841e-07 ,-1.94137871 }	,
{0.742933691 ,-0.147779301 ,-1.82873893 }	,
{0.378744274 ,-0.0753375366 ,-1.94137871 }	,
{1.97941303 ,-7.49781691e-07 ,1.49441490e-07 }	,
{1.94137859 ,-7.79277229e-07 ,0.386164308 }	,
{1.90407550 ,-0.378744960 ,0.386164308 }	,
{1.97941303 ,-7.49781691e-07 ,1.49441490e-07 }	,
{1.90407550 ,-0.378744960 ,0.386164308 }	,
{1.94137907 ,-0.386165053 ,1.49441490e-07 }	,
{0.386164784 ,-6.46547278e-07 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.378744751 ,-0.0753376633 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.386164337 ,-6.09677841e-07 ,-1.94137871 }	,
{0.378744274 ,-0.0753375366 ,-1.94137871 }	,
{1.94137859 ,-7.79277229e-07 ,-0.386164010 }	,
{1.97941303 ,-7.49781691e-07 ,1.49441490e-07 }	,
{1.94137907 ,-0.386165053 ,1.49441490e-07 }	,
{1.94137859 ,-7.79277229e-07 ,-0.386164010 }	,
{1.94137907 ,-0.386165053 ,1.49441490e-07 }	,
{1.90407550 ,-0.378744960 ,-0.386164010 }	,
{0.757488906 ,-6.31799480e-07 ,1.82873869 }	,
{0.386164784 ,-6.46547278e-07 ,1.94137859 }	,
{0.378744751 ,-0.0753376633 ,1.94137859 }	,
{0.757488906 ,-6.31799480e-07 ,1.82873869 }	,
{0.378744751 ,-0.0753376633 ,1.94137859 }	,
{0.742933989 ,-0.147779390 ,1.82873869 }	,
{1.82873905 ,-4.54826221e-07 ,-0.757488072 }	,
{1.94137859 ,-7.79277229e-07 ,-0.386164010 }	,
{1.90407550 ,-0.378744960 ,-0.386164010 }	,
{1.82873905 ,-4.54826221e-07 ,-0.757488072 }	,
{1.90407550 ,-0.378744960 ,-0.386164010 }	,
{1.79360032 ,-0.356769741 ,-0.757488072 }	,
{1.09970319 ,-6.17051683e-07 ,1.64582133 }	,
{0.757488906 ,-6.31799480e-07 ,1.82873869 }	,
{0.742933989 ,-0.147779390 ,1.82873869 }	,
{1.09970319 ,-6.17051683e-07 ,1.64582133 }	,
{0.742933989 ,-0.147779390 ,1.82873869 }	,
{1.07857275 ,-0.214542076 ,1.64582133 }	,
{1.64582169 ,-6.61295019e-07 ,-1.09970260 }	,
{1.82873905 ,-4.54826221e-07 ,-0.757488072 }	,
{1.79360032 ,-0.356769741 ,-0.757488072 }	,
{1.64582169 ,-6.61295019e-07 ,-1.09970260 }	,
{1.79360032 ,-0.356769741 ,-0.757488072 }	,
{1.61419761 ,-0.321084529 ,-1.09970260 }	,
{1.39965641 ,-6.31799480e-07 ,1.39965606 }	,
{1.09970319 ,-6.17051683e-07 ,1.64582133 }	,
{1.07857275 ,-0.214542076 ,1.64582133 }	,
{1.39965641 ,-6.31799480e-07 ,1.39965606 }	,
{1.07857275 ,-0.214542076 ,1.64582133 }	,
{1.37276232 ,-0.273060024 ,1.39965606 }	,
{1.39965641 ,-6.31799480e-07 ,-1.39965606 }	,
{1.64582169 ,-6.61295019e-07 ,-1.09970260 }	,
{1.61419761 ,-0.321084529 ,-1.09970260 }	,
{1.39965641 ,-6.31799480e-07 ,-1.39965606 }	,
{1.61419761 ,-0.321084529 ,-1.09970260 }	,
{1.37276232 ,-0.273060024 ,-1.39965606 }	,
{1.90407550 ,-0.378744960 ,-0.386164010 }	,
{1.94137907 ,-0.386165053 ,1.49441490e-07 }	,
{1.82873905 ,-0.757489264 ,1.49441490e-07 }	,
{1.90407550 ,-0.378744960 ,-0.386164010 }	,
{1.82873905 ,-0.757489264 ,1.49441490e-07 }	,
{1.79359984 ,-0.742934167 ,-0.386164010 }	,
{0.742933989 ,-0.147779390 ,1.82873869 }	,
{0.378744751 ,-0.0753376633 ,1.94137859 }	,
{0.356769711 ,-0.147779509 ,1.94137859 }	,
{0.742933989 ,-0.147779390 ,1.82873869 }	,
{0.356769711 ,-0.147779509 ,1.94137859 }	,
{0.699828506 ,-0.289879054 ,1.82873869 }	,
{1.79360032 ,-0.356769741 ,-0.757488072 }	,
{1.90407550 ,-0.378744960 ,-0.386164010 }	,
{1.79359984 ,-0.742934167 ,-0.386164010 }	,
{1.79360032 ,-0.356769741 ,-0.757488072 }	,
{1.79359984 ,-0.742934167 ,-0.386164010 }	,
{1.68953454 ,-0.699828565 ,-0.757488072 }	,
{1.07857275 ,-0.214542076 ,1.64582133 }	,
{0.742933989 ,-0.147779390 ,1.82873869 }	,
{0.699828506 ,-0.289879054 ,1.82873869 }	,
{1.07857275 ,-0.214542076 ,1.64582133 }	,
{0.699828506 ,-0.289879054 ,1.82873869 }	,
{1.01599324 ,-0.420838773 ,1.64582133 }	,
{1.61419761 ,-0.321084529 ,-1.09970260 }	,
{1.79360032 ,-0.356769741 ,-0.757488072 }	,
{1.68953454 ,-0.699828565 ,-0.757488072 }	,
{1.61419761 ,-0.321084529 ,-1.09970260 }	,
{1.68953454 ,-0.699828565 ,-0.757488072 }	,
{1.52054083 ,-0.629829347 ,-1.09970260 }	,
{1.37276232 ,-0.273060024 ,1.39965606 }	,
{1.07857275 ,-0.214542076 ,1.64582133 }	,
{1.01599324 ,-0.420838773 ,1.64582133 }	,
{1.37276232 ,-0.273060024 ,1.39965606 }	,
{1.01599324 ,-0.420838773 ,1.64582133 }	,
{1.29311383 ,-0.535625875 ,1.39965606 }	,
{1.37276232 ,-0.273060024 ,-1.39965606 }	,
{1.61419761 ,-0.321084529 ,-1.09970260 }	,
{1.52054083 ,-0.629829347 ,-1.09970260 }	,
{1.37276232 ,-0.273060024 ,-1.39965606 }	,
{1.52054083 ,-0.629829347 ,-1.09970260 }	,
{1.29311383 ,-0.535625875 ,-1.39965606 }	,
{1.61419761 ,-0.321084529 ,1.09970260 }	,
{1.37276232 ,-0.273060024 ,1.39965606 }	,
{1.29311383 ,-0.535625875 ,1.39965606 }	,
{1.61419761 ,-0.321084529 ,1.09970260 }	,
{1.29311383 ,-0.535625875 ,1.39965606 }	,
{1.52054083 ,-0.629829347 ,1.09970260 }	,
{1.07857251 ,-0.214542091 ,-1.64582145 }	,
{1.37276232 ,-0.273060024 ,-1.39965606 }	,
{1.29311383 ,-0.535625875 ,-1.39965606 }	,
{1.07857251 ,-0.214542091 ,-1.64582145 }	,
{1.29311383 ,-0.535625875 ,-1.39965606 }	,
{1.01599300 ,-0.420838773 ,-1.64582145 }	,
{1.79360032 ,-0.356769830 ,0.757488370 }	,
{1.61419761 ,-0.321084529 ,1.09970260 }	,
{1.52054083 ,-0.629829347 ,1.09970260 }	,
{1.79360032 ,-0.356769830 ,0.757488370 }	,
{1.52054083 ,-0.629829347 ,1.09970260 }	,
{1.68953454 ,-0.699828684 ,0.757488370 }	,
{0.742933691 ,-0.147779301 ,-1.82873893 }	,
{1.07857251 ,-0.214542091 ,-1.64582145 }	,
{1.01599300 ,-0.420838773 ,-1.64582145 }	,
{0.742933691 ,-0.147779301 ,-1.82873893 }	,
{1.01599300 ,-0.420838773 ,-1.64582145 }	,
{0.699828207 ,-0.289878935 ,-1.82873893 }	,
{1.90407550 ,-0.378744960 ,0.386164308 }	,
{1.79360032 ,-0.356769830 ,0.757488370 }	,
{1.68953454 ,-0.699828684 ,0.757488370 }	,
{1.90407550 ,-0.378744960 ,0.386164308 }	,
{1.68953454 ,-0.699828684 ,0.757488370 }	,
{1.79359984 ,-0.742934167 ,0.386164308 }	,
{0.378744274 ,-0.0753375366 ,-1.94137871 }	,
{0.742933691 ,-0.147779301 ,-1.82873893 }	,
{0.699828207 ,-0.289878935 ,-1.82873893 }	,
{0.378744274 ,-0.0753375366 ,-1.94137871 }	,
{0.699828207 ,-0.289878935 ,-1.82873893 }	,
{0.356769294 ,-0.147779301 ,-1.94137871 }	,
{1.94137907 ,-0.386165053 ,1.49441490e-07 }	,
{1.90407550 ,-0.378744960 ,0.386164308 }	,
{1.79359984 ,-0.742934167 ,0.386164308 }	,
{1.94137907 ,-0.386165053 ,1.49441490e-07 }	,
{1.79359984 ,-0.742934167 ,0.386164308 }	,
{1.82873905 ,-0.757489264 ,1.49441490e-07 }	,
{0.378744751 ,-0.0753376633 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.356769711 ,-0.147779509 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.378744274 ,-0.0753375366 ,-1.94137871 }	,
{0.356769294 ,-0.147779301 ,-1.94137871 }	,
{1.01599300 ,-0.420838773 ,-1.64582145 }	,
{1.29311383 ,-0.535625875 ,-1.39965606 }	,
{1.16377175 ,-0.777607918 ,-1.39965606 }	,
{1.01599300 ,-0.420838773 ,-1.64582145 }	,
{1.16377175 ,-0.777607918 ,-1.39965606 }	,
{0.914369464 ,-0.610962808 ,-1.64582145 }	,
{1.68953454 ,-0.699828684 ,0.757488370 }	,
{1.52054083 ,-0.629829347 ,1.09970260 }	,
{1.36845052 ,-0.914370179 ,1.09970260 }	,
{1.68953454 ,-0.699828684 ,0.757488370 }	,
{1.36845052 ,-0.914370179 ,1.09970260 }	,
{1.52054095 ,-1.01599336 ,0.757488370 }	,
{0.699828207 ,-0.289878935 ,-1.82873893 }	,
{1.01599300 ,-0.420838773 ,-1.64582145 }	,
{0.914369464 ,-0.610962808 ,-1.64582145 }	,
{0.699828207 ,-0.289878935 ,-1.82873893 }	,
{0.914369464 ,-0.610962808 ,-1.64582145 }	,
{0.629828691 ,-0.420838714 ,-1.82873893 }	,
{1.79359984 ,-0.742934167 ,0.386164308 }	,
{1.68953454 ,-0.699828684 ,0.757488370 }	,
{1.52054095 ,-1.01599336 ,0.757488370 }	,
{1.79359984 ,-0.742934167 ,0.386164308 }	,
{1.52054095 ,-1.01599336 ,0.757488370 }	,
{1.61419713 ,-1.07857287 ,0.386164308 }	,
{0.356769294 ,-0.147779301 ,-1.94137871 }	,
{0.699828207 ,-0.289878935 ,-1.82873893 }	,
{0.629828691 ,-0.420838714 ,-1.82873893 }	,
{0.356769294 ,-0.147779301 ,-1.94137871 }	,
{0.629828691 ,-0.420838714 ,-1.82873893 }	,
{0.321083874 ,-0.214542031 ,-1.94137871 }	,
{1.82873905 ,-0.757489264 ,1.49441490e-07 }	,
{1.79359984 ,-0.742934167 ,0.386164308 }	,
{1.61419713 ,-1.07857287 ,0.386164308 }	,
{1.82873905 ,-0.757489264 ,1.49441490e-07 }	,
{1.61419713 ,-1.07857287 ,0.386164308 }	,
{1.64582157 ,-1.09970355 ,1.49441490e-07 }	,
{0.356769711 ,-0.147779509 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.321084231 ,-0.214542300 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.356769294 ,-0.147779301 ,-1.94137871 }	,
{0.321083874 ,-0.214542031 ,-1.94137871 }	,
{1.79359984 ,-0.742934167 ,-0.386164010 }	,
{1.82873905 ,-0.757489264 ,1.49441490e-07 }	,
{1.64582157 ,-1.09970355 ,1.49441490e-07 }	,
{1.79359984 ,-0.742934167 ,-0.386164010 }	,
{1.64582157 ,-1.09970355 ,1.49441490e-07 }	,
{1.61419713 ,-1.07857287 ,-0.386164010 }	,
{0.699828506 ,-0.289879054 ,1.82873869 }	,
{0.356769711 ,-0.147779509 ,1.94137859 }	,
{0.321084231 ,-0.214542300 ,1.94137859 }	,
{0.699828506 ,-0.289879054 ,1.82873869 }	,
{0.321084231 ,-0.214542300 ,1.94137859 }	,
{0.629828990 ,-0.420838833 ,1.82873869 }	,
{1.68953454 ,-0.699828565 ,-0.757488072 }	,
{1.79359984 ,-0.742934167 ,-0.386164010 }	,
{1.61419713 ,-1.07857287 ,-0.386164010 }	,
{1.68953454 ,-0.699828565 ,-0.757488072 }	,
{1.61419713 ,-1.07857287 ,-0.386164010 }	,
{1.52054095 ,-1.01599336 ,-0.757488072 }	,
{1.01599324 ,-0.420838773 ,1.64582133 }	,
{0.699828506 ,-0.289879054 ,1.82873869 }	,
{0.629828990 ,-0.420838833 ,1.82873869 }	,
{1.01599324 ,-0.420838773 ,1.64582133 }	,
{0.629828990 ,-0.420838833 ,1.82873869 }	,
{0.914369702 ,-0.610962868 ,1.64582133 }	,
{1.52054083 ,-0.629829347 ,-1.09970260 }	,
{1.68953454 ,-0.699828565 ,-0.757488072 }	,
{1.52054095 ,-1.01599336 ,-0.757488072 }	,
{1.52054083 ,-0.629829347 ,-1.09970260 }	,
{1.52054095 ,-1.01599336 ,-0.757488072 }	,
{1.36845052 ,-0.914370179 ,-1.09970260 }	,
{1.29311383 ,-0.535625875 ,1.39965606 }	,
{1.01599324 ,-0.420838773 ,1.64582133 }	,
{0.914369702 ,-0.610962868 ,1.64582133 }	,
{1.29311383 ,-0.535625875 ,1.39965606 }	,
{0.914369702 ,-0.610962868 ,1.64582133 }	,
{1.16377175 ,-0.777607918 ,1.39965606 }	,
{1.29311383 ,-0.535625875 ,-1.39965606 }	,
{1.52054083 ,-0.629829347 ,-1.09970260 }	,
{1.36845052 ,-0.914370179 ,-1.09970260 }	,
{1.29311383 ,-0.535625875 ,-1.39965606 }	,
{1.36845052 ,-0.914370179 ,-1.09970260 }	,
{1.16377175 ,-0.777607918 ,-1.39965606 }	,
{1.52054083 ,-0.629829347 ,1.09970260 }	,
{1.29311383 ,-0.535625875 ,1.39965606 }	,
{1.16377175 ,-0.777607918 ,1.39965606 }	,
{1.52054083 ,-0.629829347 ,1.09970260 }	,
{1.16377175 ,-0.777607918 ,1.39965606 }	,
{1.36845052 ,-0.914370179 ,1.09970260 }	,
{1.52054095 ,-1.01599336 ,-0.757488072 }	,
{1.61419713 ,-1.07857287 ,-0.386164010 }	,
{1.37276185 ,-1.37276256 ,-0.386164010 }	,
{1.52054095 ,-1.01599336 ,-0.757488072 }	,
{1.37276185 ,-1.37276256 ,-0.386164010 }	,
{1.29311383 ,-1.29311419 ,-0.757488072 }	,
{0.914369702 ,-0.610962868 ,1.64582133 }	,
{0.629828990 ,-0.420838833 ,1.82873869 }	,
{0.535625517 ,-0.535626054 ,1.82873869 }	,
{0.914369702 ,-0.610962868 ,1.64582133 }	,
{0.535625517 ,-0.535626054 ,1.82873869 }	,
{0.777607441 ,-0.777608037 ,1.64582133 }	,
{1.36845052 ,-0.914370179 ,-1.09970260 }	,
{1.52054095 ,-1.01599336 ,-0.757488072 }	,
{1.29311383 ,-1.29311419 ,-0.757488072 }	,
{1.36845052 ,-0.914370179 ,-1.09970260 }	,
{1.29311383 ,-1.29311419 ,-0.757488072 }	,
{1.16377139 ,-1.16377223 ,-1.09970260 }	,
{1.16377175 ,-0.777607918 ,1.39965606 }	,
{0.914369702 ,-0.610962868 ,1.64582133 }	,
{0.777607441 ,-0.777608037 ,1.64582133 }	,
{1.16377175 ,-0.777607918 ,1.39965606 }	,
{0.777607441 ,-0.777608037 ,1.64582133 }	,
{0.989706397 ,-0.989706993 ,1.39965606 }	,
{1.16377175 ,-0.777607918 ,-1.39965606 }	,
{1.36845052 ,-0.914370179 ,-1.09970260 }	,
{1.16377139 ,-1.16377223 ,-1.09970260 }	,
{1.16377175 ,-0.777607918 ,-1.39965606 }	,
{1.16377139 ,-1.16377223 ,-1.09970260 }	,
{0.989706397 ,-0.989706993 ,-1.39965606 }	,
{1.36845052 ,-0.914370179 ,1.09970260 }	,
{1.16377175 ,-0.777607918 ,1.39965606 }	,
{0.989706397 ,-0.989706993 ,1.39965606 }	,
{1.36845052 ,-0.914370179 ,1.09970260 }	,
{0.989706397 ,-0.989706993 ,1.39965606 }	,
{1.16377139 ,-1.16377223 ,1.09970260 }	,
{0.914369464 ,-0.610962808 ,-1.64582145 }	,
{1.16377175 ,-0.777607918 ,-1.39965606 }	,
{0.989706397 ,-0.989706993 ,-1.39965606 }	,
{0.914369464 ,-0.610962808 ,-1.64582145 }	,
{0.989706397 ,-0.989706993 ,-1.39965606 }	,
{0.777607262 ,-0.777607918 ,-1.64582145 }	,
{1.52054095 ,-1.01599336 ,0.757488370 }	,
{1.36845052 ,-0.914370179 ,1.09970260 }	,
{1.16377139 ,-1.16377223 ,1.09970260 }	,
{1.52054095 ,-1.01599336 ,0.757488370 }	,
{1.16377139 ,-1.16377223 ,1.09970260 }	,
{1.29311383 ,-1.29311419 ,0.757488370 }	,
{0.629828691 ,-0.420838714 ,-1.82873893 }	,
{0.914369464 ,-0.610962808 ,-1.64582145 }	,
{0.777607262 ,-0.777607918 ,-1.64582145 }	,
{0.629828691 ,-0.420838714 ,-1.82873893 }	,
{0.777607262 ,-0.777607918 ,-1.64582145 }	,
{0.535625219 ,-0.535625875 ,-1.82873893 }	,
{1.61419713 ,-1.07857287 ,0.386164308 }	,
{1.52054095 ,-1.01599336 ,0.757488370 }	,
{1.29311383 ,-1.29311419 ,0.757488370 }	,
{1.61419713 ,-1.07857287 ,0.386164308 }	,
{1.29311383 ,-1.29311419 ,0.757488370 }	,
{1.37276185 ,-1.37276256 ,0.386164308 }	,
{0.321083874 ,-0.214542031 ,-1.94137871 }	,
{0.629828691 ,-0.420838714 ,-1.82873893 }	,
{0.535625219 ,-0.535625875 ,-1.82873893 }	,
{0.321083874 ,-0.214542031 ,-1.94137871 }	,
{0.535625219 ,-0.535625875 ,-1.82873893 }	,
{0.273059368 ,-0.273060024 ,-1.94137871 }	,
{1.64582157 ,-1.09970355 ,1.49441490e-07 }	,
{1.61419713 ,-1.07857287 ,0.386164308 }	,
{1.37276185 ,-1.37276256 ,0.386164308 }	,
{1.64582157 ,-1.09970355 ,1.49441490e-07 }	,
{1.37276185 ,-1.37276256 ,0.386164308 }	,
{1.39965618 ,-1.39965701 ,1.49441490e-07 }	,
{0.321084231 ,-0.214542300 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.273059666 ,-0.273060352 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.321083874 ,-0.214542031 ,-1.94137871 }	,
{0.273059368 ,-0.273060024 ,-1.94137871 }	,
{1.61419713 ,-1.07857287 ,-0.386164010 }	,
{1.64582157 ,-1.09970355 ,1.49441490e-07 }	,
{1.39965618 ,-1.39965701 ,1.49441490e-07 }	,
{1.61419713 ,-1.07857287 ,-0.386164010 }	,
{1.39965618 ,-1.39965701 ,1.49441490e-07 }	,
{1.37276185 ,-1.37276256 ,-0.386164010 }	,
{0.629828990 ,-0.420838833 ,1.82873869 }	,
{0.321084231 ,-0.214542300 ,1.94137859 }	,
{0.273059666 ,-0.273060352 ,1.94137859 }	,
{0.629828990 ,-0.420838833 ,1.82873869 }	,
{0.273059666 ,-0.273060352 ,1.94137859 }	,
{0.535625517 ,-0.535626054 ,1.82873869 }	,
{0.535625219 ,-0.535625875 ,-1.82873893 }	,
{0.777607262 ,-0.777607918 ,-1.64582145 }	,
{0.610962033 ,-0.914370060 ,-1.64582145 }	,
{0.535625219 ,-0.535625875 ,-1.82873893 }	,
{0.610962033 ,-0.914370060 ,-1.64582145 }	,
{0.420838058 ,-0.629829228 ,-1.82873893 }	,
{1.37276185 ,-1.37276256 ,0.386164308 }	,
{1.29311383 ,-1.29311419 ,0.757488370 }	,
{1.01599312 ,-1.52054143 ,0.757488370 }	,
{1.37276185 ,-1.37276256 ,0.386164308 }	,
{1.01599312 ,-1.52054143 ,0.757488370 }	,
{1.07857203 ,-1.61419785 ,0.386164308 }	,
{0.273059368 ,-0.273060024 ,-1.94137871 }	,
{0.535625219 ,-0.535625875 ,-1.82873893 }	,
{0.420838058 ,-0.629829228 ,-1.82873893 }	,
{0.273059368 ,-0.273060024 ,-1.94137871 }	,
{0.420838058 ,-0.629829228 ,-1.82873893 }	,
{0.214541376 ,-0.321084499 ,-1.94137871 }	,
{1.39965618 ,-1.39965701 ,1.49441490e-07 }	,
{1.37276185 ,-1.37276256 ,0.386164308 }	,
{1.07857203 ,-1.61419785 ,0.386164308 }	,
{1.39965618 ,-1.39965701 ,1.49441490e-07 }	,
{1.07857203 ,-1.61419785 ,0.386164308 }	,
{1.09970272 ,-1.64582229 ,1.49441490e-07 }	,
{0.273059666 ,-0.273060352 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.214541584 ,-0.321084857 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.273059368 ,-0.273060024 ,-1.94137871 }	,
{0.214541376 ,-0.321084499 ,-1.94137871 }	,
{1.37276185 ,-1.37276256 ,-0.386164010 }	,
{1.39965618 ,-1.39965701 ,1.49441490e-07 }	,
{1.09970272 ,-1.64582229 ,1.49441490e-07 }	,
{1.37276185 ,-1.37276256 ,-0.386164010 }	,
{1.09970272 ,-1.64582229 ,1.49441490e-07 }	,
{1.07857203 ,-1.61419785 ,-0.386164010 }	,
{0.535625517 ,-0.535626054 ,1.82873869 }	,
{0.273059666 ,-0.273060352 ,1.94137859 }	,
{0.214541584 ,-0.321084857 ,1.94137859 }	,
{0.535625517 ,-0.535626054 ,1.82873869 }	,
{0.214541584 ,-0.321084857 ,1.94137859 }	,
{0.420838267 ,-0.629829466 ,1.82873869 }	,
{1.29311383 ,-1.29311419 ,-0.757488072 }	,
{1.37276185 ,-1.37276256 ,-0.386164010 }	,
{1.07857203 ,-1.61419785 ,-0.386164010 }	,
{1.29311383 ,-1.29311419 ,-0.757488072 }	,
{1.07857203 ,-1.61419785 ,-0.386164010 }	,
{1.01599312 ,-1.52054143 ,-0.757488072 }	,
{0.777607441 ,-0.777608037 ,1.64582133 }	,
{0.535625517 ,-0.535626054 ,1.82873869 }	,
{0.420838267 ,-0.629829466 ,1.82873869 }	,
{0.777607441 ,-0.777608037 ,1.64582133 }	,
{0.420838267 ,-0.629829466 ,1.82873869 }	,
{0.610962212 ,-0.914370179 ,1.64582133 }	,
{1.16377139 ,-1.16377223 ,-1.09970260 }	,
{1.29311383 ,-1.29311419 ,-0.757488072 }	,
{1.01599312 ,-1.52054143 ,-0.757488072 }	,
{1.16377139 ,-1.16377223 ,-1.09970260 }	,
{1.01599312 ,-1.52054143 ,-0.757488072 }	,
{0.914369285 ,-1.36845112 ,-1.09970260 }	,
{0.989706397 ,-0.989706993 ,1.39965606 }	,
{0.777607441 ,-0.777608037 ,1.64582133 }	,
{0.610962212 ,-0.914370179 ,1.64582133 }	,
{0.989706397 ,-0.989706993 ,1.39965606 }	,
{0.610962212 ,-0.914370179 ,1.64582133 }	,
{0.777607262 ,-1.16377223 ,1.39965606 }	,
{0.989706397 ,-0.989706993 ,-1.39965606 }	,
{1.16377139 ,-1.16377223 ,-1.09970260 }	,
{0.914369285 ,-1.36845112 ,-1.09970260 }	,
{0.989706397 ,-0.989706993 ,-1.39965606 }	,
{0.914369285 ,-1.36845112 ,-1.09970260 }	,
{0.777607262 ,-1.16377223 ,-1.39965606 }	,
{1.16377139 ,-1.16377223 ,1.09970260 }	,
{0.989706397 ,-0.989706993 ,1.39965606 }	,
{0.777607262 ,-1.16377223 ,1.39965606 }	,
{1.16377139 ,-1.16377223 ,1.09970260 }	,
{0.777607262 ,-1.16377223 ,1.39965606 }	,
{0.914369285 ,-1.36845112 ,1.09970260 }	,
{0.777607262 ,-0.777607918 ,-1.64582145 }	,
{0.989706397 ,-0.989706993 ,-1.39965606 }	,
{0.777607262 ,-1.16377223 ,-1.39965606 }	,
{0.777607262 ,-0.777607918 ,-1.64582145 }	,
{0.777607262 ,-1.16377223 ,-1.39965606 }	,
{0.610962033 ,-0.914370060 ,-1.64582145 }	,
{1.29311383 ,-1.29311419 ,0.757488370 }	,
{1.16377139 ,-1.16377223 ,1.09970260 }	,
{0.914369285 ,-1.36845112 ,1.09970260 }	,
{1.29311383 ,-1.29311419 ,0.757488370 }	,
{0.914369285 ,-1.36845112 ,1.09970260 }	,
{1.01599312 ,-1.52054143 ,0.757488370 }	,
{0.610962212 ,-0.914370179 ,1.64582133 }	,
{0.420838267 ,-0.629829466 ,1.82873869 }	,
{0.289878458 ,-0.699828923 ,1.82873869 }	,
{0.610962212 ,-0.914370179 ,1.64582133 }	,
{0.289878458 ,-0.699828923 ,1.82873869 }	,
{0.420838147 ,-1.01599360 ,1.64582133 }	,
{0.914369285 ,-1.36845112 ,-1.09970260 }	,
{1.01599312 ,-1.52054143 ,-0.757488072 }	,
{0.699828207 ,-1.68953490 ,-0.757488072 }	,
{0.914369285 ,-1.36845112 ,-1.09970260 }	,
{0.699828207 ,-1.68953490 ,-0.757488072 }	,
{0.629828393 ,-1.52054131 ,-1.09970260 }	,
{0.777607262 ,-1.16377223 ,1.39965606 }	,
{0.610962212 ,-0.914370179 ,1.64582133 }	,
{0.420838147 ,-1.01599360 ,1.64582133 }	,
{0.777607262 ,-1.16377223 ,1.39965606 }	,
{0.420838147 ,-1.01599360 ,1.64582133 }	,
{0.535625100 ,-1.29311419 ,1.39965606 }	,
{0.777607262 ,-1.16377223 ,-1.39965606 }	,
{0.914369285 ,-1.36845112 ,-1.09970260 }	,
{0.629828393 ,-1.52054131 ,-1.09970260 }	,
{0.777607262 ,-1.16377223 ,-1.39965606 }	,
{0.629828393 ,-1.52054131 ,-1.09970260 }	,
{0.535625100 ,-1.29311419 ,-1.39965606 }	,
{0.914369285 ,-1.36845112 ,1.09970260 }	,
{0.777607262 ,-1.16377223 ,1.39965606 }	,
{0.535625100 ,-1.29311419 ,1.39965606 }	,
{0.914369285 ,-1.36845112 ,1.09970260 }	,
{0.535625100 ,-1.29311419 ,1.39965606 }	,
{0.629828393 ,-1.52054131 ,1.09970260 }	,
{0.610962033 ,-0.914370060 ,-1.64582145 }	,
{0.777607262 ,-1.16377223 ,-1.39965606 }	,
{0.535625100 ,-1.29311419 ,-1.39965606 }	,
{0.610962033 ,-0.914370060 ,-1.64582145 }	,
{0.535625100 ,-1.29311419 ,-1.39965606 }	,
{0.420837969 ,-1.01599336 ,-1.64582145 }	,
{1.01599312 ,-1.52054143 ,0.757488370 }	,
{0.914369285 ,-1.36845112 ,1.09970260 }	,
{0.629828393 ,-1.52054131 ,1.09970260 }	,
{1.01599312 ,-1.52054143 ,0.757488370 }	,
{0.629828393 ,-1.52054131 ,1.09970260 }	,
{0.699828207 ,-1.68953490 ,0.757488370 }	,
{0.420838058 ,-0.629829228 ,-1.82873893 }	,
{0.610962033 ,-0.914370060 ,-1.64582145 }	,
{0.420837969 ,-1.01599336 ,-1.64582145 }	,
{0.420838058 ,-0.629829228 ,-1.82873893 }	,
{0.420837969 ,-1.01599336 ,-1.64582145 }	,
{0.289878279 ,-0.699828684 ,-1.82873893 }	,
{1.07857203 ,-1.61419785 ,0.386164308 }	,
{1.01599312 ,-1.52054143 ,0.757488370 }	,
{0.699828207 ,-1.68953490 ,0.757488370 }	,
{1.07857203 ,-1.61419785 ,0.386164308 }	,
{0.699828207 ,-1.68953490 ,0.757488370 }	,
{0.742933214 ,-1.79360044 ,0.386164308 }	,
{0.214541376 ,-0.321084499 ,-1.94137871 }	,
{0.420838058 ,-0.629829228 ,-1.82873893 }	,
{0.289878279 ,-0.699828684 ,-1.82873893 }	,
{0.214541376 ,-0.321084499 ,-1.94137871 }	,
{0.289878279 ,-0.699828684 ,-1.82873893 }	,
{0.147778690 ,-0.356769890 ,-1.94137871 }	,
{1.09970272 ,-1.64582229 ,1.49441490e-07 }	,
{1.07857203 ,-1.61419785 ,0.386164308 }	,
{0.742933214 ,-1.79360044 ,0.386164308 }	,
{1.09970272 ,-1.64582229 ,1.49441490e-07 }	,
{0.742933214 ,-1.79360044 ,0.386164308 }	,
{0.757488310 ,-1.82873964 ,1.49441490e-07 }	,
{0.214541584 ,-0.321084857 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.147778824 ,-0.356770277 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.214541376 ,-0.321084499 ,-1.94137871 }	,
{0.147778690 ,-0.356769890 ,-1.94137871 }	,
{1.07857203 ,-1.61419785 ,-0.386164010 }	,
{1.09970272 ,-1.64582229 ,1.49441490e-07 }	,
{0.757488310 ,-1.82873964 ,1.49441490e-07 }	,
{1.07857203 ,-1.61419785 ,-0.386164010 }	,
{0.757488310 ,-1.82873964 ,1.49441490e-07 }	,
{0.742933214 ,-1.79360044 ,-0.386164010 }	,
{0.420838267 ,-0.629829466 ,1.82873869 }	,
{0.214541584 ,-0.321084857 ,1.94137859 }	,
{0.147778824 ,-0.356770277 ,1.94137859 }	,
{0.420838267 ,-0.629829466 ,1.82873869 }	,
{0.147778824 ,-0.356770277 ,1.94137859 }	,
{0.289878458 ,-0.699828923 ,1.82873869 }	,
{1.01599312 ,-1.52054143 ,-0.757488072 }	,
{1.07857203 ,-1.61419785 ,-0.386164010 }	,
{0.742933214 ,-1.79360044 ,-0.386164010 }	,
{1.01599312 ,-1.52054143 ,-0.757488072 }	,
{0.742933214 ,-1.79360044 ,-0.386164010 }	,
{0.699828207 ,-1.68953490 ,-0.757488072 }	,
{0.742933214 ,-1.79360044 ,0.386164308 }	,
{0.699828207 ,-1.68953490 ,0.757488370 }	,
{0.356769353 ,-1.79360068 ,0.757488370 }	,
{0.742933214 ,-1.79360044 ,0.386164308 }	,
{0.356769353 ,-1.79360068 ,0.757488370 }	,
{0.378743976 ,-1.90407598 ,0.386164308 }	,
{0.147778690 ,-0.356769890 ,-1.94137871 }	,
{0.289878279 ,-0.699828684 ,-1.82873893 }	,
{0.147778675 ,-0.742934108 ,-1.82873893 }	,
{0.147778690 ,-0.356769890 ,-1.94137871 }	,
{0.147778675 ,-0.742934108 ,-1.82873893 }	,
{0.0753369182 ,-0.378744841 ,-1.94137871 }	,
{0.757488310 ,-1.82873964 ,1.49441490e-07 }	,
{0.742933214 ,-1.79360044 ,0.386164308 }	,
{0.378743976 ,-1.90407598 ,0.386164308 }	,
{0.757488310 ,-1.82873964 ,1.49441490e-07 }	,
{0.378743976 ,-1.90407598 ,0.386164308 }	,
{0.386164099 ,-1.94137955 ,1.49441490e-07 }	,
{0.147778824 ,-0.356770277 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.0753369778 ,-0.378745258 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.147778690 ,-0.356769890 ,-1.94137871 }	,
{0.0753369182 ,-0.378744841 ,-1.94137871 }	,
{0.742933214 ,-1.79360044 ,-0.386164010 }	,
{0.757488310 ,-1.82873964 ,1.49441490e-07 }	,
{0.386164099 ,-1.94137955 ,1.49441490e-07 }	,
{0.742933214 ,-1.79360044 ,-0.386164010 }	,
{0.386164099 ,-1.94137955 ,1.49441490e-07 }	,
{0.378743976 ,-1.90407598 ,-0.386164010 }	,
{0.289878458 ,-0.699828923 ,1.82873869 }	,
{0.147778824 ,-0.356770277 ,1.94137859 }	,
{0.0753369778 ,-0.378745258 ,1.94137859 }	,
{0.289878458 ,-0.699828923 ,1.82873869 }	,
{0.0753369778 ,-0.378745258 ,1.94137859 }	,
{0.147778794 ,-0.742934346 ,1.82873869 }	,
{0.699828207 ,-1.68953490 ,-0.757488072 }	,
{0.742933214 ,-1.79360044 ,-0.386164010 }	,
{0.378743976 ,-1.90407598 ,-0.386164010 }	,
{0.699828207 ,-1.68953490 ,-0.757488072 }	,
{0.378743976 ,-1.90407598 ,-0.386164010 }	,
{0.356769353 ,-1.79360068 ,-0.757488072 }	,
{0.420838147 ,-1.01599360 ,1.64582133 }	,
{0.289878458 ,-0.699828923 ,1.82873869 }	,
{0.147778794 ,-0.742934346 ,1.82873869 }	,
{0.420838147 ,-1.01599360 ,1.64582133 }	,
{0.147778794 ,-0.742934346 ,1.82873869 }	,
{0.214541450 ,-1.07857311 ,1.64582133 }	,
{0.629828393 ,-1.52054131 ,-1.09970260 }	,
{0.699828207 ,-1.68953490 ,-0.757488072 }	,
{0.356769353 ,-1.79360068 ,-0.757488072 }	,
{0.629828393 ,-1.52054131 ,-1.09970260 }	,
{0.356769353 ,-1.79360068 ,-0.757488072 }	,
{0.321083605 ,-1.61419773 ,-1.09970260 }	,
{0.535625100 ,-1.29311419 ,1.39965606 }	,
{0.420838147 ,-1.01599360 ,1.64582133 }	,
{0.214541450 ,-1.07857311 ,1.64582133 }	,
{0.535625100 ,-1.29311419 ,1.39965606 }	,
{0.214541450 ,-1.07857311 ,1.64582133 }	,
{0.273059279 ,-1.37276268 ,1.39965606 }	,
{0.535625100 ,-1.29311419 ,-1.39965606 }	,
{0.629828393 ,-1.52054131 ,-1.09970260 }	,
{0.321083605 ,-1.61419773 ,-1.09970260 }	,
{0.535625100 ,-1.29311419 ,-1.39965606 }	,
{0.321083605 ,-1.61419773 ,-1.09970260 }	,
{0.273059279 ,-1.37276268 ,-1.39965606 }	,
{0.629828393 ,-1.52054131 ,1.09970260 }	,
{0.535625100 ,-1.29311419 ,1.39965606 }	,
{0.273059279 ,-1.37276268 ,1.39965606 }	,
{0.629828393 ,-1.52054131 ,1.09970260 }	,
{0.273059279 ,-1.37276268 ,1.39965606 }	,
{0.321083605 ,-1.61419773 ,1.09970260 }	,
{0.420837969 ,-1.01599336 ,-1.64582145 }	,
{0.535625100 ,-1.29311419 ,-1.39965606 }	,
{0.273059279 ,-1.37276268 ,-1.39965606 }	,
{0.420837969 ,-1.01599336 ,-1.64582145 }	,
{0.273059279 ,-1.37276268 ,-1.39965606 }	,
{0.214541316 ,-1.07857287 ,-1.64582145 }	,
{0.699828207 ,-1.68953490 ,0.757488370 }	,
{0.629828393 ,-1.52054131 ,1.09970260 }	,
{0.321083605 ,-1.61419773 ,1.09970260 }	,
{0.699828207 ,-1.68953490 ,0.757488370 }	,
{0.321083605 ,-1.61419773 ,1.09970260 }	,
{0.356769353 ,-1.79360068 ,0.757488370 }	,
{0.289878279 ,-0.699828684 ,-1.82873893 }	,
{0.420837969 ,-1.01599336 ,-1.64582145 }	,
{0.214541316 ,-1.07857287 ,-1.64582145 }	,
{0.289878279 ,-0.699828684 ,-1.82873893 }	,
{0.214541316 ,-1.07857287 ,-1.64582145 }	,
{0.147778675 ,-0.742934108 ,-1.82873893 }	,
{0.321083605 ,-1.61419773 ,-1.09970260 }	,
{0.356769353 ,-1.79360068 ,-0.757488072 }	,
{1.25828294e-07 ,-1.82873940 ,-0.757488072 }	,
{0.321083605 ,-1.61419773 ,-1.09970260 }	,
{1.25828294e-07 ,-1.82873940 ,-0.757488072 }	,
{-1.69127162e-07 ,-1.64582157 ,-1.09970260 }	,
{0.273059279 ,-1.37276268 ,1.39965606 }	,
{0.214541450 ,-1.07857311 ,1.64582133 }	,
{5.20894226e-08 ,-1.09970355 ,1.64582133 }	,
{0.273059279 ,-1.37276268 ,1.39965606 }	,
{5.20894226e-08 ,-1.09970355 ,1.64582133 }	,
{-5.11449869e-08 ,-1.39965665 ,1.39965606 }	,
{0.273059279 ,-1.37276268 ,-1.39965606 }	,
{0.321083605 ,-1.61419773 ,-1.09970260 }	,
{-1.69127162e-07 ,-1.64582157 ,-1.09970260 }	,
{0.273059279 ,-1.37276268 ,-1.39965606 }	,
{-1.69127162e-07 ,-1.64582157 ,-1.09970260 }	,
{-5.11449869e-08 ,-1.39965665 ,-1.39965606 }	,
{0.321083605 ,-1.61419773 ,1.09970260 }	,
{0.273059279 ,-1.37276268 ,1.39965606 }	,
{-5.11449869e-08 ,-1.39965665 ,1.39965606 }	,
{0.321083605 ,-1.61419773 ,1.09970260 }	,
{-5.11449869e-08 ,-1.39965665 ,1.39965606 }	,
{-1.69127162e-07 ,-1.64582157 ,1.09970260 }	,
{0.214541316 ,-1.07857287 ,-1.64582145 }	,
{0.273059279 ,-1.37276268 ,-1.39965606 }	,
{-5.11449869e-08 ,-1.39965665 ,-1.39965606 }	,
{0.214541316 ,-1.07857287 ,-1.64582145 }	,
{-5.11449869e-08 ,-1.39965665 ,-1.39965606 }	,
{-2.16494414e-08 ,-1.09970319 ,-1.64582145 }	,
{0.356769353 ,-1.79360068 ,0.757488370 }	,
{0.321083605 ,-1.61419773 ,1.09970260 }	,
{-1.69127162e-07 ,-1.64582157 ,1.09970260 }	,
{0.356769353 ,-1.79360068 ,0.757488370 }	,
{-1.69127162e-07 ,-1.64582157 ,1.09970260 }	,
{1.25828294e-07 ,-1.82873940 ,0.757488370 }	,
{0.147778675 ,-0.742934108 ,-1.82873893 }	,
{0.214541316 ,-1.07857287 ,-1.64582145 }	,
{-2.16494414e-08 ,-1.09970319 ,-1.64582145 }	,
{0.147778675 ,-0.742934108 ,-1.82873893 }	,
{-2.16494414e-08 ,-1.09970319 ,-1.64582145 }	,
{7.84610421e-09 ,-0.757488966 ,-1.82873893 }	,
{0.378743976 ,-1.90407598 ,0.386164308 }	,
{0.356769353 ,-1.79360068 ,0.757488370 }	,
{1.25828294e-07 ,-1.82873940 ,0.757488370 }	,
{0.378743976 ,-1.90407598 ,0.386164308 }	,
{1.25828294e-07 ,-1.82873940 ,0.757488370 }	,
{-1.69127162e-07 ,-1.94137883 ,0.386164308 }	,
{0.0753369182 ,-0.378744841 ,-1.94137871 }	,
{0.147778675 ,-0.742934108 ,-1.82873893 }	,
{7.84610421e-09 ,-0.757488966 ,-1.82873893 }	,
{0.0753369182 ,-0.378744841 ,-1.94137871 }	,
{7.84610421e-09 ,-0.757488966 ,-1.82873893 }	,
{7.84610421e-09 ,-0.386164844 ,-1.94137871 }	,
{0.386164099 ,-1.94137955 ,1.49441490e-07 }	,
{0.378743976 ,-1.90407598 ,0.386164308 }	,
{-1.69127162e-07 ,-1.94137883 ,0.386164308 }	,
{0.386164099 ,-1.94137955 ,1.49441490e-07 }	,
{-1.69127162e-07 ,-1.94137883 ,0.386164308 }	,
{-1.98622715e-07 ,-1.97941327 ,1.49441490e-07 }	,
{0.0753369778 ,-0.378745258 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-1.42755550e-08 ,-0.386165261 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{0.0753369182 ,-0.378744841 ,-1.94137871 }	,
{7.84610421e-09 ,-0.386164844 ,-1.94137871 }	,
{0.378743976 ,-1.90407598 ,-0.386164010 }	,
{0.386164099 ,-1.94137955 ,1.49441490e-07 }	,
{-1.98622715e-07 ,-1.97941327 ,1.49441490e-07 }	,
{0.378743976 ,-1.90407598 ,-0.386164010 }	,
{-1.98622715e-07 ,-1.97941327 ,1.49441490e-07 }	,
{-1.69127162e-07 ,-1.94137883 ,-0.386164010 }	,
{0.147778794 ,-0.742934346 ,1.82873869 }	,
{0.0753369778 ,-0.378745258 ,1.94137859 }	,
{-1.42755550e-08 ,-0.386165261 ,1.94137859 }	,
{0.147778794 ,-0.742934346 ,1.82873869 }	,
{-1.42755550e-08 ,-0.386165261 ,1.94137859 }	,
{8.15849717e-08 ,-0.757489204 ,1.82873869 }	,
{0.356769353 ,-1.79360068 ,-0.757488072 }	,
{0.378743976 ,-1.90407598 ,-0.386164010 }	,
{-1.69127162e-07 ,-1.94137883 ,-0.386164010 }	,
{0.356769353 ,-1.79360068 ,-0.757488072 }	,
{-1.69127162e-07 ,-1.94137883 ,-0.386164010 }	,
{1.25828294e-07 ,-1.82873940 ,-0.757488072 }	,
{0.214541450 ,-1.07857311 ,1.64582133 }	,
{0.147778794 ,-0.742934346 ,1.82873869 }	,
{8.15849717e-08 ,-0.757489204 ,1.82873869 }	,
{0.214541450 ,-1.07857311 ,1.64582133 }	,
{8.15849717e-08 ,-0.757489204 ,1.82873869 }	,
{5.20894226e-08 ,-1.09970355 ,1.64582133 }	,
{7.84610421e-09 ,-0.386164844 ,-1.94137871 }	,
{7.84610421e-09 ,-0.757488966 ,-1.82873893 }	,
{-0.147778630 ,-0.742933989 ,-1.82873893 }	,
{7.84610421e-09 ,-0.386164844 ,-1.94137871 }	,
{-0.147778630 ,-0.742933989 ,-1.82873893 }	,
{-0.0753368959 ,-0.378744811 ,-1.94137871 }	,
{-1.98622715e-07 ,-1.97941327 ,1.49441490e-07 }	,
{-1.69127162e-07 ,-1.94137883 ,0.386164308 }	,
{-0.378744274 ,-1.90407574 ,0.386164308 }	,
{-1.98622715e-07 ,-1.97941327 ,1.49441490e-07 }	,
{-0.378744274 ,-1.90407574 ,0.386164308 }	,
{-0.386164486 ,-1.94137931 ,1.49441490e-07 }	,
{-1.42755550e-08 ,-0.386165261 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.0753370002 ,-0.378745198 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{7.84610421e-09 ,-0.386164844 ,-1.94137871 }	,
{-0.0753368959 ,-0.378744811 ,-1.94137871 }	,
{-1.69127162e-07 ,-1.94137883 ,-0.386164010 }	,
{-1.98622715e-07 ,-1.97941327 ,1.49441490e-07 }	,
{-0.386164486 ,-1.94137931 ,1.49441490e-07 }	,
{-1.69127162e-07 ,-1.94137883 ,-0.386164010 }	,
{-0.386164486 ,-1.94137931 ,1.49441490e-07 }	,
{-0.378744274 ,-1.90407574 ,-0.386164010 }	,
{8.15849717e-08 ,-0.757489204 ,1.82873869 }	,
{-1.42755550e-08 ,-0.386165261 ,1.94137859 }	,
{-0.0753370002 ,-0.378745198 ,1.94137859 }	,
{8.15849717e-08 ,-0.757489204 ,1.82873869 }	,
{-0.0753370002 ,-0.378745198 ,1.94137859 }	,
{-0.147778615 ,-0.742934227 ,1.82873869 }	,
{1.25828294e-07 ,-1.82873940 ,-0.757488072 }	,
{-1.69127162e-07 ,-1.94137883 ,-0.386164010 }	,
{-0.378744274 ,-1.90407574 ,-0.386164010 }	,
{1.25828294e-07 ,-1.82873940 ,-0.757488072 }	,
{-0.378744274 ,-1.90407574 ,-0.386164010 }	,
{-0.356769115 ,-1.79360068 ,-0.757488072 }	,
{5.20894226e-08 ,-1.09970355 ,1.64582133 }	,
{8.15849717e-08 ,-0.757489204 ,1.82873869 }	,
{-0.147778615 ,-0.742934227 ,1.82873869 }	,
{5.20894226e-08 ,-1.09970355 ,1.64582133 }	,
{-0.147778615 ,-0.742934227 ,1.82873869 }	,
{-0.214541331 ,-1.07857311 ,1.64582133 }	,
{-1.69127162e-07 ,-1.64582157 ,-1.09970260 }	,
{1.25828294e-07 ,-1.82873940 ,-0.757488072 }	,
{-0.356769115 ,-1.79360068 ,-0.757488072 }	,
{-1.69127162e-07 ,-1.64582157 ,-1.09970260 }	,
{-0.356769115 ,-1.79360068 ,-0.757488072 }	,
{-0.321083933 ,-1.61419749 ,-1.09970260 }	,
{-5.11449869e-08 ,-1.39965665 ,1.39965606 }	,
{5.20894226e-08 ,-1.09970355 ,1.64582133 }	,
{-0.214541331 ,-1.07857311 ,1.64582133 }	,
{-5.11449869e-08 ,-1.39965665 ,1.39965606 }	,
{-0.214541331 ,-1.07857311 ,1.64582133 }	,
{-0.273059398 ,-1.37276256 ,1.39965606 }	,
{-5.11449869e-08 ,-1.39965665 ,-1.39965606 }	,
{-1.69127162e-07 ,-1.64582157 ,-1.09970260 }	,
{-0.321083933 ,-1.61419749 ,-1.09970260 }	,
{-5.11449869e-08 ,-1.39965665 ,-1.39965606 }	,
{-0.321083933 ,-1.61419749 ,-1.09970260 }	,
{-0.273059398 ,-1.37276256 ,-1.39965606 }	,
{-1.69127162e-07 ,-1.64582157 ,1.09970260 }	,
{-5.11449869e-08 ,-1.39965665 ,1.39965606 }	,
{-0.273059398 ,-1.37276256 ,1.39965606 }	,
{-1.69127162e-07 ,-1.64582157 ,1.09970260 }	,
{-0.273059398 ,-1.37276256 ,1.39965606 }	,
{-0.321083933 ,-1.61419749 ,1.09970260 }	,
{-2.16494414e-08 ,-1.09970319 ,-1.64582145 }	,
{-5.11449869e-08 ,-1.39965665 ,-1.39965606 }	,
{-0.273059398 ,-1.37276256 ,-1.39965606 }	,
{-2.16494414e-08 ,-1.09970319 ,-1.64582145 }	,
{-0.273059398 ,-1.37276256 ,-1.39965606 }	,
{-0.214541331 ,-1.07857275 ,-1.64582145 }	,
{1.25828294e-07 ,-1.82873940 ,0.757488370 }	,
{-1.69127162e-07 ,-1.64582157 ,1.09970260 }	,
{-0.321083933 ,-1.61419749 ,1.09970260 }	,
{1.25828294e-07 ,-1.82873940 ,0.757488370 }	,
{-0.321083933 ,-1.61419749 ,1.09970260 }	,
{-0.356769115 ,-1.79360068 ,0.757488370 }	,
{7.84610421e-09 ,-0.757488966 ,-1.82873893 }	,
{-2.16494414e-08 ,-1.09970319 ,-1.64582145 }	,
{-0.214541331 ,-1.07857275 ,-1.64582145 }	,
{7.84610421e-09 ,-0.757488966 ,-1.82873893 }	,
{-0.214541331 ,-1.07857275 ,-1.64582145 }	,
{-0.147778630 ,-0.742933989 ,-1.82873893 }	,
{-1.69127162e-07 ,-1.94137883 ,0.386164308 }	,
{1.25828294e-07 ,-1.82873940 ,0.757488370 }	,
{-0.356769115 ,-1.79360068 ,0.757488370 }	,
{-1.69127162e-07 ,-1.94137883 ,0.386164308 }	,
{-0.356769115 ,-1.79360068 ,0.757488370 }	,
{-0.378744274 ,-1.90407574 ,0.386164308 }	,
{-0.273059398 ,-1.37276256 ,1.39965606 }	,
{-0.214541331 ,-1.07857311 ,1.64582133 }	,
{-0.420838028 ,-1.01599360 ,1.64582133 }	,
{-0.273059398 ,-1.37276256 ,1.39965606 }	,
{-0.420838028 ,-1.01599360 ,1.64582133 }	,
{-0.535625160 ,-1.29311407 ,1.39965606 }	,
{-0.273059398 ,-1.37276256 ,-1.39965606 }	,
{-0.321083933 ,-1.61419749 ,-1.09970260 }	,
{-0.629828572 ,-1.52054071 ,-1.09970260 }	,
{-0.273059398 ,-1.37276256 ,-1.39965606 }	,
{-0.629828572 ,-1.52054071 ,-1.09970260 }	,
{-0.535625160 ,-1.29311407 ,-1.39965606 }	,
{-0.321083933 ,-1.61419749 ,1.09970260 }	,
{-0.273059398 ,-1.37276256 ,1.39965606 }	,
{-0.535625160 ,-1.29311407 ,1.39965606 }	,
{-0.321083933 ,-1.61419749 ,1.09970260 }	,
{-0.535625160 ,-1.29311407 ,1.39965606 }	,
{-0.629828572 ,-1.52054071 ,1.09970260 }	,
{-0.214541331 ,-1.07857275 ,-1.64582145 }	,
{-0.273059398 ,-1.37276256 ,-1.39965606 }	,
{-0.535625160 ,-1.29311407 ,-1.39965606 }	,
{-0.214541331 ,-1.07857275 ,-1.64582145 }	,
{-0.535625160 ,-1.29311407 ,-1.39965606 }	,
{-0.420837969 ,-1.01599336 ,-1.64582145 }	,
{-0.356769115 ,-1.79360068 ,0.757488370 }	,
{-0.321083933 ,-1.61419749 ,1.09970260 }	,
{-0.629828572 ,-1.52054071 ,1.09970260 }	,
{-0.356769115 ,-1.79360068 ,0.757488370 }	,
{-0.629828572 ,-1.52054071 ,1.09970260 }	,
{-0.699827909 ,-1.68953490 ,0.757488370 }	,
{-0.147778630 ,-0.742933989 ,-1.82873893 }	,
{-0.214541331 ,-1.07857275 ,-1.64582145 }	,
{-0.420837969 ,-1.01599336 ,-1.64582145 }	,
{-0.147778630 ,-0.742933989 ,-1.82873893 }	,
{-0.420837969 ,-1.01599336 ,-1.64582145 }	,
{-0.289878219 ,-0.699828506 ,-1.82873893 }	,
{-0.378744274 ,-1.90407574 ,0.386164308 }	,
{-0.356769115 ,-1.79360068 ,0.757488370 }	,
{-0.699827909 ,-1.68953490 ,0.757488370 }	,
{-0.378744274 ,-1.90407574 ,0.386164308 }	,
{-0.699827909 ,-1.68953490 ,0.757488370 }	,
{-0.742933452 ,-1.79360008 ,0.386164308 }	,
{-0.0753368959 ,-0.378744811 ,-1.94137871 }	,
{-0.147778630 ,-0.742933989 ,-1.82873893 }	,
{-0.289878219 ,-0.699828506 ,-1.82873893 }	,
{-0.0753368959 ,-0.378744811 ,-1.94137871 }	,
{-0.289878219 ,-0.699828506 ,-1.82873893 }	,
{-0.147778630 ,-0.356769800 ,-1.94137871 }	,
{-0.386164486 ,-1.94137931 ,1.49441490e-07 }	,
{-0.378744274 ,-1.90407574 ,0.386164308 }	,
{-0.742933452 ,-1.79360008 ,0.386164308 }	,
{-0.386164486 ,-1.94137931 ,1.49441490e-07 }	,
{-0.742933452 ,-1.79360008 ,0.386164308 }	,
{-0.757488668 ,-1.82873929 ,1.49441490e-07 }	,
{-0.0753370002 ,-0.378745198 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.147778809 ,-0.356770188 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.0753368959 ,-0.378744811 ,-1.94137871 }	,
{-0.147778630 ,-0.356769800 ,-1.94137871 }	,
{-0.378744274 ,-1.90407574 ,-0.386164010 }	,
{-0.386164486 ,-1.94137931 ,1.49441490e-07 }	,
{-0.757488668 ,-1.82873929 ,1.49441490e-07 }	,
{-0.378744274 ,-1.90407574 ,-0.386164010 }	,
{-0.757488668 ,-1.82873929 ,1.49441490e-07 }	,
{-0.742933452 ,-1.79360008 ,-0.386164010 }	,
{-0.147778615 ,-0.742934227 ,1.82873869 }	,
{-0.0753370002 ,-0.378745198 ,1.94137859 }	,
{-0.147778809 ,-0.356770188 ,1.94137859 }	,
{-0.147778615 ,-0.742934227 ,1.82873869 }	,
{-0.147778809 ,-0.356770188 ,1.94137859 }	,
{-0.289878249 ,-0.699828744 ,1.82873869 }	,
{-0.356769115 ,-1.79360068 ,-0.757488072 }	,
{-0.378744274 ,-1.90407574 ,-0.386164010 }	,
{-0.742933452 ,-1.79360008 ,-0.386164010 }	,
{-0.356769115 ,-1.79360068 ,-0.757488072 }	,
{-0.742933452 ,-1.79360008 ,-0.386164010 }	,
{-0.699827909 ,-1.68953490 ,-0.757488072 }	,
{-0.214541331 ,-1.07857311 ,1.64582133 }	,
{-0.147778615 ,-0.742934227 ,1.82873869 }	,
{-0.289878249 ,-0.699828744 ,1.82873869 }	,
{-0.214541331 ,-1.07857311 ,1.64582133 }	,
{-0.289878249 ,-0.699828744 ,1.82873869 }	,
{-0.420838028 ,-1.01599360 ,1.64582133 }	,
{-0.321083933 ,-1.61419749 ,-1.09970260 }	,
{-0.356769115 ,-1.79360068 ,-0.757488072 }	,
{-0.699827909 ,-1.68953490 ,-0.757488072 }	,
{-0.321083933 ,-1.61419749 ,-1.09970260 }	,
{-0.699827909 ,-1.68953490 ,-0.757488072 }	,
{-0.629828572 ,-1.52054071 ,-1.09970260 }	,
{-0.757488668 ,-1.82873929 ,1.49441490e-07 }	,
{-0.742933452 ,-1.79360008 ,0.386164308 }	,
{-1.07857215 ,-1.61419737 ,0.386164308 }	,
{-0.757488668 ,-1.82873929 ,1.49441490e-07 }	,
{-1.07857215 ,-1.61419737 ,0.386164308 }	,
{-1.09970295 ,-1.64582181 ,1.49441490e-07 }	,
{-0.147778809 ,-0.356770188 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.214541540 ,-0.321084738 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.147778630 ,-0.356769800 ,-1.94137871 }	,
{-0.214541286 ,-0.321084380 ,-1.94137871 }	,
{-0.742933452 ,-1.79360008 ,-0.386164010 }	,
{-0.757488668 ,-1.82873929 ,1.49441490e-07 }	,
{-1.09970295 ,-1.64582181 ,1.49441490e-07 }	,
{-0.742933452 ,-1.79360008 ,-0.386164010 }	,
{-1.09970295 ,-1.64582181 ,1.49441490e-07 }	,
{-1.07857215 ,-1.61419737 ,-0.386164010 }	,
{-0.289878249 ,-0.699828744 ,1.82873869 }	,
{-0.147778809 ,-0.356770188 ,1.94137859 }	,
{-0.214541540 ,-0.321084738 ,1.94137859 }	,
{-0.289878249 ,-0.699828744 ,1.82873869 }	,
{-0.214541540 ,-0.321084738 ,1.94137859 }	,
{-0.420837998 ,-0.629829228 ,1.82873869 }	,
{-0.699827909 ,-1.68953490 ,-0.757488072 }	,
{-0.742933452 ,-1.79360008 ,-0.386164010 }	,
{-1.07857215 ,-1.61419737 ,-0.386164010 }	,
{-0.699827909 ,-1.68953490 ,-0.757488072 }	,
{-1.07857215 ,-1.61419737 ,-0.386164010 }	,
{-1.01599276 ,-1.52054131 ,-0.757488072 }	,
{-0.420838028 ,-1.01599360 ,1.64582133 }	,
{-0.289878249 ,-0.699828744 ,1.82873869 }	,
{-0.420837998 ,-0.629829228 ,1.82873869 }	,
{-0.420838028 ,-1.01599360 ,1.64582133 }	,
{-0.420837998 ,-0.629829228 ,1.82873869 }	,
{-0.610962093 ,-0.914370179 ,1.64582133 }	,
{-0.629828572 ,-1.52054071 ,-1.09970260 }	,
{-0.699827909 ,-1.68953490 ,-0.757488072 }	,
{-1.01599276 ,-1.52054131 ,-0.757488072 }	,
{-0.629828572 ,-1.52054071 ,-1.09970260 }	,
{-1.01599276 ,-1.52054131 ,-0.757488072 }	,
{-0.914369226 ,-1.36845040 ,-1.09970260 }	,
{-0.535625160 ,-1.29311407 ,1.39965606 }	,
{-0.420838028 ,-1.01599360 ,1.64582133 }	,
{-0.610962093 ,-0.914370179 ,1.64582133 }	,
{-0.535625160 ,-1.29311407 ,1.39965606 }	,
{-0.610962093 ,-0.914370179 ,1.64582133 }	,
{-0.777607203 ,-1.16377199 ,1.39965606 }	,
{-0.535625160 ,-1.29311407 ,-1.39965606 }	,
{-0.629828572 ,-1.52054071 ,-1.09970260 }	,
{-0.914369226 ,-1.36845040 ,-1.09970260 }	,
{-0.535625160 ,-1.29311407 ,-1.39965606 }	,
{-0.914369226 ,-1.36845040 ,-1.09970260 }	,
{-0.777607203 ,-1.16377199 ,-1.39965606 }	,
{-0.629828572 ,-1.52054071 ,1.09970260 }	,
{-0.535625160 ,-1.29311407 ,1.39965606 }	,
{-0.777607203 ,-1.16377199 ,1.39965606 }	,
{-0.629828572 ,-1.52054071 ,1.09970260 }	,
{-0.777607203 ,-1.16377199 ,1.39965606 }	,
{-0.914369226 ,-1.36845040 ,1.09970260 }	,
{-0.420837969 ,-1.01599336 ,-1.64582145 }	,
{-0.535625160 ,-1.29311407 ,-1.39965606 }	,
{-0.777607203 ,-1.16377199 ,-1.39965606 }	,
{-0.420837969 ,-1.01599336 ,-1.64582145 }	,
{-0.777607203 ,-1.16377199 ,-1.39965606 }	,
{-0.610961974 ,-0.914369822 ,-1.64582145 }	,
{-0.699827909 ,-1.68953490 ,0.757488370 }	,
{-0.629828572 ,-1.52054071 ,1.09970260 }	,
{-0.914369226 ,-1.36845040 ,1.09970260 }	,
{-0.699827909 ,-1.68953490 ,0.757488370 }	,
{-0.914369226 ,-1.36845040 ,1.09970260 }	,
{-1.01599276 ,-1.52054131 ,0.757488370 }	,
{-0.289878219 ,-0.699828506 ,-1.82873893 }	,
{-0.420837969 ,-1.01599336 ,-1.64582145 }	,
{-0.610961974 ,-0.914369822 ,-1.64582145 }	,
{-0.289878219 ,-0.699828506 ,-1.82873893 }	,
{-0.610961974 ,-0.914369822 ,-1.64582145 }	,
{-0.420837909 ,-0.629828990 ,-1.82873893 }	,
{-0.742933452 ,-1.79360008 ,0.386164308 }	,
{-0.699827909 ,-1.68953490 ,0.757488370 }	,
{-1.01599276 ,-1.52054131 ,0.757488370 }	,
{-0.742933452 ,-1.79360008 ,0.386164308 }	,
{-1.01599276 ,-1.52054131 ,0.757488370 }	,
{-1.07857215 ,-1.61419737 ,0.386164308 }	,
{-0.147778630 ,-0.356769800 ,-1.94137871 }	,
{-0.289878219 ,-0.699828506 ,-1.82873893 }	,
{-0.420837909 ,-0.629828990 ,-1.82873893 }	,
{-0.147778630 ,-0.356769800 ,-1.94137871 }	,
{-0.420837909 ,-0.629828990 ,-1.82873893 }	,
{-0.214541286 ,-0.321084380 ,-1.94137871 }	,
{-0.777607203 ,-1.16377199 ,-1.39965606 }	,
{-0.914369226 ,-1.36845040 ,-1.09970260 }	,
{-1.16377115 ,-1.16377139 ,-1.09970260 }	,
{-0.777607203 ,-1.16377199 ,-1.39965606 }	,
{-1.16377115 ,-1.16377139 ,-1.09970260 }	,
{-0.989706278 ,-0.989706755 ,-1.39965606 }	,
{-0.914369226 ,-1.36845040 ,1.09970260 }	,
{-0.777607203 ,-1.16377199 ,1.39965606 }	,
{-0.989706278 ,-0.989706755 ,1.39965606 }	,
{-0.914369226 ,-1.36845040 ,1.09970260 }	,
{-0.989706278 ,-0.989706755 ,1.39965606 }	,
{-1.16377115 ,-1.16377139 ,1.09970260 }	,
{-0.610961974 ,-0.914369822 ,-1.64582145 }	,
{-0.777607203 ,-1.16377199 ,-1.39965606 }	,
{-0.989706278 ,-0.989706755 ,-1.39965606 }	,
{-0.610961974 ,-0.914369822 ,-1.64582145 }	,
{-0.989706278 ,-0.989706755 ,-1.39965606 }	,
{-0.777607143 ,-0.777607620 ,-1.64582145 }	,
{-1.01599276 ,-1.52054131 ,0.757488370 }	,
{-0.914369226 ,-1.36845040 ,1.09970260 }	,
{-1.16377115 ,-1.16377139 ,1.09970260 }	,
{-1.01599276 ,-1.52054131 ,0.757488370 }	,
{-1.16377115 ,-1.16377139 ,1.09970260 }	,
{-1.29311335 ,-1.29311407 ,0.757488370 }	,
{-0.420837909 ,-0.629828990 ,-1.82873893 }	,
{-0.610961974 ,-0.914369822 ,-1.64582145 }	,
{-0.777607143 ,-0.777607620 ,-1.64582145 }	,
{-0.420837909 ,-0.629828990 ,-1.82873893 }	,
{-0.777607143 ,-0.777607620 ,-1.64582145 }	,
{-0.535625041 ,-0.535625577 ,-1.82873893 }	,
{-1.07857215 ,-1.61419737 ,0.386164308 }	,
{-1.01599276 ,-1.52054131 ,0.757488370 }	,
{-1.29311335 ,-1.29311407 ,0.757488370 }	,
{-1.07857215 ,-1.61419737 ,0.386164308 }	,
{-1.29311335 ,-1.29311407 ,0.757488370 }	,
{-1.37276173 ,-1.37276196 ,0.386164308 }	,
{-0.214541286 ,-0.321084380 ,-1.94137871 }	,
{-0.420837909 ,-0.629828990 ,-1.82873893 }	,
{-0.535625041 ,-0.535625577 ,-1.82873893 }	,
{-0.214541286 ,-0.321084380 ,-1.94137871 }	,
{-0.535625041 ,-0.535625577 ,-1.82873893 }	,
{-0.273059249 ,-0.273059905 ,-1.94137871 }	,
{-1.09970295 ,-1.64582181 ,1.49441490e-07 }	,
{-1.07857215 ,-1.61419737 ,0.386164308 }	,
{-1.37276173 ,-1.37276196 ,0.386164308 }	,
{-1.09970295 ,-1.64582181 ,1.49441490e-07 }	,
{-1.37276173 ,-1.37276196 ,0.386164308 }	,
{-1.39965630 ,-1.39965641 ,1.49441490e-07 }	,
{-0.214541540 ,-0.321084738 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.273059577 ,-0.273060203 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.214541286 ,-0.321084380 ,-1.94137871 }	,
{-0.273059249 ,-0.273059905 ,-1.94137871 }	,
{-1.07857215 ,-1.61419737 ,-0.386164010 }	,
{-1.09970295 ,-1.64582181 ,1.49441490e-07 }	,
{-1.39965630 ,-1.39965641 ,1.49441490e-07 }	,
{-1.07857215 ,-1.61419737 ,-0.386164010 }	,
{-1.39965630 ,-1.39965641 ,1.49441490e-07 }	,
{-1.37276173 ,-1.37276196 ,-0.386164010 }	,
{-0.420837998 ,-0.629829228 ,1.82873869 }	,
{-0.214541540 ,-0.321084738 ,1.94137859 }	,
{-0.273059577 ,-0.273060203 ,1.94137859 }	,
{-0.420837998 ,-0.629829228 ,1.82873869 }	,
{-0.273059577 ,-0.273060203 ,1.94137859 }	,
{-0.535625160 ,-0.535625756 ,1.82873869 }	,
{-1.01599276 ,-1.52054131 ,-0.757488072 }	,
{-1.07857215 ,-1.61419737 ,-0.386164010 }	,
{-1.37276173 ,-1.37276196 ,-0.386164010 }	,
{-1.01599276 ,-1.52054131 ,-0.757488072 }	,
{-1.37276173 ,-1.37276196 ,-0.386164010 }	,
{-1.29311335 ,-1.29311407 ,-0.757488072 }	,
{-0.610962093 ,-0.914370179 ,1.64582133 }	,
{-0.420837998 ,-0.629829228 ,1.82873869 }	,
{-0.535625160 ,-0.535625756 ,1.82873869 }	,
{-0.610962093 ,-0.914370179 ,1.64582133 }	,
{-0.535625160 ,-0.535625756 ,1.82873869 }	,
{-0.777607262 ,-0.777607977 ,1.64582133 }	,
{-0.914369226 ,-1.36845040 ,-1.09970260 }	,
{-1.01599276 ,-1.52054131 ,-0.757488072 }	,
{-1.29311335 ,-1.29311407 ,-0.757488072 }	,
{-0.914369226 ,-1.36845040 ,-1.09970260 }	,
{-1.29311335 ,-1.29311407 ,-0.757488072 }	,
{-1.16377115 ,-1.16377139 ,-1.09970260 }	,
{-0.777607203 ,-1.16377199 ,1.39965606 }	,
{-0.610962093 ,-0.914370179 ,1.64582133 }	,
{-0.777607262 ,-0.777607977 ,1.64582133 }	,
{-0.777607203 ,-1.16377199 ,1.39965606 }	,
{-0.777607262 ,-0.777607977 ,1.64582133 }	,
{-0.989706278 ,-0.989706755 ,1.39965606 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.273059249 ,-0.273059905 ,-1.94137871 }	,
{-0.321083724 ,-0.214541912 ,-1.94137871 }	,
{-1.37276173 ,-1.37276196 ,-0.386164010 }	,
{-1.39965630 ,-1.39965641 ,1.49441490e-07 }	,
{-1.64582145 ,-1.09970295 ,1.49441490e-07 }	,
{-1.37276173 ,-1.37276196 ,-0.386164010 }	,
{-1.64582145 ,-1.09970295 ,1.49441490e-07 }	,
{-1.61419690 ,-1.07857215 ,-0.386164010 }	,
{-0.535625160 ,-0.535625756 ,1.82873869 }	,
{-0.273059577 ,-0.273060203 ,1.94137859 }	,
{-0.321084082 ,-0.214542150 ,1.94137859 }	,
{-0.535625160 ,-0.535625756 ,1.82873869 }	,
{-0.321084082 ,-0.214542150 ,1.94137859 }	,
{-0.629828572 ,-0.420838565 ,1.82873869 }	,
{-1.29311335 ,-1.29311407 ,-0.757488072 }	,
{-1.37276173 ,-1.37276196 ,-0.386164010 }	,
{-1.61419690 ,-1.07857215 ,-0.386164010 }	,
{-1.29311335 ,-1.29311407 ,-0.757488072 }	,
{-1.61419690 ,-1.07857215 ,-0.386164010 }	,
{-1.52054060 ,-1.01599336 ,-0.757488072 }	,
{-0.777607262 ,-0.777607977 ,1.64582133 }	,
{-0.535625160 ,-0.535625756 ,1.82873869 }	,
{-0.629828572 ,-0.420838565 ,1.82873869 }	,
{-0.777607262 ,-0.777607977 ,1.64582133 }	,
{-0.629828572 ,-0.420838565 ,1.82873869 }	,
{-0.914369404 ,-0.610962749 ,1.64582133 }	,
{-1.16377115 ,-1.16377139 ,-1.09970260 }	,
{-1.29311335 ,-1.29311407 ,-0.757488072 }	,
{-1.52054060 ,-1.01599336 ,-0.757488072 }	,
{-1.16377115 ,-1.16377139 ,-1.09970260 }	,
{-1.52054060 ,-1.01599336 ,-0.757488072 }	,
{-1.36845005 ,-0.914369404 ,-1.09970260 }	,
{-0.989706278 ,-0.989706755 ,1.39965606 }	,
{-0.777607262 ,-0.777607977 ,1.64582133 }	,
{-0.914369404 ,-0.610962749 ,1.64582133 }	,
{-0.989706278 ,-0.989706755 ,1.39965606 }	,
{-0.914369404 ,-0.610962749 ,1.64582133 }	,
{-1.16377139 ,-0.777607679 ,1.39965606 }	,
{-0.989706278 ,-0.989706755 ,-1.39965606 }	,
{-1.16377115 ,-1.16377139 ,-1.09970260 }	,
{-1.36845005 ,-0.914369404 ,-1.09970260 }	,
{-0.989706278 ,-0.989706755 ,-1.39965606 }	,
{-1.36845005 ,-0.914369404 ,-1.09970260 }	,
{-1.16377139 ,-0.777607679 ,-1.39965606 }	,
{-1.16377115 ,-1.16377139 ,1.09970260 }	,
{-0.989706278 ,-0.989706755 ,1.39965606 }	,
{-1.16377139 ,-0.777607679 ,1.39965606 }	,
{-1.16377115 ,-1.16377139 ,1.09970260 }	,
{-1.16377139 ,-0.777607679 ,1.39965606 }	,
{-1.36845005 ,-0.914369404 ,1.09970260 }	,
{-0.777607143 ,-0.777607620 ,-1.64582145 }	,
{-0.989706278 ,-0.989706755 ,-1.39965606 }	,
{-1.16377139 ,-0.777607679 ,-1.39965606 }	,
{-0.777607143 ,-0.777607620 ,-1.64582145 }	,
{-1.16377139 ,-0.777607679 ,-1.39965606 }	,
{-0.914369226 ,-0.610962451 ,-1.64582145 }	,
{-1.29311335 ,-1.29311407 ,0.757488370 }	,
{-1.16377115 ,-1.16377139 ,1.09970260 }	,
{-1.36845005 ,-0.914369404 ,1.09970260 }	,
{-1.29311335 ,-1.29311407 ,0.757488370 }	,
{-1.36845005 ,-0.914369404 ,1.09970260 }	,
{-1.52054060 ,-1.01599336 ,0.757488370 }	,
{-0.535625041 ,-0.535625577 ,-1.82873893 }	,
{-0.777607143 ,-0.777607620 ,-1.64582145 }	,
{-0.914369226 ,-0.610962451 ,-1.64582145 }	,
{-0.535625041 ,-0.535625577 ,-1.82873893 }	,
{-0.914369226 ,-0.610962451 ,-1.64582145 }	,
{-0.629828393 ,-0.420838386 ,-1.82873893 }	,
{-1.37276173 ,-1.37276196 ,0.386164308 }	,
{-1.29311335 ,-1.29311407 ,0.757488370 }	,
{-1.52054060 ,-1.01599336 ,0.757488370 }	,
{-1.37276173 ,-1.37276196 ,0.386164308 }	,
{-1.52054060 ,-1.01599336 ,0.757488370 }	,
{-1.61419690 ,-1.07857215 ,0.386164308 }	,
{-0.273059249 ,-0.273059905 ,-1.94137871 }	,
{-0.535625041 ,-0.535625577 ,-1.82873893 }	,
{-0.629828393 ,-0.420838386 ,-1.82873893 }	,
{-0.273059249 ,-0.273059905 ,-1.94137871 }	,
{-0.629828393 ,-0.420838386 ,-1.82873893 }	,
{-0.321083724 ,-0.214541912 ,-1.94137871 }	,
{-1.39965630 ,-1.39965641 ,1.49441490e-07 }	,
{-1.37276173 ,-1.37276196 ,0.386164308 }	,
{-1.61419690 ,-1.07857215 ,0.386164308 }	,
{-1.39965630 ,-1.39965641 ,1.49441490e-07 }	,
{-1.61419690 ,-1.07857215 ,0.386164308 }	,
{-1.64582145 ,-1.09970295 ,1.49441490e-07 }	,
{-0.273059577 ,-0.273060203 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.321084082 ,-0.214542150 ,1.94137859 }	,
{-0.914369226 ,-0.610962451 ,-1.64582145 }	,
{-1.16377139 ,-0.777607679 ,-1.39965606 }	,
{-1.29311347 ,-0.535625577 ,-1.39965606 }	,
{-0.914369226 ,-0.610962451 ,-1.64582145 }	,
{-1.29311347 ,-0.535625577 ,-1.39965606 }	,
{-1.01599264 ,-0.420838445 ,-1.64582145 }	,
{-1.52054060 ,-1.01599336 ,0.757488370 }	,
{-1.36845005 ,-0.914369404 ,1.09970260 }	,
{-1.52054012 ,-0.629828632 ,1.09970260 }	,
{-1.52054060 ,-1.01599336 ,0.757488370 }	,
{-1.52054012 ,-0.629828632 ,1.09970260 }	,
{-1.68953419 ,-0.699828684 ,0.757488370 }	,
{-0.629828393 ,-0.420838386 ,-1.82873893 }	,
{-0.914369226 ,-0.610962451 ,-1.64582145 }	,
{-1.01599264 ,-0.420838445 ,-1.64582145 }	,
{-0.629828393 ,-0.420838386 ,-1.82873893 }	,
{-1.01599264 ,-0.420838445 ,-1.64582145 }	,
{-0.699827790 ,-0.289878666 ,-1.82873893 }	,
{-1.61419690 ,-1.07857215 ,0.386164308 }	,
{-1.52054060 ,-1.01599336 ,0.757488370 }	,
{-1.68953419 ,-0.699828684 ,0.757488370 }	,
{-1.61419690 ,-1.07857215 ,0.386164308 }	,
{-1.68953419 ,-0.699828684 ,0.757488370 }	,
{-1.79359949 ,-0.742933393 ,0.386164308 }	,
{-0.321083724 ,-0.214541912 ,-1.94137871 }	,
{-0.629828393 ,-0.420838386 ,-1.82873893 }	,
{-0.699827790 ,-0.289878666 ,-1.82873893 }	,
{-0.321083724 ,-0.214541912 ,-1.94137871 }	,
{-0.699827790 ,-0.289878666 ,-1.82873893 }	,
{-0.356769085 ,-0.147779211 ,-1.94137871 }	,
{-1.64582145 ,-1.09970295 ,1.49441490e-07 }	,
{-1.61419690 ,-1.07857215 ,0.386164308 }	,
{-1.79359949 ,-0.742933393 ,0.386164308 }	,
{-1.64582145 ,-1.09970295 ,1.49441490e-07 }	,
{-1.79359949 ,-0.742933393 ,0.386164308 }	,
{-1.82873869 ,-0.757488608 ,1.49441490e-07 }	,
{-0.321084082 ,-0.214542150 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.356769502 ,-0.147779390 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.321083724 ,-0.214541912 ,-1.94137871 }	,
{-0.356769085 ,-0.147779211 ,-1.94137871 }	,
{-1.61419690 ,-1.07857215 ,-0.386164010 }	,
{-1.64582145 ,-1.09970295 ,1.49441490e-07 }	,
{-1.82873869 ,-0.757488608 ,1.49441490e-07 }	,
{-1.61419690 ,-1.07857215 ,-0.386164010 }	,
{-1.82873869 ,-0.757488608 ,1.49441490e-07 }	,
{-1.79359949 ,-0.742933393 ,-0.386164010 }	,
{-0.629828572 ,-0.420838565 ,1.82873869 }	,
{-0.321084082 ,-0.214542150 ,1.94137859 }	,
{-0.356769502 ,-0.147779390 ,1.94137859 }	,
{-0.629828572 ,-0.420838565 ,1.82873869 }	,
{-0.356769502 ,-0.147779390 ,1.94137859 }	,
{-0.699827969 ,-0.289878786 ,1.82873869 }	,
{-1.52054060 ,-1.01599336 ,-0.757488072 }	,
{-1.61419690 ,-1.07857215 ,-0.386164010 }	,
{-1.79359949 ,-0.742933393 ,-0.386164010 }	,
{-1.52054060 ,-1.01599336 ,-0.757488072 }	,
{-1.79359949 ,-0.742933393 ,-0.386164010 }	,
{-1.68953419 ,-0.699828684 ,-0.757488072 }	,
{-0.914369404 ,-0.610962749 ,1.64582133 }	,
{-0.629828572 ,-0.420838565 ,1.82873869 }	,
{-0.699827969 ,-0.289878786 ,1.82873869 }	,
{-0.914369404 ,-0.610962749 ,1.64582133 }	,
{-0.699827969 ,-0.289878786 ,1.82873869 }	,
{-1.01599288 ,-0.420838624 ,1.64582133 }	,
{-1.36845005 ,-0.914369404 ,-1.09970260 }	,
{-1.52054060 ,-1.01599336 ,-0.757488072 }	,
{-1.68953419 ,-0.699828684 ,-0.757488072 }	,
{-1.36845005 ,-0.914369404 ,-1.09970260 }	,
{-1.68953419 ,-0.699828684 ,-0.757488072 }	,
{-1.52054012 ,-0.629828632 ,-1.09970260 }	,
{-1.16377139 ,-0.777607679 ,1.39965606 }	,
{-0.914369404 ,-0.610962749 ,1.64582133 }	,
{-1.01599288 ,-0.420838624 ,1.64582133 }	,
{-1.16377139 ,-0.777607679 ,1.39965606 }	,
{-1.01599288 ,-0.420838624 ,1.64582133 }	,
{-1.29311347 ,-0.535625577 ,1.39965606 }	,
{-1.16377139 ,-0.777607679 ,-1.39965606 }	,
{-1.36845005 ,-0.914369404 ,-1.09970260 }	,
{-1.52054012 ,-0.629828632 ,-1.09970260 }	,
{-1.16377139 ,-0.777607679 ,-1.39965606 }	,
{-1.52054012 ,-0.629828632 ,-1.09970260 }	,
{-1.29311347 ,-0.535625577 ,-1.39965606 }	,
{-1.36845005 ,-0.914369404 ,1.09970260 }	,
{-1.16377139 ,-0.777607679 ,1.39965606 }	,
{-1.29311347 ,-0.535625577 ,1.39965606 }	,
{-1.36845005 ,-0.914369404 ,1.09970260 }	,
{-1.29311347 ,-0.535625577 ,1.39965606 }	,
{-1.52054012 ,-0.629828632 ,1.09970260 }	,
{-0.699827969 ,-0.289878786 ,1.82873869 }	,
{-0.356769502 ,-0.147779390 ,1.94137859 }	,
{-0.378744483 ,-0.0753375813 ,1.94137859 }	,
{-0.699827969 ,-0.289878786 ,1.82873869 }	,
{-0.378744483 ,-0.0753375813 ,1.94137859 }	,
{-0.742933333 ,-0.147779182 ,1.82873869 }	,
{-1.68953419 ,-0.699828684 ,-0.757488072 }	,
{-1.79359949 ,-0.742933393 ,-0.386164010 }	,
{-1.90407491 ,-0.378744245 ,-0.386164010 }	,
{-1.68953419 ,-0.699828684 ,-0.757488072 }	,
{-1.90407491 ,-0.378744245 ,-0.386164010 }	,
{-1.79359996 ,-0.356769860 ,-0.757488072 }	,
{-1.01599288 ,-0.420838624 ,1.64582133 }	,
{-0.699827969 ,-0.289878786 ,1.82873869 }	,
{-0.742933333 ,-0.147779182 ,1.82873869 }	,
{-1.01599288 ,-0.420838624 ,1.64582133 }	,
{-0.742933333 ,-0.147779182 ,1.82873869 }	,
{-1.07857227 ,-0.214541927 ,1.64582133 }	,
{-1.52054012 ,-0.629828632 ,-1.09970260 }	,
{-1.68953419 ,-0.699828684 ,-0.757488072 }	,
{-1.79359996 ,-0.356769860 ,-0.757488072 }	,
{-1.52054012 ,-0.629828632 ,-1.09970260 }	,
{-1.79359996 ,-0.356769860 ,-0.757488072 }	,
{-1.61419666 ,-0.321083963 ,-1.09970260 }	,
{-1.29311347 ,-0.535625577 ,1.39965606 }	,
{-1.01599288 ,-0.420838624 ,1.64582133 }	,
{-1.07857227 ,-0.214541927 ,1.64582133 }	,
{-1.29311347 ,-0.535625577 ,1.39965606 }	,
{-1.07857227 ,-0.214541927 ,1.64582133 }	,
{-1.37276196 ,-0.273059726 ,1.39965606 }	,
{-1.29311347 ,-0.535625577 ,-1.39965606 }	,
{-1.52054012 ,-0.629828632 ,-1.09970260 }	,
{-1.61419666 ,-0.321083963 ,-1.09970260 }	,
{-1.29311347 ,-0.535625577 ,-1.39965606 }	,
{-1.61419666 ,-0.321083963 ,-1.09970260 }	,
{-1.37276196 ,-0.273059726 ,-1.39965606 }	,
{-1.52054012 ,-0.629828632 ,1.09970260 }	,
{-1.29311347 ,-0.535625577 ,1.39965606 }	,
{-1.37276196 ,-0.273059726 ,1.39965606 }	,
{-1.52054012 ,-0.629828632 ,1.09970260 }	,
{-1.37276196 ,-0.273059726 ,1.39965606 }	,
{-1.61419666 ,-0.321083963 ,1.09970260 }	,
{-1.01599264 ,-0.420838445 ,-1.64582145 }	,
{-1.29311347 ,-0.535625577 ,-1.39965606 }	,
{-1.37276196 ,-0.273059726 ,-1.39965606 }	,
{-1.01599264 ,-0.420838445 ,-1.64582145 }	,
{-1.37276196 ,-0.273059726 ,-1.39965606 }	,
{-1.07857203 ,-0.214541838 ,-1.64582145 }	,
{-1.68953419 ,-0.699828684 ,0.757488370 }	,
{-1.52054012 ,-0.629828632 ,1.09970260 }	,
{-1.61419666 ,-0.321083963 ,1.09970260 }	,
{-1.68953419 ,-0.699828684 ,0.757488370 }	,
{-1.61419666 ,-0.321083963 ,1.09970260 }	,
{-1.79359996 ,-0.356769860 ,0.757488370 }	,
{-0.699827790 ,-0.289878666 ,-1.82873893 }	,
{-1.01599264 ,-0.420838445 ,-1.64582145 }	,
{-1.07857203 ,-0.214541838 ,-1.64582145 }	,
{-0.699827790 ,-0.289878666 ,-1.82873893 }	,
{-1.07857203 ,-0.214541838 ,-1.64582145 }	,
{-0.742933154 ,-0.147779092 ,-1.82873893 }	,
{-1.79359949 ,-0.742933393 ,0.386164308 }	,
{-1.68953419 ,-0.699828684 ,0.757488370 }	,
{-1.79359996 ,-0.356769860 ,0.757488370 }	,
{-1.79359949 ,-0.742933393 ,0.386164308 }	,
{-1.79359996 ,-0.356769860 ,0.757488370 }	,
{-1.90407491 ,-0.378744245 ,0.386164308 }	,
{-0.356769085 ,-0.147779211 ,-1.94137871 }	,
{-0.699827790 ,-0.289878666 ,-1.82873893 }	,
{-0.742933154 ,-0.147779092 ,-1.82873893 }	,
{-0.356769085 ,-0.147779211 ,-1.94137871 }	,
{-0.742933154 ,-0.147779092 ,-1.82873893 }	,
{-0.378744036 ,-0.0753374994 ,-1.94137871 }	,
{-1.82873869 ,-0.757488608 ,1.49441490e-07 }	,
{-1.79359949 ,-0.742933393 ,0.386164308 }	,
{-1.90407491 ,-0.378744245 ,0.386164308 }	,
{-1.82873869 ,-0.757488608 ,1.49441490e-07 }	,
{-1.90407491 ,-0.378744245 ,0.386164308 }	,
{-1.94137847 ,-0.386164486 ,1.49441490e-07 }	,
{-0.356769502 ,-0.147779390 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.378744483 ,-0.0753375813 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.356769085 ,-0.147779211 ,-1.94137871 }	,
{-0.378744036 ,-0.0753374994 ,-1.94137871 }	,
{-1.79359949 ,-0.742933393 ,-0.386164010 }	,
{-1.82873869 ,-0.757488608 ,1.49441490e-07 }	,
{-1.94137847 ,-0.386164486 ,1.49441490e-07 }	,
{-1.79359949 ,-0.742933393 ,-0.386164010 }	,
{-1.94137847 ,-0.386164486 ,1.49441490e-07 }	,
{-1.90407491 ,-0.378744245 ,-0.386164010 }	,
{-1.79359996 ,-0.356769860 ,0.757488370 }	,
{-1.61419666 ,-0.321083963 ,1.09970260 }	,
{-1.64582062 ,-2.77852934e-07 ,1.09970260 }	,
{-1.79359996 ,-0.356769860 ,0.757488370 }	,
{-1.64582062 ,-2.77852934e-07 ,1.09970260 }	,
{-1.82873857 ,-6.31799480e-07 ,0.757488370 }	,
{-0.742933154 ,-0.147779092 ,-1.82873893 }	,
{-1.07857203 ,-0.214541838 ,-1.64582145 }	,
{-1.09970236 ,-5.13817326e-07 ,-1.64582145 }	,
{-0.742933154 ,-0.147779092 ,-1.82873893 }	,
{-1.09970236 ,-5.13817326e-07 ,-1.64582145 }	,
{-0.757488012 ,-4.99069529e-07 ,-1.82873893 }	,
{-1.90407491 ,-0.378744245 ,0.386164308 }	,
{-1.79359996 ,-0.356769860 ,0.757488370 }	,
{-1.82873857 ,-6.31799480e-07 ,0.757488370 }	,
{-1.90407491 ,-0.378744245 ,0.386164308 }	,
{-1.82873857 ,-6.31799480e-07 ,0.757488370 }	,
{-1.94137776 ,-1.89366304e-07 ,0.386164308 }	,
{-0.378744036 ,-0.0753374994 ,-1.94137871 }	,
{-0.742933154 ,-0.147779092 ,-1.82873893 }	,
{-0.757488012 ,-4.99069529e-07 ,-1.82873893 }	,
{-0.378744036 ,-0.0753374994 ,-1.94137871 }	,
{-0.757488012 ,-4.99069529e-07 ,-1.82873893 }	,
{-0.386164099 ,-6.24425581e-07 ,-1.94137871 }	,
{-1.94137847 ,-0.386164486 ,1.49441490e-07 }	,
{-1.90407491 ,-0.378744245 ,0.386164308 }	,
{-1.94137776 ,-1.89366304e-07 ,0.386164308 }	,
{-1.94137847 ,-0.386164486 ,1.49441490e-07 }	,
{-1.94137776 ,-1.89366304e-07 ,0.386164308 }	,
{-1.97941220 ,-2.77852934e-07 ,1.49441490e-07 }	,
{-0.378744483 ,-0.0753375813 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.386164516 ,-6.17051683e-07 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.378744036 ,-0.0753374994 ,-1.94137871 }	,
{-0.386164099 ,-6.24425581e-07 ,-1.94137871 }	,
{-1.90407491 ,-0.378744245 ,-0.386164010 }	,
{-1.94137847 ,-0.386164486 ,1.49441490e-07 }	,
{-1.97941220 ,-2.77852934e-07 ,1.49441490e-07 }	,
{-1.90407491 ,-0.378744245 ,-0.386164010 }	,
{-1.97941220 ,-2.77852934e-07 ,1.49441490e-07 }	,
{-1.94137776 ,-1.89366304e-07 ,-0.386164010 }	,
{-0.742933333 ,-0.147779182 ,1.82873869 }	,
{-0.378744483 ,-0.0753375813 ,1.94137859 }	,
{-0.386164516 ,-6.17051683e-07 ,1.94137859 }	,
{-0.742933333 ,-0.147779182 ,1.82873869 }	,
{-0.386164516 ,-6.17051683e-07 ,1.94137859 }	,
{-0.757488251 ,-5.58060606e-07 ,1.82873869 }	,
{-1.79359996 ,-0.356769860 ,-0.757488072 }	,
{-1.90407491 ,-0.378744245 ,-0.386164010 }	,
{-1.94137776 ,-1.89366304e-07 ,-0.386164010 }	,
{-1.79359996 ,-0.356769860 ,-0.757488072 }	,
{-1.94137776 ,-1.89366304e-07 ,-0.386164010 }	,
{-1.82873857 ,-6.31799480e-07 ,-0.757488072 }	,
{-1.07857227 ,-0.214541927 ,1.64582133 }	,
{-0.742933333 ,-0.147779182 ,1.82873869 }	,
{-0.757488251 ,-5.58060606e-07 ,1.82873869 }	,
{-1.07857227 ,-0.214541927 ,1.64582133 }	,
{-0.757488251 ,-5.58060606e-07 ,1.82873869 }	,
{-1.09970260 ,-5.58060606e-07 ,1.64582133 }	,
{-1.61419666 ,-0.321083963 ,-1.09970260 }	,
{-1.79359996 ,-0.356769860 ,-0.757488072 }	,
{-1.82873857 ,-6.31799480e-07 ,-0.757488072 }	,
{-1.61419666 ,-0.321083963 ,-1.09970260 }	,
{-1.82873857 ,-6.31799480e-07 ,-0.757488072 }	,
{-1.64582062 ,-2.77852934e-07 ,-1.09970260 }	,
{-1.37276196 ,-0.273059726 ,1.39965606 }	,
{-1.07857227 ,-0.214541927 ,1.64582133 }	,
{-1.09970260 ,-5.58060606e-07 ,1.64582133 }	,
{-1.37276196 ,-0.273059726 ,1.39965606 }	,
{-1.09970260 ,-5.58060606e-07 ,1.64582133 }	,
{-1.39965594 ,-3.66339577e-07 ,1.39965606 }	,
{-1.37276196 ,-0.273059726 ,-1.39965606 }	,
{-1.61419666 ,-0.321083963 ,-1.09970260 }	,
{-1.64582062 ,-2.77852934e-07 ,-1.09970260 }	,
{-1.37276196 ,-0.273059726 ,-1.39965606 }	,
{-1.64582062 ,-2.77852934e-07 ,-1.09970260 }	,
{-1.39965594 ,-3.66339577e-07 ,-1.39965606 }	,
{-1.61419666 ,-0.321083963 ,1.09970260 }	,
{-1.37276196 ,-0.273059726 ,1.39965606 }	,
{-1.39965594 ,-3.66339577e-07 ,1.39965606 }	,
{-1.61419666 ,-0.321083963 ,1.09970260 }	,
{-1.39965594 ,-3.66339577e-07 ,1.39965606 }	,
{-1.64582062 ,-2.77852934e-07 ,1.09970260 }	,
{-1.07857203 ,-0.214541838 ,-1.64582145 }	,
{-1.37276196 ,-0.273059726 ,-1.39965606 }	,
{-1.39965594 ,-3.66339577e-07 ,-1.39965606 }	,
{-1.07857203 ,-0.214541838 ,-1.64582145 }	,
{-1.39965594 ,-3.66339577e-07 ,-1.39965606 }	,
{-1.09970236 ,-5.13817326e-07 ,-1.64582145 }	,
{-1.82873857 ,-6.31799480e-07 ,-0.757488072 }	,
{-1.94137776 ,-1.89366304e-07 ,-0.386164010 }	,
{-1.90407455 ,0.378743827 ,-0.386164010 }	,
{-1.82873857 ,-6.31799480e-07 ,-0.757488072 }	,
{-1.90407455 ,0.378743827 ,-0.386164010 }	,
{-1.79359984 ,0.356768578 ,-0.757488072 }	,
{-1.09970260 ,-5.58060606e-07 ,1.64582133 }	,
{-0.757488251 ,-5.58060606e-07 ,1.82873869 }	,
{-0.742933333 ,0.147778064 ,1.82873869 }	,
{-1.09970260 ,-5.58060606e-07 ,1.64582133 }	,
{-0.742933333 ,0.147778064 ,1.82873869 }	,
{-1.07857215 ,0.214540780 ,1.64582133 }	,
{-1.64582062 ,-2.77852934e-07 ,-1.09970260 }	,
{-1.82873857 ,-6.31799480e-07 ,-0.757488072 }	,
{-1.79359984 ,0.356768578 ,-0.757488072 }	,
{-1.64582062 ,-2.77852934e-07 ,-1.09970260 }	,
{-1.79359984 ,0.356768578 ,-0.757488072 }	,
{-1.61419642 ,0.321083397 ,-1.09970260 }	,
{-1.39965594 ,-3.66339577e-07 ,1.39965606 }	,
{-1.09970260 ,-5.58060606e-07 ,1.64582133 }	,
{-1.07857215 ,0.214540780 ,1.64582133 }	,
{-1.39965594 ,-3.66339577e-07 ,1.39965606 }	,
{-1.07857215 ,0.214540780 ,1.64582133 }	,
{-1.37276185 ,0.273058951 ,1.39965606 }	,
{-1.39965594 ,-3.66339577e-07 ,-1.39965606 }	,
{-1.64582062 ,-2.77852934e-07 ,-1.09970260 }	,
{-1.61419642 ,0.321083397 ,-1.09970260 }	,
{-1.39965594 ,-3.66339577e-07 ,-1.39965606 }	,
{-1.61419642 ,0.321083397 ,-1.09970260 }	,
{-1.37276185 ,0.273058951 ,-1.39965606 }	,
{-1.64582062 ,-2.77852934e-07 ,1.09970260 }	,
{-1.39965594 ,-3.66339577e-07 ,1.39965606 }	,
{-1.37276185 ,0.273058951 ,1.39965606 }	,
{-1.64582062 ,-2.77852934e-07 ,1.09970260 }	,
{-1.37276185 ,0.273058951 ,1.39965606 }	,
{-1.61419642 ,0.321083397 ,1.09970260 }	,
{-1.09970236 ,-5.13817326e-07 ,-1.64582145 }	,
{-1.39965594 ,-3.66339577e-07 ,-1.39965606 }	,
{-1.37276185 ,0.273058951 ,-1.39965606 }	,
{-1.09970236 ,-5.13817326e-07 ,-1.64582145 }	,
{-1.37276185 ,0.273058951 ,-1.39965606 }	,
{-1.07857192 ,0.214540780 ,-1.64582145 }	,
{-1.82873857 ,-6.31799480e-07 ,0.757488370 }	,
{-1.64582062 ,-2.77852934e-07 ,1.09970260 }	,
{-1.61419642 ,0.321083397 ,1.09970260 }	,
{-1.82873857 ,-6.31799480e-07 ,0.757488370 }	,
{-1.61419642 ,0.321083397 ,1.09970260 }	,
{-1.79359984 ,0.356768578 ,0.757488370 }	,
{-0.757488012 ,-4.99069529e-07 ,-1.82873893 }	,
{-1.09970236 ,-5.13817326e-07 ,-1.64582145 }	,
{-1.07857192 ,0.214540780 ,-1.64582145 }	,
{-0.757488012 ,-4.99069529e-07 ,-1.82873893 }	,
{-1.07857192 ,0.214540780 ,-1.64582145 }	,
{-0.742933095 ,0.147778079 ,-1.82873893 }	,
{-1.94137776 ,-1.89366304e-07 ,0.386164308 }	,
{-1.82873857 ,-6.31799480e-07 ,0.757488370 }	,
{-1.79359984 ,0.356768578 ,0.757488370 }	,
{-1.94137776 ,-1.89366304e-07 ,0.386164308 }	,
{-1.79359984 ,0.356768578 ,0.757488370 }	,
{-1.90407455 ,0.378743827 ,0.386164308 }	,
{-0.386164099 ,-6.24425581e-07 ,-1.94137871 }	,
{-0.757488012 ,-4.99069529e-07 ,-1.82873893 }	,
{-0.742933095 ,0.147778079 ,-1.82873893 }	,
{-0.386164099 ,-6.24425581e-07 ,-1.94137871 }	,
{-0.742933095 ,0.147778079 ,-1.82873893 }	,
{-0.378744036 ,0.0753362477 ,-1.94137871 }	,
{-1.97941220 ,-2.77852934e-07 ,1.49441490e-07 }	,
{-1.94137776 ,-1.89366304e-07 ,0.386164308 }	,
{-1.90407455 ,0.378743827 ,0.386164308 }	,
{-1.97941220 ,-2.77852934e-07 ,1.49441490e-07 }	,
{-1.90407455 ,0.378743827 ,0.386164308 }	,
{-1.94137812 ,0.386163920 ,1.49441490e-07 }	,
{-0.386164516 ,-6.17051683e-07 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.378744453 ,0.0753363371 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.386164099 ,-6.24425581e-07 ,-1.94137871 }	,
{-0.378744036 ,0.0753362477 ,-1.94137871 }	,
{-1.94137776 ,-1.89366304e-07 ,-0.386164010 }	,
{-1.97941220 ,-2.77852934e-07 ,1.49441490e-07 }	,
{-1.94137812 ,0.386163920 ,1.49441490e-07 }	,
{-1.94137776 ,-1.89366304e-07 ,-0.386164010 }	,
{-1.94137812 ,0.386163920 ,1.49441490e-07 }	,
{-1.90407455 ,0.378743827 ,-0.386164010 }	,
{-0.757488251 ,-5.58060606e-07 ,1.82873869 }	,
{-0.386164516 ,-6.17051683e-07 ,1.94137859 }	,
{-0.378744453 ,0.0753363371 ,1.94137859 }	,
{-0.757488251 ,-5.58060606e-07 ,1.82873869 }	,
{-0.378744453 ,0.0753363371 ,1.94137859 }	,
{-0.742933333 ,0.147778064 ,1.82873869 }	,
{-0.742933095 ,0.147778079 ,-1.82873893 }	,
{-1.07857192 ,0.214540780 ,-1.64582145 }	,
{-1.01599240 ,0.420837373 ,-1.64582145 }	,
{-0.742933095 ,0.147778079 ,-1.82873893 }	,
{-1.01599240 ,0.420837373 ,-1.64582145 }	,
{-0.699827671 ,0.289877623 ,-1.82873893 }	,
{-1.90407455 ,0.378743827 ,0.386164308 }	,
{-1.79359984 ,0.356768578 ,0.757488370 }	,
{-1.68953407 ,0.699827373 ,0.757488370 }	,
{-1.90407455 ,0.378743827 ,0.386164308 }	,
{-1.68953407 ,0.699827373 ,0.757488370 }	,
{-1.79359889 ,0.742932856 ,0.386164308 }	,
{-0.378744036 ,0.0753362477 ,-1.94137871 }	,
{-0.742933095 ,0.147778079 ,-1.82873893 }	,
{-0.699827671 ,0.289877623 ,-1.82873893 }	,
{-0.378744036 ,0.0753362477 ,-1.94137871 }	,
{-0.699827671 ,0.289877623 ,-1.82873893 }	,
{-0.356769085 ,0.147777960 ,-1.94137871 }	,
{-1.94137812 ,0.386163920 ,1.49441490e-07 }	,
{-1.90407455 ,0.378743827 ,0.386164308 }	,
{-1.79359889 ,0.742932856 ,0.386164308 }	,
{-1.94137812 ,0.386163920 ,1.49441490e-07 }	,
{-1.79359889 ,0.742932856 ,0.386164308 }	,
{-1.82873809 ,0.757487953 ,1.49441490e-07 }	,
{-0.378744453 ,0.0753363371 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.356769472 ,0.147778124 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.378744036 ,0.0753362477 ,-1.94137871 }	,
{-0.356769085 ,0.147777960 ,-1.94137871 }	,
{-1.90407455 ,0.378743827 ,-0.386164010 }	,
{-1.94137812 ,0.386163920 ,1.49441490e-07 }	,
{-1.82873809 ,0.757487953 ,1.49441490e-07 }	,
{-1.90407455 ,0.378743827 ,-0.386164010 }	,
{-1.82873809 ,0.757487953 ,1.49441490e-07 }	,
{-1.79359889 ,0.742932856 ,-0.386164010 }	,
{-0.742933333 ,0.147778064 ,1.82873869 }	,
{-0.378744453 ,0.0753363371 ,1.94137859 }	,
{-0.356769472 ,0.147778124 ,1.94137859 }	,
{-0.742933333 ,0.147778064 ,1.82873869 }	,
{-0.356769472 ,0.147778124 ,1.94137859 }	,
{-0.699827909 ,0.289877653 ,1.82873869 }	,
{-1.79359984 ,0.356768578 ,-0.757488072 }	,
{-1.90407455 ,0.378743827 ,-0.386164010 }	,
{-1.79359889 ,0.742932856 ,-0.386164010 }	,
{-1.79359984 ,0.356768578 ,-0.757488072 }	,
{-1.79359889 ,0.742932856 ,-0.386164010 }	,
{-1.68953407 ,0.699827373 ,-0.757488072 }	,
{-1.07857215 ,0.214540780 ,1.64582133 }	,
{-0.742933333 ,0.147778064 ,1.82873869 }	,
{-0.699827909 ,0.289877653 ,1.82873869 }	,
{-1.07857215 ,0.214540780 ,1.64582133 }	,
{-0.699827909 ,0.289877653 ,1.82873869 }	,
{-1.01599264 ,0.420837432 ,1.64582133 }	,
{-1.61419642 ,0.321083397 ,-1.09970260 }	,
{-1.79359984 ,0.356768578 ,-0.757488072 }	,
{-1.68953407 ,0.699827373 ,-0.757488072 }	,
{-1.61419642 ,0.321083397 ,-1.09970260 }	,
{-1.68953407 ,0.699827373 ,-0.757488072 }	,
{-1.52053976 ,0.629827976 ,-1.09970260 }	,
{-1.37276185 ,0.273058951 ,1.39965606 }	,
{-1.07857215 ,0.214540780 ,1.64582133 }	,
{-1.01599264 ,0.420837432 ,1.64582133 }	,
{-1.37276185 ,0.273058951 ,1.39965606 }	,
{-1.01599264 ,0.420837432 ,1.64582133 }	,
{-1.29311323 ,0.535624802 ,1.39965606 }	,
{-1.37276185 ,0.273058951 ,-1.39965606 }	,
{-1.61419642 ,0.321083397 ,-1.09970260 }	,
{-1.52053976 ,0.629827976 ,-1.09970260 }	,
{-1.37276185 ,0.273058951 ,-1.39965606 }	,
{-1.52053976 ,0.629827976 ,-1.09970260 }	,
{-1.29311323 ,0.535624802 ,-1.39965606 }	,
{-1.61419642 ,0.321083397 ,1.09970260 }	,
{-1.37276185 ,0.273058951 ,1.39965606 }	,
{-1.29311323 ,0.535624802 ,1.39965606 }	,
{-1.61419642 ,0.321083397 ,1.09970260 }	,
{-1.29311323 ,0.535624802 ,1.39965606 }	,
{-1.52053976 ,0.629827976 ,1.09970260 }	,
{-1.07857192 ,0.214540780 ,-1.64582145 }	,
{-1.37276185 ,0.273058951 ,-1.39965606 }	,
{-1.29311323 ,0.535624802 ,-1.39965606 }	,
{-1.07857192 ,0.214540780 ,-1.64582145 }	,
{-1.29311323 ,0.535624802 ,-1.39965606 }	,
{-1.01599240 ,0.420837373 ,-1.64582145 }	,
{-1.79359984 ,0.356768578 ,0.757488370 }	,
{-1.61419642 ,0.321083397 ,1.09970260 }	,
{-1.52053976 ,0.629827976 ,1.09970260 }	,
{-1.79359984 ,0.356768578 ,0.757488370 }	,
{-1.52053976 ,0.629827976 ,1.09970260 }	,
{-1.68953407 ,0.699827373 ,0.757488370 }	,
{-1.01599264 ,0.420837432 ,1.64582133 }	,
{-0.699827909 ,0.289877653 ,1.82873869 }	,
{-0.629828393 ,0.420837373 ,1.82873869 }	,
{-1.01599264 ,0.420837432 ,1.64582133 }	,
{-0.629828393 ,0.420837373 ,1.82873869 }	,
{-0.914369106 ,0.610961497 ,1.64582133 }	,
{-1.52053976 ,0.629827976 ,-1.09970260 }	,
{-1.68953407 ,0.699827373 ,-0.757488072 }	,
{-1.52054048 ,1.01599216 ,-0.757488072 }	,
{-1.52053976 ,0.629827976 ,-1.09970260 }	,
{-1.52054048 ,1.01599216 ,-0.757488072 }	,
{-1.36844945 ,0.914368629 ,-1.09970260 }	,
{-1.29311323 ,0.535624802 ,1.39965606 }	,
{-1.01599264 ,0.420837432 ,1.64582133 }	,
{-0.914369106 ,0.610961497 ,1.64582133 }	,
{-1.29311323 ,0.535624802 ,1.39965606 }	,
{-0.914369106 ,0.610961497 ,1.64582133 }	,
{-1.16377115 ,0.777606785 ,1.39965606 }	,
{-1.29311323 ,0.535624802 ,-1.39965606 }	,
{-1.52053976 ,0.629827976 ,-1.09970260 }	,
{-1.36844945 ,0.914368629 ,-1.09970260 }	,
{-1.29311323 ,0.535624802 ,-1.39965606 }	,
{-1.36844945 ,0.914368629 ,-1.09970260 }	,
{-1.16377115 ,0.777606785 ,-1.39965606 }	,
{-1.52053976 ,0.629827976 ,1.09970260 }	,
{-1.29311323 ,0.535624802 ,1.39965606 }	,
{-1.16377115 ,0.777606785 ,1.39965606 }	,
{-1.52053976 ,0.629827976 ,1.09970260 }	,
{-1.16377115 ,0.777606785 ,1.39965606 }	,
{-1.36844945 ,0.914368629 ,1.09970260 }	,
{-1.01599240 ,0.420837373 ,-1.64582145 }	,
{-1.29311323 ,0.535624802 ,-1.39965606 }	,
{-1.16377115 ,0.777606785 ,-1.39965606 }	,
{-1.01599240 ,0.420837373 ,-1.64582145 }	,
{-1.16377115 ,0.777606785 ,-1.39965606 }	,
{-0.914368868 ,0.610961378 ,-1.64582145 }	,
{-1.68953407 ,0.699827373 ,0.757488370 }	,
{-1.52053976 ,0.629827976 ,1.09970260 }	,
{-1.36844945 ,0.914368629 ,1.09970260 }	,
{-1.68953407 ,0.699827373 ,0.757488370 }	,
{-1.36844945 ,0.914368629 ,1.09970260 }	,
{-1.52054048 ,1.01599216 ,0.757488370 }	,
{-0.699827671 ,0.289877623 ,-1.82873893 }	,
{-1.01599240 ,0.420837373 ,-1.64582145 }	,
{-0.914368868 ,0.610961378 ,-1.64582145 }	,
{-0.699827671 ,0.289877623 ,-1.82873893 }	,
{-0.914368868 ,0.610961378 ,-1.64582145 }	,
{-0.629828155 ,0.420837283 ,-1.82873893 }	,
{-1.79359889 ,0.742932856 ,0.386164308 }	,
{-1.68953407 ,0.699827373 ,0.757488370 }	,
{-1.52054048 ,1.01599216 ,0.757488370 }	,
{-1.79359889 ,0.742932856 ,0.386164308 }	,
{-1.52054048 ,1.01599216 ,0.757488370 }	,
{-1.61419618 ,1.07857144 ,0.386164308 }	,
{-0.356769085 ,0.147777960 ,-1.94137871 }	,
{-0.699827671 ,0.289877623 ,-1.82873893 }	,
{-0.629828155 ,0.420837283 ,-1.82873893 }	,
{-0.356769085 ,0.147777960 ,-1.94137871 }	,
{-0.629828155 ,0.420837283 ,-1.82873893 }	,
{-0.321083695 ,0.214540616 ,-1.94137871 }	,
{-1.82873809 ,0.757487953 ,1.49441490e-07 }	,
{-1.79359889 ,0.742932856 ,0.386164308 }	,
{-1.61419618 ,1.07857144 ,0.386164308 }	,
{-1.82873809 ,0.757487953 ,1.49441490e-07 }	,
{-1.61419618 ,1.07857144 ,0.386164308 }	,
{-1.64582062 ,1.09970212 ,1.49441490e-07 }	,
{-0.356769472 ,0.147778124 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.321084023 ,0.214540869 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.356769085 ,0.147777960 ,-1.94137871 }	,
{-0.321083695 ,0.214540616 ,-1.94137871 }	,
{-1.79359889 ,0.742932856 ,-0.386164010 }	,
{-1.82873809 ,0.757487953 ,1.49441490e-07 }	,
{-1.64582062 ,1.09970212 ,1.49441490e-07 }	,
{-1.79359889 ,0.742932856 ,-0.386164010 }	,
{-1.64582062 ,1.09970212 ,1.49441490e-07 }	,
{-1.61419618 ,1.07857144 ,-0.386164010 }	,
{-0.699827909 ,0.289877653 ,1.82873869 }	,
{-0.356769472 ,0.147778124 ,1.94137859 }	,
{-0.321084023 ,0.214540869 ,1.94137859 }	,
{-0.699827909 ,0.289877653 ,1.82873869 }	,
{-0.321084023 ,0.214540869 ,1.94137859 }	,
{-0.629828393 ,0.420837373 ,1.82873869 }	,
{-1.68953407 ,0.699827373 ,-0.757488072 }	,
{-1.79359889 ,0.742932856 ,-0.386164010 }	,
{-1.61419618 ,1.07857144 ,-0.386164010 }	,
{-1.68953407 ,0.699827373 ,-0.757488072 }	,
{-1.61419618 ,1.07857144 ,-0.386164010 }	,
{-1.52054048 ,1.01599216 ,-0.757488072 }	,
{-1.61419618 ,1.07857144 ,0.386164308 }	,
{-1.52054048 ,1.01599216 ,0.757488370 }	,
{-1.29311335 ,1.29311275 ,0.757488370 }	,
{-1.61419618 ,1.07857144 ,0.386164308 }	,
{-1.29311335 ,1.29311275 ,0.757488370 }	,
{-1.37276089 ,1.37276089 ,0.386164308 }	,
{-0.321083695 ,0.214540616 ,-1.94137871 }	,
{-0.629828155 ,0.420837283 ,-1.82873893 }	,
{-0.535624802 ,0.535624385 ,-1.82873893 }	,
{-0.321083695 ,0.214540616 ,-1.94137871 }	,
{-0.535624802 ,0.535624385 ,-1.82873893 }	,
{-0.273059219 ,0.273058623 ,-1.94137871 }	,
{-1.64582062 ,1.09970212 ,1.49441490e-07 }	,
{-1.61419618 ,1.07857144 ,0.386164308 }	,
{-1.37276089 ,1.37276089 ,0.386164308 }	,
{-1.64582062 ,1.09970212 ,1.49441490e-07 }	,
{-1.37276089 ,1.37276089 ,0.386164308 }	,
{-1.39965522 ,1.39965534 ,1.49441490e-07 }	,
{-0.321084023 ,0.214540869 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.273059487 ,0.273058921 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.321083695 ,0.214540616 ,-1.94137871 }	,
{-0.273059219 ,0.273058623 ,-1.94137871 }	,
{-1.61419618 ,1.07857144 ,-0.386164010 }	,
{-1.64582062 ,1.09970212 ,1.49441490e-07 }	,
{-1.39965522 ,1.39965534 ,1.49441490e-07 }	,
{-1.61419618 ,1.07857144 ,-0.386164010 }	,
{-1.39965522 ,1.39965534 ,1.49441490e-07 }	,
{-1.37276089 ,1.37276089 ,-0.386164010 }	,
{-0.629828393 ,0.420837373 ,1.82873869 }	,
{-0.321084023 ,0.214540869 ,1.94137859 }	,
{-0.273059487 ,0.273058921 ,1.94137859 }	,
{-0.629828393 ,0.420837373 ,1.82873869 }	,
{-0.273059487 ,0.273058921 ,1.94137859 }	,
{-0.535624921 ,0.535624504 ,1.82873869 }	,
{-1.52054048 ,1.01599216 ,-0.757488072 }	,
{-1.61419618 ,1.07857144 ,-0.386164010 }	,
{-1.37276089 ,1.37276089 ,-0.386164010 }	,
{-1.52054048 ,1.01599216 ,-0.757488072 }	,
{-1.37276089 ,1.37276089 ,-0.386164010 }	,
{-1.29311335 ,1.29311275 ,-0.757488072 }	,
{-0.914369106 ,0.610961497 ,1.64582133 }	,
{-0.629828393 ,0.420837373 ,1.82873869 }	,
{-0.535624921 ,0.535624504 ,1.82873869 }	,
{-0.914369106 ,0.610961497 ,1.64582133 }	,
{-0.535624921 ,0.535624504 ,1.82873869 }	,
{-0.777606964 ,0.777606606 ,1.64582133 }	,
{-1.36844945 ,0.914368629 ,-1.09970260 }	,
{-1.52054048 ,1.01599216 ,-0.757488072 }	,
{-1.29311335 ,1.29311275 ,-0.757488072 }	,
{-1.36844945 ,0.914368629 ,-1.09970260 }	,
{-1.29311335 ,1.29311275 ,-0.757488072 }	,
{-1.16377044 ,1.16377056 ,-1.09970260 }	,
{-1.16377115 ,0.777606785 ,1.39965606 }	,
{-0.914369106 ,0.610961497 ,1.64582133 }	,
{-0.777606964 ,0.777606606 ,1.64582133 }	,
{-1.16377115 ,0.777606785 ,1.39965606 }	,
{-0.777606964 ,0.777606606 ,1.64582133 }	,
{-0.989705980 ,0.989705741 ,1.39965606 }	,
{-1.16377115 ,0.777606785 ,-1.39965606 }	,
{-1.36844945 ,0.914368629 ,-1.09970260 }	,
{-1.16377044 ,1.16377056 ,-1.09970260 }	,
{-1.16377115 ,0.777606785 ,-1.39965606 }	,
{-1.16377044 ,1.16377056 ,-1.09970260 }	,
{-0.989705980 ,0.989705741 ,-1.39965606 }	,
{-1.36844945 ,0.914368629 ,1.09970260 }	,
{-1.16377115 ,0.777606785 ,1.39965606 }	,
{-0.989705980 ,0.989705741 ,1.39965606 }	,
{-1.36844945 ,0.914368629 ,1.09970260 }	,
{-0.989705980 ,0.989705741 ,1.39965606 }	,
{-1.16377044 ,1.16377056 ,1.09970260 }	,
{-0.914368868 ,0.610961378 ,-1.64582145 }	,
{-1.16377115 ,0.777606785 ,-1.39965606 }	,
{-0.989705980 ,0.989705741 ,-1.39965606 }	,
{-0.914368868 ,0.610961378 ,-1.64582145 }	,
{-0.989705980 ,0.989705741 ,-1.39965606 }	,
{-0.777606785 ,0.777606428 ,-1.64582145 }	,
{-1.52054048 ,1.01599216 ,0.757488370 }	,
{-1.36844945 ,0.914368629 ,1.09970260 }	,
{-1.16377044 ,1.16377056 ,1.09970260 }	,
{-1.52054048 ,1.01599216 ,0.757488370 }	,
{-1.16377044 ,1.16377056 ,1.09970260 }	,
{-1.29311335 ,1.29311275 ,0.757488370 }	,
{-0.629828155 ,0.420837283 ,-1.82873893 }	,
{-0.914368868 ,0.610961378 ,-1.64582145 }	,
{-0.777606785 ,0.777606428 ,-1.64582145 }	,
{-0.629828155 ,0.420837283 ,-1.82873893 }	,
{-0.777606785 ,0.777606428 ,-1.64582145 }	,
{-0.535624802 ,0.535624385 ,-1.82873893 }	,
{-1.16377044 ,1.16377056 ,-1.09970260 }	,
{-1.29311335 ,1.29311275 ,-0.757488072 }	,
{-1.01599264 ,1.52053988 ,-0.757488072 }	,
{-1.16377044 ,1.16377056 ,-1.09970260 }	,
{-1.01599264 ,1.52053988 ,-0.757488072 }	,
{-0.914368451 ,1.36844933 ,-1.09970260 }	,
{-0.989705980 ,0.989705741 ,1.39965606 }	,
{-0.777606964 ,0.777606606 ,1.64582133 }	,
{-0.610961735 ,0.914368629 ,1.64582133 }	,
{-0.989705980 ,0.989705741 ,1.39965606 }	,
{-0.610961735 ,0.914368629 ,1.64582133 }	,
{-0.777606905 ,1.16377079 ,1.39965606 }	,
{-0.989705980 ,0.989705741 ,-1.39965606 }	,
{-1.16377044 ,1.16377056 ,-1.09970260 }	,
{-0.914368451 ,1.36844933 ,-1.09970260 }	,
{-0.989705980 ,0.989705741 ,-1.39965606 }	,
{-0.914368451 ,1.36844933 ,-1.09970260 }	,
{-0.777606905 ,1.16377079 ,-1.39965606 }	,
{-1.16377044 ,1.16377056 ,1.09970260 }	,
{-0.989705980 ,0.989705741 ,1.39965606 }	,
{-0.777606905 ,1.16377079 ,1.39965606 }	,
{-1.16377044 ,1.16377056 ,1.09970260 }	,
{-0.777606905 ,1.16377079 ,1.39965606 }	,
{-0.914368451 ,1.36844933 ,1.09970260 }	,
{-0.777606785 ,0.777606428 ,-1.64582145 }	,
{-0.989705980 ,0.989705741 ,-1.39965606 }	,
{-0.777606905 ,1.16377079 ,-1.39965606 }	,
{-0.777606785 ,0.777606428 ,-1.64582145 }	,
{-0.777606905 ,1.16377079 ,-1.39965606 }	,
{-0.610961676 ,0.914368451 ,-1.64582145 }	,
{-1.29311335 ,1.29311275 ,0.757488370 }	,
{-1.16377044 ,1.16377056 ,1.09970260 }	,
{-0.914368451 ,1.36844933 ,1.09970260 }	,
{-1.29311335 ,1.29311275 ,0.757488370 }	,
{-0.914368451 ,1.36844933 ,1.09970260 }	,
{-1.01599264 ,1.52053988 ,0.757488370 }	,
{-0.535624802 ,0.535624385 ,-1.82873893 }	,
{-0.777606785 ,0.777606428 ,-1.64582145 }	,
{-0.610961676 ,0.914368451 ,-1.64582145 }	,
{-0.535624802 ,0.535624385 ,-1.82873893 }	,
{-0.610961676 ,0.914368451 ,-1.64582145 }	,
{-0.420837700 ,0.629827678 ,-1.82873893 }	,
{-1.37276089 ,1.37276089 ,0.386164308 }	,
{-1.29311335 ,1.29311275 ,0.757488370 }	,
{-1.01599264 ,1.52053988 ,0.757488370 }	,
{-1.37276089 ,1.37276089 ,0.386164308 }	,
{-1.01599264 ,1.52053988 ,0.757488370 }	,
{-1.07857120 ,1.61419594 ,0.386164308 }	,
{-0.273059219 ,0.273058623 ,-1.94137871 }	,
{-0.535624802 ,0.535624385 ,-1.82873893 }	,
{-0.420837700 ,0.629827678 ,-1.82873893 }	,
{-0.273059219 ,0.273058623 ,-1.94137871 }	,
{-0.420837700 ,0.629827678 ,-1.82873893 }	,
{-0.214541242 ,0.321083069 ,-1.94137871 }	,
{-1.39965522 ,1.39965534 ,1.49441490e-07 }	,
{-1.37276089 ,1.37276089 ,0.386164308 }	,
{-1.07857120 ,1.61419594 ,0.386164308 }	,
{-1.39965522 ,1.39965534 ,1.49441490e-07 }	,
{-1.07857120 ,1.61419594 ,0.386164308 }	,
{-1.09970188 ,1.64582038 ,1.49441490e-07 }	,
{-0.273059487 ,0.273058921 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.214541450 ,0.321083397 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.273059219 ,0.273058623 ,-1.94137871 }	,
{-0.214541242 ,0.321083069 ,-1.94137871 }	,
{-1.37276089 ,1.37276089 ,-0.386164010 }	,
{-1.39965522 ,1.39965534 ,1.49441490e-07 }	,
{-1.09970188 ,1.64582038 ,1.49441490e-07 }	,
{-1.37276089 ,1.37276089 ,-0.386164010 }	,
{-1.09970188 ,1.64582038 ,1.49441490e-07 }	,
{-1.07857120 ,1.61419594 ,-0.386164010 }	,
{-0.535624921 ,0.535624504 ,1.82873869 }	,
{-0.273059487 ,0.273058921 ,1.94137859 }	,
{-0.214541450 ,0.321083397 ,1.94137859 }	,
{-0.535624921 ,0.535624504 ,1.82873869 }	,
{-0.214541450 ,0.321083397 ,1.94137859 }	,
{-0.420837790 ,0.629827797 ,1.82873869 }	,
{-1.29311335 ,1.29311275 ,-0.757488072 }	,
{-1.37276089 ,1.37276089 ,-0.386164010 }	,
{-1.07857120 ,1.61419594 ,-0.386164010 }	,
{-1.29311335 ,1.29311275 ,-0.757488072 }	,
{-1.07857120 ,1.61419594 ,-0.386164010 }	,
{-1.01599264 ,1.52053988 ,-0.757488072 }	,
{-0.777606964 ,0.777606606 ,1.64582133 }	,
{-0.535624921 ,0.535624504 ,1.82873869 }	,
{-0.420837790 ,0.629827797 ,1.82873869 }	,
{-0.777606964 ,0.777606606 ,1.64582133 }	,
{-0.420837790 ,0.629827797 ,1.82873869 }	,
{-0.610961735 ,0.914368629 ,1.64582133 }	,
{-0.214541242 ,0.321083069 ,-1.94137871 }	,
{-0.420837700 ,0.629827678 ,-1.82873893 }	,
{-0.289878011 ,0.699827135 ,-1.82873893 }	,
{-0.214541242 ,0.321083069 ,-1.94137871 }	,
{-0.289878011 ,0.699827135 ,-1.82873893 }	,
{-0.147778571 ,0.356768489 ,-1.94137871 }	,
{-1.09970188 ,1.64582038 ,1.49441490e-07 }	,
{-1.07857120 ,1.61419594 ,0.386164308 }	,
{-0.742932498 ,1.79359841 ,0.386164308 }	,
{-1.09970188 ,1.64582038 ,1.49441490e-07 }	,
{-0.742932498 ,1.79359841 ,0.386164308 }	,
{-0.757487595 ,1.82873750 ,1.49441490e-07 }	,
{-0.214541450 ,0.321083397 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.147778705 ,0.356768847 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.214541242 ,0.321083069 ,-1.94137871 }	,
{-0.147778571 ,0.356768489 ,-1.94137871 }	,
{-1.07857120 ,1.61419594 ,-0.386164010 }	,
{-1.09970188 ,1.64582038 ,1.49441490e-07 }	,
{-0.757487595 ,1.82873750 ,1.49441490e-07 }	,
{-1.07857120 ,1.61419594 ,-0.386164010 }	,
{-0.757487595 ,1.82873750 ,1.49441490e-07 }	,
{-0.742932498 ,1.79359841 ,-0.386164010 }	,
{-0.420837790 ,0.629827797 ,1.82873869 }	,
{-0.214541450 ,0.321083397 ,1.94137859 }	,
{-0.147778705 ,0.356768847 ,1.94137859 }	,
{-0.420837790 ,0.629827797 ,1.82873869 }	,
{-0.147778705 ,0.356768847 ,1.94137859 }	,
{-0.289878070 ,0.699827254 ,1.82873869 }	,
{-1.01599264 ,1.52053988 ,-0.757488072 }	,
{-1.07857120 ,1.61419594 ,-0.386164010 }	,
{-0.742932498 ,1.79359841 ,-0.386164010 }	,
{-1.01599264 ,1.52053988 ,-0.757488072 }	,
{-0.742932498 ,1.79359841 ,-0.386164010 }	,
{-0.699827850 ,1.68953335 ,-0.757488072 }	,
{-0.610961735 ,0.914368629 ,1.64582133 }	,
{-0.420837790 ,0.629827797 ,1.82873869 }	,
{-0.289878070 ,0.699827254 ,1.82873869 }	,
{-0.610961735 ,0.914368629 ,1.64582133 }	,
{-0.289878070 ,0.699827254 ,1.82873869 }	,
{-0.420837730 ,1.01599205 ,1.64582133 }	,
{-0.914368451 ,1.36844933 ,-1.09970260 }	,
{-1.01599264 ,1.52053988 ,-0.757488072 }	,
{-0.699827850 ,1.68953335 ,-0.757488072 }	,
{-0.914368451 ,1.36844933 ,-1.09970260 }	,
{-0.699827850 ,1.68953335 ,-0.757488072 }	,
{-0.629827678 ,1.52053940 ,-1.09970260 }	,
{-0.777606905 ,1.16377079 ,1.39965606 }	,
{-0.610961735 ,0.914368629 ,1.64582133 }	,
{-0.420837730 ,1.01599205 ,1.64582133 }	,
{-0.777606905 ,1.16377079 ,1.39965606 }	,
{-0.420837730 ,1.01599205 ,1.64582133 }	,
{-0.535624802 ,1.29311287 ,1.39965606 }	,
{-0.777606905 ,1.16377079 ,-1.39965606 }	,
{-0.914368451 ,1.36844933 ,-1.09970260 }	,
{-0.629827678 ,1.52053940 ,-1.09970260 }	,
{-0.777606905 ,1.16377079 ,-1.39965606 }	,
{-0.629827678 ,1.52053940 ,-1.09970260 }	,
{-0.535624802 ,1.29311287 ,-1.39965606 }	,
{-0.914368451 ,1.36844933 ,1.09970260 }	,
{-0.777606905 ,1.16377079 ,1.39965606 }	,
{-0.535624802 ,1.29311287 ,1.39965606 }	,
{-0.914368451 ,1.36844933 ,1.09970260 }	,
{-0.535624802 ,1.29311287 ,1.39965606 }	,
{-0.629827678 ,1.52053940 ,1.09970260 }	,
{-0.610961676 ,0.914368451 ,-1.64582145 }	,
{-0.777606905 ,1.16377079 ,-1.39965606 }	,
{-0.535624802 ,1.29311287 ,-1.39965606 }	,
{-0.610961676 ,0.914368451 ,-1.64582145 }	,
{-0.535624802 ,1.29311287 ,-1.39965606 }	,
{-0.420837611 ,1.01599181 ,-1.64582145 }	,
{-1.01599264 ,1.52053988 ,0.757488370 }	,
{-0.914368451 ,1.36844933 ,1.09970260 }	,
{-0.629827678 ,1.52053940 ,1.09970260 }	,
{-1.01599264 ,1.52053988 ,0.757488370 }	,
{-0.629827678 ,1.52053940 ,1.09970260 }	,
{-0.699827850 ,1.68953335 ,0.757488370 }	,
{-0.420837700 ,0.629827678 ,-1.82873893 }	,
{-0.610961676 ,0.914368451 ,-1.64582145 }	,
{-0.420837611 ,1.01599181 ,-1.64582145 }	,
{-0.420837700 ,0.629827678 ,-1.82873893 }	,
{-0.420837611 ,1.01599181 ,-1.64582145 }	,
{-0.289878011 ,0.699827135 ,-1.82873893 }	,
{-1.07857120 ,1.61419594 ,0.386164308 }	,
{-1.01599264 ,1.52053988 ,0.757488370 }	,
{-0.699827850 ,1.68953335 ,0.757488370 }	,
{-1.07857120 ,1.61419594 ,0.386164308 }	,
{-0.699827850 ,1.68953335 ,0.757488370 }	,
{-0.742932498 ,1.79359841 ,0.386164308 }	,
{-0.535624802 ,1.29311287 ,-1.39965606 }	,
{-0.629827678 ,1.52053940 ,-1.09970260 }	,
{-0.321083099 ,1.61419582 ,-1.09970260 }	,
{-0.535624802 ,1.29311287 ,-1.39965606 }	,
{-0.321083099 ,1.61419582 ,-1.09970260 }	,
{-0.273059011 ,1.37276125 ,-1.39965606 }	,
{-0.629827678 ,1.52053940 ,1.09970260 }	,
{-0.535624802 ,1.29311287 ,1.39965606 }	,
{-0.273059011 ,1.37276125 ,1.39965606 }	,
{-0.629827678 ,1.52053940 ,1.09970260 }	,
{-0.273059011 ,1.37276125 ,1.39965606 }	,
{-0.321083099 ,1.61419582 ,1.09970260 }	,
{-0.420837611 ,1.01599181 ,-1.64582145 }	,
{-0.535624802 ,1.29311287 ,-1.39965606 }	,
{-0.273059011 ,1.37276125 ,-1.39965606 }	,
{-0.420837611 ,1.01599181 ,-1.64582145 }	,
{-0.273059011 ,1.37276125 ,-1.39965606 }	,
{-0.214541018 ,1.07857108 ,-1.64582145 }	,
{-0.699827850 ,1.68953335 ,0.757488370 }	,
{-0.629827678 ,1.52053940 ,1.09970260 }	,
{-0.321083099 ,1.61419582 ,1.09970260 }	,
{-0.699827850 ,1.68953335 ,0.757488370 }	,
{-0.321083099 ,1.61419582 ,1.09970260 }	,
{-0.356769055 ,1.79359913 ,0.757488370 }	,
{-0.289878011 ,0.699827135 ,-1.82873893 }	,
{-0.420837611 ,1.01599181 ,-1.64582145 }	,
{-0.214541018 ,1.07857108 ,-1.64582145 }	,
{-0.289878011 ,0.699827135 ,-1.82873893 }	,
{-0.214541018 ,1.07857108 ,-1.64582145 }	,
{-0.147778437 ,0.742932498 ,-1.82873893 }	,
{-0.742932498 ,1.79359841 ,0.386164308 }	,
{-0.699827850 ,1.68953335 ,0.757488370 }	,
{-0.356769055 ,1.79359913 ,0.757488370 }	,
{-0.742932498 ,1.79359841 ,0.386164308 }	,
{-0.356769055 ,1.79359913 ,0.757488370 }	,
{-0.378743440 ,1.90407383 ,0.386164308 }	,
{-0.147778571 ,0.356768489 ,-1.94137871 }	,
{-0.289878011 ,0.699827135 ,-1.82873893 }	,
{-0.147778437 ,0.742932498 ,-1.82873893 }	,
{-0.147778571 ,0.356768489 ,-1.94137871 }	,
{-0.147778437 ,0.742932498 ,-1.82873893 }	,
{-0.0753368437 ,0.378743410 ,-1.94137871 }	,
{-0.757487595 ,1.82873750 ,1.49441490e-07 }	,
{-0.742932498 ,1.79359841 ,0.386164308 }	,
{-0.378743440 ,1.90407383 ,0.386164308 }	,
{-0.757487595 ,1.82873750 ,1.49441490e-07 }	,
{-0.378743440 ,1.90407383 ,0.386164308 }	,
{-0.386163563 ,1.94137728 ,1.49441490e-07 }	,
{-0.147778705 ,0.356768847 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{-0.0753368884 ,0.378743798 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.147778571 ,0.356768489 ,-1.94137871 }	,
{-0.0753368437 ,0.378743410 ,-1.94137871 }	,
{-0.742932498 ,1.79359841 ,-0.386164010 }	,
{-0.757487595 ,1.82873750 ,1.49441490e-07 }	,
{-0.386163563 ,1.94137728 ,1.49441490e-07 }	,
{-0.742932498 ,1.79359841 ,-0.386164010 }	,
{-0.386163563 ,1.94137728 ,1.49441490e-07 }	,
{-0.378743440 ,1.90407383 ,-0.386164010 }	,
{-0.289878070 ,0.699827254 ,1.82873869 }	,
{-0.147778705 ,0.356768847 ,1.94137859 }	,
{-0.0753368884 ,0.378743798 ,1.94137859 }	,
{-0.289878070 ,0.699827254 ,1.82873869 }	,
{-0.0753368884 ,0.378743798 ,1.94137859 }	,
{-0.147778466 ,0.742932618 ,1.82873869 }	,
{-0.699827850 ,1.68953335 ,-0.757488072 }	,
{-0.742932498 ,1.79359841 ,-0.386164010 }	,
{-0.378743440 ,1.90407383 ,-0.386164010 }	,
{-0.699827850 ,1.68953335 ,-0.757488072 }	,
{-0.378743440 ,1.90407383 ,-0.386164010 }	,
{-0.356769055 ,1.79359913 ,-0.757488072 }	,
{-0.420837730 ,1.01599205 ,1.64582133 }	,
{-0.289878070 ,0.699827254 ,1.82873869 }	,
{-0.147778466 ,0.742932618 ,1.82873869 }	,
{-0.420837730 ,1.01599205 ,1.64582133 }	,
{-0.147778466 ,0.742932618 ,1.82873869 }	,
{-0.214541093 ,1.07857132 ,1.64582133 }	,
{-0.629827678 ,1.52053940 ,-1.09970260 }	,
{-0.699827850 ,1.68953335 ,-0.757488072 }	,
{-0.356769055 ,1.79359913 ,-0.757488072 }	,
{-0.629827678 ,1.52053940 ,-1.09970260 }	,
{-0.356769055 ,1.79359913 ,-0.757488072 }	,
{-0.321083099 ,1.61419582 ,-1.09970260 }	,
{-0.535624802 ,1.29311287 ,1.39965606 }	,
{-0.420837730 ,1.01599205 ,1.64582133 }	,
{-0.214541093 ,1.07857132 ,1.64582133 }	,
{-0.535624802 ,1.29311287 ,1.39965606 }	,
{-0.214541093 ,1.07857132 ,1.64582133 }	,
{-0.273059011 ,1.37276125 ,1.39965606 }	,
{-0.0753368884 ,0.378743798 ,1.94137859 }	,
{-4.56065635e-07 ,-1.10104008e-06 ,1.97941256 }	,
{0.00000000 ,0.386164248 ,1.94137859 }	,
{0.00000000 ,-6.44974477e-07 ,-1.97941256 }	,
{-0.0753368437 ,0.378743410 ,-1.94137871 }	,
{2.99677652e-08 ,0.386163443 ,-1.94137871 }	,
{-0.378743440 ,1.90407383 ,-0.386164010 }	,
{-0.386163563 ,1.94137728 ,1.49441490e-07 }	,
{0.00000000 ,1.97941256 ,1.49441490e-07 }	,
{-0.378743440 ,1.90407383 ,-0.386164010 }	,
{0.00000000 ,1.97941256 ,1.49441490e-07 }	,
{0.00000000 ,1.94137871 ,-0.386164010 }	,
{-0.147778466 ,0.742932618 ,1.82873869 }	,
{-0.0753368884 ,0.378743798 ,1.94137859 }	,
{0.00000000 ,0.386164248 ,1.94137859 }	,
{-0.147778466 ,0.742932618 ,1.82873869 }	,
{0.00000000 ,0.386164248 ,1.94137859 }	,
{0.00000000 ,0.757488430 ,1.82873869 }	,
{-0.356769055 ,1.79359913 ,-0.757488072 }	,
{-0.378743440 ,1.90407383 ,-0.386164010 }	,
{0.00000000 ,1.94137871 ,-0.386164010 }	,
{-0.356769055 ,1.79359913 ,-0.757488072 }	,
{0.00000000 ,1.94137871 ,-0.386164010 }	,
{1.25828294e-07 ,1.82873774 ,-0.757488072 }	,
{-0.214541093 ,1.07857132 ,1.64582133 }	,
{-0.147778466 ,0.742932618 ,1.82873869 }	,
{0.00000000 ,0.757488430 ,1.82873869 }	,
{-0.214541093 ,1.07857132 ,1.64582133 }	,
{0.00000000 ,0.757488430 ,1.82873869 }	,
{0.00000000 ,1.09970272 ,1.64582133 }	,
{-0.321083099 ,1.61419582 ,-1.09970260 }	,
{-0.356769055 ,1.79359913 ,-0.757488072 }	,
{1.25828294e-07 ,1.82873774 ,-0.757488072 }	,
{-0.321083099 ,1.61419582 ,-1.09970260 }	,
{1.25828294e-07 ,1.82873774 ,-0.757488072 }	,
{5.38765960e-07 ,1.64581966 ,-1.09970260 }	,
{-0.273059011 ,1.37276125 ,1.39965606 }	,
{-0.214541093 ,1.07857132 ,1.64582133 }	,
{0.00000000 ,1.09970272 ,1.64582133 }	,
{-0.273059011 ,1.37276125 ,1.39965606 }	,
{0.00000000 ,1.09970272 ,1.64582133 }	,
{0.00000000 ,1.39965606 ,1.39965606 }	,
{-0.273059011 ,1.37276125 ,-1.39965606 }	,
{-0.321083099 ,1.61419582 ,-1.09970260 }	,
{5.38765960e-07 ,1.64581966 ,-1.09970260 }	,
{-0.273059011 ,1.37276125 ,-1.39965606 }	,
{5.38765960e-07 ,1.64581966 ,-1.09970260 }	,
{3.02801567e-07 ,1.39965522 ,-1.39965606 }	,
{-0.321083099 ,1.61419582 ,1.09970260 }	,
{-0.273059011 ,1.37276125 ,1.39965606 }	,
{0.00000000 ,1.39965606 ,1.39965606 }	,
{-0.321083099 ,1.61419582 ,1.09970260 }	,
{0.00000000 ,1.39965606 ,1.39965606 }	,
{0.00000000 ,1.64582145 ,1.09970260 }	,
{-0.214541018 ,1.07857108 ,-1.64582145 }	,
{-0.273059011 ,1.37276125 ,-1.39965606 }	,
{3.02801567e-07 ,1.39965522 ,-1.39965606 }	,
{-0.214541018 ,1.07857108 ,-1.64582145 }	,
{3.02801567e-07 ,1.39965522 ,-1.39965606 }	,
{0.00000000 ,1.09970260 ,-1.64582145 }	,
{-0.356769055 ,1.79359913 ,0.757488370 }	,
{-0.321083099 ,1.61419582 ,1.09970260 }	,
{0.00000000 ,1.64582145 ,1.09970260 }	,
{-0.356769055 ,1.79359913 ,0.757488370 }	,
{0.00000000 ,1.64582145 ,1.09970260 }	,
{0.00000000 ,1.82873869 ,0.757488370 }	,
{-0.147778437 ,0.742932498 ,-1.82873893 }	,
{-0.214541018 ,1.07857108 ,-1.64582145 }	,
{0.00000000 ,1.09970260 ,-1.64582145 }	,
{-0.147778437 ,0.742932498 ,-1.82873893 }	,
{0.00000000 ,1.09970260 ,-1.64582145 }	,
{1.55323832e-07 ,0.757487357 ,-1.82873893 }	,
{-0.378743440 ,1.90407383 ,0.386164308 }	,
{-0.356769055 ,1.79359913 ,0.757488370 }	,
{0.00000000 ,1.82873869 ,0.757488370 }	,
{-0.378743440 ,1.90407383 ,0.386164308 }	,
{0.00000000 ,1.82873869 ,0.757488370 }	,
{0.00000000 ,1.94137859 ,0.386164308 }	,
{-0.0753368437 ,0.378743410 ,-1.94137871 }	,
{-0.147778437 ,0.742932498 ,-1.82873893 }	,
{1.55323832e-07 ,0.757487357 ,-1.82873893 }	,
{-0.0753368437 ,0.378743410 ,-1.94137871 }	,
{1.55323832e-07 ,0.757487357 ,-1.82873893 }	,
{2.99677652e-08 ,0.386163443 ,-1.94137871 }	,
{-0.386163563 ,1.94137728 ,1.49441490e-07 }	,
{-0.378743440 ,1.90407383 ,0.386164308 }	,
{0.00000000 ,1.94137859 ,0.386164308 }	,
{-0.386163563 ,1.94137728 ,1.49441490e-07 }	,
{0.00000000 ,1.94137859 ,0.386164308 }	,
{0.00000000 ,1.97941256 ,1.49441490e-07 }

		};

#pragma endregion vDat
		PointLightVNT.resize(dat.size());
		for (int i = 0; i < dat.size(); i++) {
			fillBlank(&PointLightVNT, &dat[i], i);
		}

	}
	void LoadSpotLightVNT() {
#pragma region vDat
		std::vector <XMFLOAT3> dat = {

{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.195090324 ,0.997116029 ,-1.94718647 }	,
{0.195090324 ,0.997116029 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.382683456 ,0.940210283 ,-1.94718647 }	,
{0.382683456 ,0.940210283 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.555570245 ,0.847800374 ,-1.94718647 }	,
{0.555570245 ,0.847800374 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.707106769 ,0.723437548 ,-1.94718647 }	,
{0.707106769 ,0.723437548 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.831469655 ,0.571900964 ,-1.94718647 }	,
{0.831469655 ,0.571900964 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.923879504 ,0.399014235 ,-1.94718647 }	,
{0.923879504 ,0.399014235 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.980785251 ,0.211421162 ,-1.94718647 }	,
{0.980785251 ,0.211421162 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{1.00000000 ,0.0163308773 ,-1.94718647 }	,
{1.00000000 ,0.0163308773 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.980785310 ,-0.178759396 ,-1.94718647 }	,
{0.980785310 ,-0.178759396 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.923879564 ,-0.366352469 ,-1.94718647 }	,
{0.923879564 ,-0.366352469 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.831469655 ,-0.539239407 ,-1.94718647 }	,
{0.831469655 ,-0.539239407 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.707106769 ,-0.690775990 ,-1.94718647 }	,
{0.707106769 ,-0.690775990 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.555570185 ,-0.815138876 ,-1.94718647 }	,
{0.555570185 ,-0.815138876 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.382683277 ,-0.907548845 ,-1.94718647 }	,
{0.382683277 ,-0.907548845 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{0.195090085 ,-0.964454532 ,-1.94718647 }	,
{0.195090085 ,-0.964454532 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-3.25841370e-07 ,-0.983669221 ,-1.94718647 }	,
{-3.25841370e-07 ,-0.983669221 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.195090726 ,-0.964454412 ,-1.94718647 }	,
{-0.195090726 ,-0.964454412 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.382683873 ,-0.907548547 ,-1.94718647 }	,
{-0.382683873 ,-0.907548547 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.555570722 ,-0.815138519 ,-1.94718647 }	,
{-0.555570722 ,-0.815138519 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.707107246 ,-0.690775573 ,-1.94718647 }	,
{-0.707107246 ,-0.690775573 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.831470013 ,-0.539238870 ,-1.94718647 }	,
{-0.831470013 ,-0.539238870 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.923879862 ,-0.366351873 ,-1.94718647 }	,
{-0.923879862 ,-0.366351873 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.980785429 ,-0.178758651 ,-1.94718647 }	,
{-0.980785429 ,-0.178758651 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-1.00000000 ,0.0163317658 ,-1.94718647 }	,
{-1.00000000 ,0.0163317658 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.980785072 ,0.211422145 ,-1.94718647 }	,
{-0.980785072 ,0.211422145 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.923879087 ,0.399015278 ,-1.94718647 }	,
{-0.923879087 ,0.399015278 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.831468940 ,0.571902037 ,-1.94718647 }	,
{-0.831468940 ,0.571902037 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.707105875 ,0.723438442 ,-1.94718647 }	,
{-0.707105875 ,0.723438442 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.555569112 ,0.847801149 ,-1.94718647 }	,
{-0.555569112 ,0.847801149 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.382682085 ,0.940210879 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.195090324 ,0.997116029 ,-1.94718647 }	,
{0.382683456 ,0.940210283 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.382683456 ,0.940210283 ,-1.94718647 }	,
{0.555570245 ,0.847800374 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.555570245 ,0.847800374 ,-1.94718647 }	,
{0.707106769 ,0.723437548 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.707106769 ,0.723437548 ,-1.94718647 }	,
{0.831469655 ,0.571900964 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.831469655 ,0.571900964 ,-1.94718647 }	,
{0.923879504 ,0.399014235 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.923879504 ,0.399014235 ,-1.94718647 }	,
{0.980785251 ,0.211421162 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.980785251 ,0.211421162 ,-1.94718647 }	,
{1.00000000 ,0.0163308773 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{1.00000000 ,0.0163308773 ,-1.94718647 }	,
{0.980785310 ,-0.178759396 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.980785310 ,-0.178759396 ,-1.94718647 }	,
{0.923879564 ,-0.366352469 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.923879564 ,-0.366352469 ,-1.94718647 }	,
{0.831469655 ,-0.539239407 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.831469655 ,-0.539239407 ,-1.94718647 }	,
{0.707106769 ,-0.690775990 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.707106769 ,-0.690775990 ,-1.94718647 }	,
{0.555570185 ,-0.815138876 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.555570185 ,-0.815138876 ,-1.94718647 }	,
{0.382683277 ,-0.907548845 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.382683277 ,-0.907548845 ,-1.94718647 }	,
{0.195090085 ,-0.964454532 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{0.195090085 ,-0.964454532 ,-1.94718647 }	,
{-3.25841370e-07 ,-0.983669221 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-3.25841370e-07 ,-0.983669221 ,-1.94718647 }	,
{-0.195090726 ,-0.964454412 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.195090726 ,-0.964454412 ,-1.94718647 }	,
{-0.382683873 ,-0.907548547 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.382683873 ,-0.907548547 ,-1.94718647 }	,
{-0.555570722 ,-0.815138519 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.555570722 ,-0.815138519 ,-1.94718647 }	,
{-0.707107246 ,-0.690775573 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.707107246 ,-0.690775573 ,-1.94718647 }	,
{-0.831470013 ,-0.539238870 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.831470013 ,-0.539238870 ,-1.94718647 }	,
{-0.923879862 ,-0.366351873 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.923879862 ,-0.366351873 ,-1.94718647 }	,
{-0.980785429 ,-0.178758651 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.980785429 ,-0.178758651 ,-1.94718647 }	,
{-1.00000000 ,0.0163317658 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-1.00000000 ,0.0163317658 ,-1.94718647 }	,
{-0.980785072 ,0.211422145 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.980785072 ,0.211422145 ,-1.94718647 }	,
{-0.923879087 ,0.399015278 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.923879087 ,0.399015278 ,-1.94718647 }	,
{-0.831468940 ,0.571902037 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.831468940 ,0.571902037 ,-1.94718647 }	,
{-0.707105875 ,0.723438442 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.707105875 ,0.723438442 ,-1.94718647 }	,
{-0.555569112 ,0.847801149 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.555569112 ,0.847801149 ,-1.94718647 }	,
{-0.382682085 ,0.940210879 ,-1.94718647 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }	,
{-0.382682085 ,0.940210879 ,-1.94718647 }	,
{-0.195088819 ,0.997116327 ,-1.94718647 }	,
{-0.382682085 ,0.940210879 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-0.195088819 ,0.997116327 ,-1.94718647 }	,
{-0.195088819 ,0.997116327 ,-1.94718647 }	,
{-2.10317659e-16 ,0.0163308010 ,0.0528134704 }	,
{-2.10317659e-16 ,1.01633084 ,-1.94718647 }

		};
#pragma endregion vDat

		SpotLightVNT.resize(dat.size());
		for (int i = 0; i < dat.size(); i++) {
			fillBlank(&SpotLightVNT, &dat[i], i);
		}
	}
	//////////////////////////////////////////////////////////END OF MODEL DEBUG V's


	// 0 - nothing
	// 1 - 3d regular VS
	// 2 - 2d regular VS
	int LastVSUsed = 0;

	// 0 - nothing
	// 1 - 2d regular PS
	// 2 - 2d regular PS
	int LastPSUsed = 0;

	void DefaultLastVSPSUsed() {// I cannot promise the last shader binded is not following only my shader extension - so I must pretend it was unbinded - so I set 0 at some points
		LastPSUsed = 0;
		LastVSUsed = 0;
	}

	ID3D11RasterizerState* dxRasterizerState3DAllFace = nullptr;
	ID3D11RasterizerState* dxRasterizerState3DBackFace = nullptr;
	ID3D11RasterizerState* dxRasterizerState3DFrontFace = nullptr;
	int CurrentFaceDrawType = 0;
	enum { ALL_FACE = 0, BACK_FACE = 1, FRONT_FACE = 2 };


	ID3D11DepthStencilState* dxDepthStencilState3DKeepDepth = nullptr;
	ID3D11DepthStencilState* dxDepthStencilState3DIgnoreDepth = nullptr;
	int CurrentDepthDrawType = 0;

	void Create3dRasterDesc() {

		D3D11_RASTERIZER_DESC rasterizerDesc;
		ZeroMemory(&rasterizerDesc, sizeof(D3D11_RASTERIZER_DESC));

		rasterizerDesc.AntialiasedLineEnable = FALSE;
		rasterizerDesc.CullMode = D3D11_CULL_NONE;
		rasterizerDesc.DepthBias = 0.0f;
		rasterizerDesc.DepthBiasClamp = 0.0f;
		rasterizerDesc.SlopeScaledDepthBias = 0.0f;
		rasterizerDesc.DepthClipEnable = false;
		rasterizerDesc.FillMode = D3D11_FILL_SOLID;
		rasterizerDesc.FrontCounterClockwise = FALSE;
		rasterizerDesc.MultisampleEnable = FALSE;
		rasterizerDesc.ScissorEnable = FALSE;

		dxDevice->CreateRasterizerState(
			&rasterizerDesc,
			&dxRasterizerState3DAllFace);

		rasterizerDesc.CullMode = D3D11_CULL_BACK;

		dxDevice->CreateRasterizerState(
			&rasterizerDesc,
			&dxRasterizerState3DBackFace);

		rasterizerDesc.CullMode = D3D11_CULL_FRONT;

		dxDevice->CreateRasterizerState(
			&rasterizerDesc,
			&dxRasterizerState3DFrontFace);

		D3D11_DEPTH_STENCIL_DESC depthStencilStateDesc;
		ZeroMemory(&depthStencilStateDesc, sizeof(D3D11_DEPTH_STENCIL_DESC));

		depthStencilStateDesc.DepthEnable = TRUE; //this is a bad idea
		depthStencilStateDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
		depthStencilStateDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;
		depthStencilStateDesc.StencilEnable = FALSE; //for now don't want it

		// Stencil operations if pixel is front-facing.
		depthStencilStateDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
		depthStencilStateDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
		depthStencilStateDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
		depthStencilStateDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

		// Stencil operations if pixel is back-facing.
		depthStencilStateDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
		depthStencilStateDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
		depthStencilStateDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
		depthStencilStateDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

		dxDevice->CreateDepthStencilState(&depthStencilStateDesc, &dxDepthStencilState3DKeepDepth);

		depthStencilStateDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
		depthStencilStateDesc.DepthFunc = D3D11_COMPARISON_EQUAL;
		dxDevice->CreateDepthStencilState(&depthStencilStateDesc, &dxDepthStencilState3DIgnoreDepth);


	}

	void PGEX3DGeneralRenderStateAllFace() {
		CurrentFaceDrawType = 0;
		dxDeviceContext->RSSetState(dxRasterizerState3DAllFace);

	}
	void PGEX3DGeneralRenderStateBackFace() {
		CurrentFaceDrawType = 1;
		dxDeviceContext->RSSetState(dxRasterizerState3DBackFace);
	}
	void PGEX3DGeneralRenderStateFrontFace() {
		CurrentFaceDrawType = 2;
		dxDeviceContext->RSSetState(dxRasterizerState3DFrontFace);
	}


	std::array<std::function<void()>, 3> Set3dFaceRasterArray = {
		[&]() {PGEX3DGeneralRenderStateAllFace(); },[&]() {PGEX3DGeneralRenderStateBackFace(); },[&]() {PGEX3DGeneralRenderStateFrontFace(); }
	};

	void PGEX3DGeneralDepthStateKeep() {
		CurrentDepthDrawType = 0;
		dxDeviceContext->OMSetDepthStencilState(dxDepthStencilState3DKeepDepth, 1);

	}
	void PGEX3DGeneralDepthStateIgnore() {
		CurrentDepthDrawType = 1;
		dxDeviceContext->OMSetDepthStencilState(dxDepthStencilState3DIgnoreDepth, 1);
	}
	std::array<std::function<void()>, 3> Set3dDepthArray = {
		[&]() {PGEX3DGeneralDepthStateKeep(); },[&]() {PGEX3DGeneralDepthStateIgnore(); } };


	void PGEX3DGeneralRenderStateSet() { //reduce calls because its dumb.... i'll slowly do this more as time passes
		CurrentFaceDrawType = 0;
		dxDeviceContext->RSSetState(dxRasterizerState3DAllFace);

		CurrentDepthDrawType = 0;
		dxDeviceContext->OMSetDepthStencilState(dxDepthStencilState3DKeepDepth, 1);
		dxDeviceContext->OMSetRenderTargets(
			1,
			&dxRenderTargetView,
			dxDepthStencilView);
	}



	void RegularRasterState() {
		dxDeviceContext->RSSetState(dxRasterizerStateF);
		dxDeviceContext->OMSetDepthStencilState(dxDepthStencilStateDefault, 1);

		dxDeviceContext->OMSetRenderTargets(
			1,
			&dxRenderTargetView,
			nullptr);

	}

	float MyPi = 3.141592653;

	float radToD(float rad) {
		return rad * (180 / MyPi);
	}

	float aToRad(float ang) {
		return ang * (MyPi / 180);
	}


	float ToNotPGESpace(float* InvScreenSize, float* val) {
		return (*val) * (*InvScreenSize) * 2.0f; //returns to regular not PGE space
	}
	float ToPGESpace(float* InvScreenSize, float* val) {
		return (*val) / (*InvScreenSize) / 2.0f; //returns pixel space
	}


	struct DataDrawOrderAndFunc {
		//place holder struct incase things get more complex
		std::function<void()> func;

	};




	struct DataLerpFunc { //end position
		//place holder struct incase things get more complex 
		std::function<void()> func;
		float X = 0.0f;
		bool useX = false;

		float Y = 0.0f;
		bool useY = false;

		float Z = 0.0f;
		bool useZ = false;

		float MaxTime = 0.0f;
		float CurTime = 0.0f;

		DataLerpFunc* me() {
			return this;
		}
	};


	std::vector< DataDrawOrderAndFunc > DrawOrder;
	std::vector< DataDrawOrderAndFunc > DrawOrderBefore;

	std::vector< DataLerpFunc > LerpCamFunc;
	//std::vector< DataLerpFunc > LerpCamRotFunc;

	std::vector< DataLerpFunc > LerpModelFunc;

	class ProgramLink_3D_DX : public olc::PGEX {
	public:

		void Initialize3DShadersPL(int LayersToUse = 0);

		ProgramLink_3D_DX()
		{

		}

		int32_t ScreenWidth() { return pge->ScreenWidth(); };
		int32_t ScreenHeight() { return pge->ScreenHeight(); };

		void DrawFuncMain();

		bool IniSAndB = false;

		int currentLayer = 0;

		std::function<void()> DrawerHandle = [&] { DrawFuncMain(); };

		float LastSec() { return pge->GetElapsedTime(); };

	}PL;



}

namespace DOLC11 {

	bool DepthPrePass = false;

	struct ObjTuneStatReg { //TODO: make scale and translate work in shader - make obj visible
		std::array<float, 3> Translate = { 0.0f,0.0f,0.0f }; //not using xm float, so sad... :(
		float pad1 = 0.0f;
		std::array<float, 3> Scale = { 1.0f,1.0f,1.0f };
		float pad2 = 0.0f;
		XMFLOAT4 Quat = { 0.0f,0.0f,0.0f,0.0f };
		//XMFLOAT4 pad2 = {0.0f,0.0f,0.0f,0.0f};
	};

	//	struct BoneInfoStruct {
			//UINT ID;
	//		 t_m; //trans matrix
	//		XMFLOAT4X4 t_l_m; //trans link matrix
	//	};

	void SeperateTransformationMatrix(XMFLOAT4X4* Im, ObjTuneStatReg* transformDat) {
		//TODO: matrix rot and stuff extraction
	}
	XMFLOAT4X4 ofbxMatToXM(ofbx::Matrix* TMPtm) {
		return XMFLOAT4X4(static_cast<float>(TMPtm->m[0]), static_cast<float>(TMPtm->m[1]), static_cast<float>(TMPtm->m[2]), static_cast<float>(TMPtm->m[3]), static_cast<float>(TMPtm->m[4]), static_cast<float>(TMPtm->m[5]), static_cast<float>(TMPtm->m[6]), static_cast<float>(TMPtm->m[7]), static_cast<float>(TMPtm->m[8]), static_cast<float>(TMPtm->m[9]), static_cast<float>(TMPtm->m[10]), static_cast<float>(TMPtm->m[11]), static_cast<float>(TMPtm->m[12]), static_cast<float>(TMPtm->m[13]), static_cast<float>(TMPtm->m[14]), static_cast<float>(TMPtm->m[15]));
	}
	ofbx::Matrix XMToofbxMat(XMFLOAT4X4* TMPtm) {
		return { TMPtm->m[0][0],TMPtm->m[0][1],TMPtm->m[0][2],TMPtm->m[0][3],TMPtm->m[1][0],TMPtm->m[1][1],TMPtm->m[1][2],TMPtm->m[1][3] ,TMPtm->m[2][0],TMPtm->m[2][1],TMPtm->m[2][2],TMPtm->m[2][3] ,TMPtm->m[3][0],TMPtm->m[3][1],TMPtm->m[3][2],TMPtm->m[3][3] };

	}


	std::array<float, 3> GetTranslate(ObjTuneStatReg* ObjTune) {
		olc::vf2d vInvScreenSize = {
	(1.0f / float(PL.ScreenWidth())),
	(1.0f / float(PL.ScreenHeight()))
		};
		return std::array<float, 3> { ToPGESpace(&vInvScreenSize.x, &ObjTune->Translate[0]), ToPGESpace(&vInvScreenSize.y, &ObjTune->Translate[1]), ToPGESpace(&vInvScreenSize.x, &ObjTune->Translate[2]) };
	}

	std::array<float, 3> GetScale(ObjTuneStatReg* ObjTune) {
		return ObjTune->Scale;
	}
	std::array<float, 4> GetQuaternion(ObjTuneStatReg* ObjTune) {
		return std::array<float, 4> {ObjTune->Quat.x, ObjTune->Quat.y, ObjTune->Quat.z, ObjTune->Quat.w};
	}
	std::array<float, 3> GetRadians(ObjTuneStatReg* ObjTune) { //ObjTune.Quat
		float quatDiv = sqrt(1 - ObjTune->Quat.w * ObjTune->Quat.w);
		return std::array<float, 3> {(ObjTune->Quat.x / quatDiv), (ObjTune->Quat.y / quatDiv), (ObjTune->Quat.z / quatDiv)};
	}

	ofbx::Vec3 GetDataFromAnimation(double time, const ofbx::AnimationCurveNode* node) {

		return node->getNodeLocalTransform(time); //every of these calls it recomputes getLocalTransform TODO : check why time not working

	}

	struct Plane {
		XMFLOAT3 normal;
		float distance;
	};
	struct Frustum {
		Plane plane[4];
	};

	struct ScreenToViewParamsStruct {

		XMMATRIX InverseProjectionMatrix;
		XMFLOAT2 ScreenDim;

		void MathInvProjM() {
			InverseProjectionMatrix = XMMatrixInverse(nullptr,dxProjectionMatrix);
		}
		void MathSetScreenDim() {
			ScreenDim.x = (float(PL.ScreenWidth()));
			ScreenDim.y = (float(PL.ScreenHeight()));
		}
		void SetParams() {
			MathInvProjM();
			MathSetScreenDim();
		}
	};

	struct DispatchParamsStruct {

		UINT numThreadGroups[3];
		UINT pad1 = 1;

		UINT numThreads[3];
		UINT pad2 = 1;

	};

	struct FrustumObjectAndShaderLight {
		UINT BLOCK_SIZE = 16;

		ID3D11SamplerState* Sampler = NULL;

		Frustum Frustum;
		ID3D11Buffer* FDat;
		ID3D11UnorderedAccessView* FOutDat; //TODO, pass this and eye to frustrum compute
		ID3D11ShaderResourceView* FInDat;

		ScreenToViewParamsStruct ScreenToViewParams;
		ID3D11Buffer* ScreenToViewParamsBuf;

		DispatchParamsStruct DispatchParams;
		ID3D11Buffer* DispatchParamsBuf;

		ID3D11ShaderResourceView* DepthStencilRLink;
		//
		ID3D11Buffer* o_LightIndexCounterBuf;
		ID3D11UnorderedAccessView* o_LightIndexCounterUAV; 
		ID3D11ShaderResourceView* o_LightIndexCounterSRV;

		ID3D11Buffer* t_LightIndexCounterBuf;
		ID3D11UnorderedAccessView* t_LightIndexCounterUAV; 
		ID3D11ShaderResourceView* t_LightIndexCounterSRV;

		ID3D11Buffer* o_LightIndexListBuf;
		ID3D11UnorderedAccessView* o_LightIndexListUAV; 
		ID3D11ShaderResourceView* o_LightIndexListSRV;

		ID3D11Buffer* t_LightIndexListBuf;
		ID3D11UnorderedAccessView* t_LightIndexListUAV; 
		ID3D11ShaderResourceView* t_LightIndexListSRV;

		ID3D11Texture2D* o_LightGridBuf;
		ID3D11UnorderedAccessView* o_LightGridUAV; 
		ID3D11ShaderResourceView* o_LightGridSRV;

		ID3D11Texture2D* t_LightGridBuf;
		ID3D11UnorderedAccessView* t_LightGridUAV;
		ID3D11ShaderResourceView* t_LightGridSRV;

		UINT DepthSizeX = 0;
		UINT DepthSizeY = 0;

		ID3D11Texture2D* DebugTextureBuf;
		ID3D11UnorderedAccessView* DebugTextureUAV;
		ID3D11ShaderResourceView* DebugTextureSRV;

		float FOVCheck = -1.0f;

		void DebugTexBufDefault() {
			if (DebugTextureBuf != NULL) {
				SafeRelease(DebugTextureBuf);
			}
			DepthSizeX = PL.ScreenWidth();
			DepthSizeY = PL.ScreenHeight();


			D3D11_TEXTURE2D_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(D3D11_TEXTURE2D_DESC));

			bufDesc.ArraySize = 1;
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
			bufDesc.Width = DepthSizeX;
			bufDesc.Height = DepthSizeY;
			bufDesc.MipLevels = 1;

			bufDesc.SampleDesc.Count = 1;
			bufDesc.SampleDesc.Quality = 0;

			dxDevice->CreateTexture2D(
				&bufDesc,
				nullptr,
				&DebugTextureBuf);

			D3D11_UNORDERED_ACCESS_VIEW_DESC UAVDesc;
			//UAVDesc.Texture2D
			ZeroMemory(&UAVDesc, sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC));

			UAVDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT; //
			UAVDesc.ViewDimension = D3D11_UAV_DIMENSION_TEXTURE2D;

			dxDevice->CreateUnorderedAccessView(DebugTextureBuf, &UAVDesc, &DebugTextureUAV);
			dxDevice->CreateShaderResourceView(DebugTextureBuf, nullptr, &DebugTextureSRV);
		}

		void LightGridBufDefault() {
			if (t_LightGridBuf != NULL) {
				SafeRelease(o_LightGridBuf);
				SafeRelease(t_LightGridBuf);
			}
			DepthSizeX = PL.ScreenWidth();
			DepthSizeY = PL.ScreenHeight();


			D3D11_TEXTURE2D_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(D3D11_TEXTURE2D_DESC));

			bufDesc.ArraySize = 1;
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.Format = DXGI_FORMAT_R32G32_UINT;
			bufDesc.Width = DepthSizeX;
			bufDesc.Height = DepthSizeY;
			bufDesc.MipLevels = 1;
			bufDesc.MiscFlags = 0;
			bufDesc.SampleDesc.Count = 1;
			bufDesc.SampleDesc.Quality = 0;

			dxDevice->CreateTexture2D(
				&bufDesc,
				nullptr,
				&o_LightGridBuf);
			dxDevice->CreateTexture2D(
				&bufDesc,
				nullptr,
				&t_LightGridBuf);

			D3D11_UNORDERED_ACCESS_VIEW_DESC UAVDesc;
			//UAVDesc.Texture2D
			ZeroMemory(&UAVDesc, sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC));

			UAVDesc.Format = DXGI_FORMAT_R32G32_UINT; //
			UAVDesc.ViewDimension = D3D11_UAV_DIMENSION_TEXTURE2D;

			dxDevice->CreateUnorderedAccessView(o_LightGridBuf, &UAVDesc, &o_LightGridUAV);
			dxDevice->CreateUnorderedAccessView(t_LightGridBuf, &UAVDesc, &t_LightGridUAV);


			D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;
			ZeroMemory(&SRVDesc, sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC));
			SRVDesc.Format = DXGI_FORMAT_R32G32_UINT;
			SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
			SRVDesc.Texture2D.MostDetailedMip = 0;
			SRVDesc.Texture2D.MipLevels = 1;

			dxDevice->CreateShaderResourceView(o_LightGridBuf, &SRVDesc, &o_LightGridSRV);

			dxDevice->CreateShaderResourceView(t_LightGridBuf, &SRVDesc, &t_LightGridSRV);
		}

		void LightIndexBufDefault() {
			DepthSizeX = PL.ScreenWidth();
			DepthSizeY = PL.ScreenHeight();
			
			if (o_LightIndexListBuf != NULL) {
				SafeRelease(o_LightIndexListBuf);
				SafeRelease(t_LightIndexListBuf);
			}
			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
			bufDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(UINT) * int(DepthSizeX/BLOCK_SIZE) * int(DepthSizeY/BLOCK_SIZE) * 100; //TODO: add specifier to allow more than 100 lights to affect a position if wanted --- the *100 controls this -- make it a var
			bufDesc.StructureByteStride = sizeof(UINT);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &o_LightIndexListBuf);
			dxDevice->CreateBuffer(&bufDesc, nullptr, &t_LightIndexListBuf);

			D3D11_UNORDERED_ACCESS_VIEW_DESC UAVDesc;
			UAVDesc.Buffer.FirstElement = 0;
			UAVDesc.Buffer.Flags = 0;
			UAVDesc.Buffer.NumElements = int(DepthSizeX / BLOCK_SIZE) * int(DepthSizeY / BLOCK_SIZE) * 100;
			UAVDesc.Format = DXGI_FORMAT_UNKNOWN; //
			UAVDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;

			dxDevice->CreateUnorderedAccessView(o_LightIndexListBuf, &UAVDesc, &o_LightIndexListUAV);
			dxDevice->CreateUnorderedAccessView(t_LightIndexListBuf, &UAVDesc, &t_LightIndexListUAV);

			D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;
			ZeroMemory(&SRVDesc, sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC));

			SRVDesc.Buffer.FirstElement = 0;
			SRVDesc.Buffer.NumElements = 1;
			SRVDesc.Format = DXGI_FORMAT_UNKNOWN;
			SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;

			dxDevice->CreateShaderResourceView(o_LightIndexListBuf, &SRVDesc, &o_LightIndexListSRV);

			dxDevice->CreateShaderResourceView(t_LightIndexListBuf, &SRVDesc, &t_LightIndexListSRV);

		}

		void LightIndexCounterBufDefault() {
			if (o_LightIndexCounterBuf != NULL) {
				SafeRelease(o_LightIndexCounterBuf);
				SafeRelease(t_LightIndexCounterBuf);
			}
			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
			bufDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(UINT);
			bufDesc.StructureByteStride = sizeof(UINT);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &o_LightIndexCounterBuf);
			dxDevice->CreateBuffer(&bufDesc, nullptr, &t_LightIndexCounterBuf);

			D3D11_UNORDERED_ACCESS_VIEW_DESC UAVDesc;
			UAVDesc.Buffer.FirstElement = 0;
			UAVDesc.Buffer.Flags = 0;
			UAVDesc.Buffer.NumElements = 1;
			UAVDesc.Format = DXGI_FORMAT_UNKNOWN; //
			UAVDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;

			dxDevice->CreateUnorderedAccessView(o_LightIndexCounterBuf, &UAVDesc, &o_LightIndexCounterUAV);
			dxDevice->CreateUnorderedAccessView(t_LightIndexCounterBuf, &UAVDesc, &t_LightIndexCounterUAV);
		}

		void DefaultSampler() {
			D3D11_SAMPLER_DESC tmpSampleDesc;

			tmpSampleDesc.AddressU = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_WRAP };
			tmpSampleDesc.AddressV = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_WRAP };
			tmpSampleDesc.AddressW = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_WRAP };
			tmpSampleDesc.MipLODBias = 0;
			tmpSampleDesc.MaxAnisotropy = 8;
			tmpSampleDesc.ComparisonFunc = D3D11_COMPARISON_FUNC{ D3D11_COMPARISON_NEVER }; //never remove model for now - always pass render pass
			tmpSampleDesc.MinLOD = 1;
			tmpSampleDesc.MaxLOD = D3D11_FLOAT32_MAX;
			tmpSampleDesc.Filter = D3D11_FILTER{ D3D11_FILTER_MIN_MAG_MIP_LINEAR };
			tmpSampleDesc.AddressV = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_MIRROR };

			dxDevice->CreateSamplerState(&tmpSampleDesc, &Sampler);
		}

		void LinkDepthStencil() {

			D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;
			SRVDesc.Texture2D.MostDetailedMip = 0;
			SRVDesc.Texture2D.MipLevels = -1;
			SRVDesc.Format = DXGI_FORMAT_R32_FLOAT;
			SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;

			dxDevice->CreateShaderResourceView(dxDepthStencilBuffer, &SRVDesc, &DepthStencilRLink);
		}

		void DefaultSVParams() {
			if (ScreenToViewParamsBuf != NULL) {
				SafeRelease(ScreenToViewParamsBuf);
			}

			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(ScreenToViewParamsStruct);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &ScreenToViewParamsBuf);
		}

		void UpdateSVParamBuf() {
			dxDeviceContext->UpdateSubresource(ScreenToViewParamsBuf, 0, nullptr, &ScreenToViewParams, 0, 0);
		}

		void UpdateMathOfSVParamAndBuf() {
			ScreenToViewParams.SetParams();
			UpdateSVParamBuf();
		}
		void DefaultDispatchParams() {
			if (DispatchParamsBuf != NULL) {
				SafeRelease(DispatchParamsBuf);
			}
			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(ScreenToViewParamsStruct);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &DispatchParamsBuf);
		}

		void UpdateDispatchParamBuf() {
			dxDeviceContext->UpdateSubresource(DispatchParamsBuf, 0, nullptr, &DispatchParams, 0, 0);
		}

		void UpdateDispatchParamAndBuf(std::array<UINT,3> NTG, std::array<UINT, 3> NT) {
			DispatchParams.numThreadGroups[0] = NTG[0];
			DispatchParams.numThreadGroups[1] = NTG[1];
			DispatchParams.numThreadGroups[2] = NTG[2];
			DispatchParams.numThreads[0] = NT[0];
			DispatchParams.numThreads[1] = NT[1];
			DispatchParams.numThreads[2] = NT[2];

			UpdateDispatchParamBuf();
		}

		void DefaultF() {
			if (FDat != NULL) {
				SafeRelease(FDat);
			}
			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
			bufDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(Frustum);
			bufDesc.StructureByteStride = sizeof(Frustum);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &FDat);

			D3D11_UNORDERED_ACCESS_VIEW_DESC UAVDesc;
			UAVDesc.Buffer.FirstElement = 0;
			UAVDesc.Buffer.Flags = 0;
			UAVDesc.Buffer.NumElements = 1;
			UAVDesc.Format = DXGI_FORMAT_UNKNOWN;
			UAVDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;


			dxDevice->CreateUnorderedAccessView(FDat, &UAVDesc, &FOutDat);

			D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;
			SRVDesc.Buffer.FirstElement = 0;
			SRVDesc.Buffer.NumElements = 1;
			SRVDesc.Format = DXGI_FORMAT_UNKNOWN;
			SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;

			dxDevice->CreateShaderResourceView(FDat, &SRVDesc, &FInDat);
			
		}

		void SetupAndRunLightCompute();

		
		void SetupAndRunComputeFrustum();

		void CheckToSetupAndRunComputeFrustum() {
			if (FOVCheck != FOV) {
				SetupAndRunComputeFrustum();
			}
		}

		void Setup() {

#ifdef _DEBUG
			DebugTexBufDefault();
#endif
			LightIndexBufDefault();
			LightGridBufDefault();
			LinkDepthStencil(); //may need to move to logic and check if null srv
			LightIndexCounterBufDefault();
			DefaultSampler();

			DefaultF();
			DefaultSVParams();
			DefaultDispatchParams();
		}

	}FrustumObj; //cannot promise initialize time - so I need a startup func

#ifdef _DEBUG
	ID3D11ShaderResourceView* GetDebugTexture(){
		return FrustumObj.DebugTextureSRV;
	}
#endif

	struct Joint {
		int id; // index/ID of bone
		std::string name;
		const ofbx::Object* Bone;

		std::vector <const ofbx::AnimationCurveNode*> tNode;
		std::vector <const ofbx::AnimationCurveNode*> rNode;
		std::vector <const ofbx::AnimationCurveNode*> sNode;

		XMMATRIX LBT;
		XMMATRIX InvBP = XMMatrixIdentity();
		XMMATRIX BP = XMMatrixIdentity();
		XMMATRIX SkinM = XMMatrixIdentity();

		XMMATRIX BoneOffsetMatrix;

		std::vector<std::shared_ptr<Joint>> children;
		std::shared_ptr<Joint> parent;

		void GetInvBindT(XMMATRIX parentBindT) {

			XMMATRIX BT = parentBindT * LBT;

			BP = BT;
			InvBP = XMMatrixInverse(nullptr, BT);
			SkinM = (BP * InvBP);

			for (int i = 0; i < children.size(); i++) {
				children[i]->GetInvBindT(LBT);
			}
		}



	};

	struct Light {
		//0 is directional - big bottom to small tip is dir
		//1 is point light - its a generic spher to show point
		//2 is spot light - cone bottom half is direction

		//Angles are measured clockwise when looking along the rotation axis toward the origin

		XMFLOAT4 PositionWS = { 0,0,0,0 };
		XMFLOAT4 PositionVS = { 0,0,0,0 };
		XMFLOAT4 DirectionWS = { 1,0,0,0 };  //Direction vector - 
		XMFLOAT4 DirectionVS = { 1,0,0,0 };  //Direction vector - 
		XMFLOAT4 Color = { 1,1,1,1 }; //why is it not 4 bytes you ask?- well its because I'd rather not pad 2 XMfloat2 and bytes
		
		float SpotAngle = 90;
		float Range = 1.0f;
		float Intensity = 1.0f;
		UINT LightType = 0;

		UINT on = true;
		XMFLOAT3 pad;


		void SetDirection(float x = 0, float y = 0, float z = 0) { //radian variant
			float mag = 1;

			DirectionVS.x = mag * cos(aToRad(x));
			DirectionVS.y = mag * cos(aToRad(y));
			DirectionVS.z = mag * cos(aToRad(z));
		}
		void SetDirection(std::array<float, 3> t = { 0, 0, 0 }) { //direction vector variant
			DirectionVS.x = t[0];
			DirectionVS.y = t[1];
			DirectionVS.z = t[2];
		}
		void SetPosition(float x, float y, float z) { //PGE space
			olc::vf2d vInvScreenSize = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
			};

			PositionVS.x = ToNotPGESpace(&vInvScreenSize.x, &x);
			PositionVS.y = ToNotPGESpace(&vInvScreenSize.y, &y);
			PositionVS.z = ToNotPGESpace(&vInvScreenSize.x, &z);


		}
		void SetColor(float r, float g, float b, float a) {
			Color = { r / 255,g / 255,b / 255,a / 255 };
		}
		void SetSpotAngle(float a) {//radians
			SpotAngle = a;
		}
		void SetRange(float a) {
			Range = a;
		}
		void SetIntensity(float a) {
			Intensity = a;
		}
		void SetLightOn(bool t) {
			on = UINT(t);
		}
		void SetLightType(int t) {
			LightType = t;
		}

		std::array<float, 3> GetPosition() {
			olc::vf2d vInvScreenSize = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
			};

			return std::array<float, 3>{
				ToPGESpace(&vInvScreenSize.x, &PositionVS.x),
					ToNotPGESpace(&vInvScreenSize.y, &PositionVS.y),
					ToNotPGESpace(&vInvScreenSize.x, &PositionVS.z)};
		}
		std::array<float, 3> GetDirectionVector() {
			return std::array<float, 3>{DirectionVS.x, DirectionVS.y, DirectionVS.z};
		}
		std::array<float, 3> GetDirectionRadians() {
			float mag = sqrt(pow(DirectionVS.y, 2) + pow(DirectionVS.x, 2) + pow(DirectionVS.z, 2));

			std::array <float, 3> angle = { acos(DirectionVS.x / mag),acos(DirectionVS.y / mag),acos(DirectionVS.z / mag) };
			angle[0] *= -1;
			angle[1] *= -1;
			angle[2] *= -1;

			return angle;
		}
		std::array<float, 4> GetColor() {
			return std::array<float, 4>{ Color.x * 255, Color.y * 255, Color.z * 255, Color.w * 255};
		}
		int GetLightType() {
			return LightType;
		}
		float GetLightRange() {
			return Range;
		}
		float GetLightIntensity() {
			return Intensity;
		}

		bool GetLightOn() {
			return bool(on);
		}

	};

	struct UniversalLightProperties {

		std::vector<Light> Lights;

		void* data() {
			return Lights.data();
		}

		UniversalLightProperties() {
			Lights.resize(8);
			Lights.shrink_to_fit();
		}
		void SetMaxLights(int Num);
	};

	struct LightDataCont {
		ID3D11Buffer* ULPBuffer;
		ID3D11Buffer* GlobalAmbientBuffer;
		ID3D11Buffer* EyePositionBuffer;

		bool ToUpdateULP = false;
		bool ToUpdateGA = false;
		bool ToUpdateEP = false;

		UniversalLightProperties ULP;
		XMFLOAT4 GlobalAmbient = { 1.0f,1.0f,1.0f,1.0f };
		XMFLOAT4 EyePosition = { 0,0,0,0 };

		void DefaultULP() {
			if (ULPBuffer != nullptr) {
				SafeRelease(ULPBuffer);
			}

			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(Light) * ULPC.ULP.Lights.size();

			dxDevice->CreateBuffer(&bufDesc, nullptr, &ULPBuffer);

			dxDeviceContext->UpdateSubresource(ULPBuffer, 0, nullptr, ULP.data(), 0, 0);
		}
		void DefaultGA() {
			if (GlobalAmbientBuffer != nullptr) {
				SafeRelease(GlobalAmbientBuffer);
			}

			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(XMFLOAT4);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &GlobalAmbientBuffer);

			dxDeviceContext->UpdateSubresource(GlobalAmbientBuffer, 0, nullptr, &GlobalAmbient, 0, 0);
		}
		void DefaultEP() {
			if (EyePositionBuffer != nullptr) {
				SafeRelease(EyePositionBuffer);
			}

			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(XMFLOAT4);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &EyePositionBuffer);

			dxDeviceContext->UpdateSubresource(EyePositionBuffer, 0, nullptr, &EyePosition, 0, 0);
		}

		void UpdateULP() {
			dxDeviceContext->UpdateSubresource(ULPBuffer, 0, nullptr, ULP.data(), 0, 0);
		}
		void UpdateGA() {
			dxDeviceContext->UpdateSubresource(GlobalAmbientBuffer, 0, nullptr, &GlobalAmbient, 0, 0);
		}
		void UpdateEP() {
			dxDeviceContext->UpdateSubresource(EyePositionBuffer, 0, nullptr, &EyePosition, 0, 0);
		}

		void CheckToUpdateULP() {
			if (ToUpdateULP) {
				UpdateULP();
				ToUpdateULP = false;
			}
		}
		void CheckToUpdateGA() {
			if (ToUpdateGA) {
				UpdateGA();
				ToUpdateGA = false;
			}
		}
		void CheckToUpdateEP() {
			XMFLOAT3 tmpCam;

			XMStoreFloat3(&tmpCam, camPosition); //camTarget

			if (tmpCam.x != EyePosition.x || tmpCam.y != EyePosition.y || tmpCam.z != EyePosition.z || ToUpdateEP) {
				EyePosition.x = tmpCam.x;
				EyePosition.y = tmpCam.y;
				EyePosition.z = tmpCam.z;

				UpdateEP();

				ToUpdateEP = false;
			}
		}

		LightDataCont() {

		}

		void SetLightToPixelShaderSlotTen() {
			dxDeviceContext->PSSetConstantBuffers(10, 1, &ULPC.ULPBuffer);
			dxDeviceContext->PSSetConstantBuffers(11, 1, &ULPC.GlobalAmbientBuffer);
			dxDeviceContext->PSSetConstantBuffers(12, 1, &ULPC.EyePositionBuffer);
		}

	}ULPC;

	void SetGlobalAmbient(std::array<float,4> A) {
		ULPC.ToUpdateGA = true;
		ULPC.GlobalAmbient = {A[0],A[1],A[2],A[3]};
	}

	//TODO: global ambient color

	struct MaterialData { //seperate struct to send to resource

		/*
		
			&MatData.HasAmbientTexture 0
			&MatData.HasEmissiveTexture, 1
			&MatData.HasDiffuseTexture, 2
			&MatData.HasSpecularTexture, 3
			&MatData.HasSpecularPowerTexture, 4
			&MatData.HasNormalTexture, 5
			&MatData.HasBumpTexture, 6
			&MatData.HasOpacityTexture, 7

		
		*/

		XMFLOAT4 Emissive = { 0,0,0,1 };
		XMFLOAT4 BaseColor = { 1,1,1,1 }; //uses if no texture - emulates a texture of 1 color only
		XMFLOAT4 Ambient = { 1,1,1,1 };
		XMFLOAT4 Diffuse = { 0.1,0.1,0.1,1 };
		XMFLOAT4 Specular = { 0.1,0.1,0.1,1 };
		XMFLOAT4 Reflectance = { 1.0f,1.0f,1.0f,1.0f };

		float Opacity = 1.0f;
		float SpecularStr = { 128 };
		float IndexOfRefraction = 0;
		INT32 TexOn[8] = { 0,0,0,0,0,0,0,0 };
		float BumpIntensity = 0.0f;

		float SpecularScale = 1.0f;
		float AlphaThreshold = 0.0f;
		UINT Lit = false;
		float pad;
	};
	struct Material {
		UINT UpdateMat = false;

		/*
		ID3D11ShaderResourceView* TexSRVAmbient = NULL;//TypeOfTexture = 0
		ID3D11Texture2D* TexRAmbient = NULL;

		ID3D11ShaderResourceView* TexSRVEmissive = NULL;//TypeOfTexture = 1
		ID3D11Texture2D* TexREmissive = NULL;

		ID3D11ShaderResourceView* TexSRVDiffuse = NULL;//TypeOfTexture = 2
		ID3D11Texture2D* TexRDiffuse = NULL;

		ID3D11ShaderResourceView* TexSRVSpecular = NULL;//TypeOfTexture = 3
		ID3D11Texture2D* TexRSpecular = NULL;

		ID3D11ShaderResourceView* TexSRVSpecularPower = NULL;//TypeOfTexture = 4
		ID3D11Texture2D* TexRSpecularPower = NULL;

		ID3D11ShaderResourceView* TexSRVNormal = NULL;//TypeOfTexture = 5
		ID3D11Texture2D* TexRNormal = NULL;

		ID3D11ShaderResourceView* TexSRVBump = NULL;//TypeOfTexture = 6
		ID3D11Texture2D* TexRBump = NULL;

		ID3D11ShaderResourceView* TexSRVOpacity = NULL;//TypeOfTexture = 7
		ID3D11Texture2D* TexROpacity = NULL;
		*/
		ID3D11ShaderResourceView* TexSRV[8] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL, };

		ID3D11Texture2D* TexR[8] = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,};

		
		MaterialData MatData;


		ID3D11Buffer* MatDataBuf;

		Material() {
			//TexOn[0] = &MatData.HasAmbientTexture;
			//TexOn[1] = &MatData.HasEmissiveTexture;
			//TexOn[2] = &MatData.HasDiffuseTexture;
			//TexOn[3] = &MatData.HasSpecularTexture;
			//TexOn[4] = &MatData.HasSpecularPowerTexture;
			//TexOn[5] = &MatData.HasNormalTexture; //normal
			//TexOn[6] = &MatData.HasBumpTexture;
			//TexOn[7] = &MatData.HasOpacityTexture;
		}
	};



	struct M3DR { //3d model with all data - TODO: I need seperate obj loader later with the code I commented and made a bit back?
		int FaceDrawType = 1;

		int GetFaceDrawType() {
			return FaceDrawType; // (0 is all face, 1 is back face, 2 is front face)
		}
		void SetFaceDrawType(int i) {
			std::max(i, 2);

			FaceDrawType = i;
		}
		void CheckToSetFaceRasterizer() {
			if (CurrentFaceDrawType != FaceDrawType) {
				Set3dFaceRasterArray[FaceDrawType]();
			}
		}



		bool IsDebugLight = false;
		int DebugLightID = -1;
		int DebugLightVType = -1;

		int DepthBitKeep = 0; //don't want this yet
		void CheckToSetDepthRasterizer() {
			if (CurrentDepthDrawType != DepthBitKeep) {
				Set3dDepthArray[CurrentDepthDrawType]();
			}
		}

		//FOR ANIMATION export in blender have deform and no leaf bones

		//Material Stuff
		std::vector<Material> Mat = {};

		ID3D11SamplerState* Sampler = NULL;

		ID3D11BlendState* BlendState = NULL;

		//set to a greater than number mat to set all to this val - 0 based indexed materials - so 1 with size 0 still sets all

		//0-1 scale)
		void SetEmissive(int MatToChange, std::array<float, 4> e) {
			e[0] /= 255;
			e[1] /= 255;
			e[2] /= 255;
			e[3] /= 255;

			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.Emissive = { e[0],e[1],e[2],e[3] };
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.Emissive = { e[0],e[1],e[2],e[3] };
			}
		}
		std::array<float, 4> GetEmissive(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return std::array<float, 4>{-9999, -9999, -9999};
			else return std::array<float, 4>{Mat[MatToReturn].MatData.Emissive.x * 255, Mat[MatToReturn].MatData.Emissive.y * 255, Mat[MatToReturn].MatData.Emissive.z * 255, Mat[MatToReturn].MatData.Emissive.w * 255};
		}

		void SetBaseColor(int MatToChange, std::array<float, 4> e) {
			e[0] /= 255;
			e[1] /= 255;
			e[2] /= 255;
			e[3] /= 255;

			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.BaseColor = { e[0],e[1],e[2],e[3] };
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.BaseColor = { e[0],e[1],e[2],e[3] };
			}
		}
		std::array<float, 4> GetBaseColor(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return std::array<float, 4>{-9999, -9999, -9999};
			else return std::array<float, 4>{Mat[MatToReturn].MatData.BaseColor.x * 255, Mat[MatToReturn].MatData.BaseColor.y * 255, Mat[MatToReturn].MatData.BaseColor.z * 255, Mat[MatToReturn].MatData.BaseColor.w * 255};
		}

		void SetAmbient(int MatToChange, std::array<float, 4> e) {
			e[0] /= 255;
			e[1] /= 255;
			e[2] /= 255;
			e[3] /= 255;

			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.Ambient = { e[0],e[1],e[2],e[3] };
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.Ambient = { e[0],e[1],e[2],e[3] };
			}
		}
		std::array<float, 4> GetAmbient(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return std::array<float, 4>{-9999, -9999, -9999};
			else return std::array<float, 4>{Mat[MatToReturn].MatData.Ambient.x * 255, Mat[MatToReturn].MatData.Ambient.y * 255, Mat[MatToReturn].MatData.Ambient.z * 255, Mat[MatToReturn].MatData.Ambient.w * 255};
		}
		void SetDiffuse(int MatToChange, std::array<float, 4> e) {
			e[0] /= 255;
			e[1] /= 255;
			e[2] /= 255;
			e[3] /= 255;

			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.Diffuse = { e[0],e[1],e[2],e[3] };
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.Diffuse = { e[0],e[1],e[2],e[3] };
			}
		}
		std::array<float, 4> GetDiffuse(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return std::array<float, 4>{-9999, -9999, -9999};
			else return std::array<float, 4>{Mat[MatToReturn].MatData.Diffuse.x * 255, Mat[MatToReturn].MatData.Diffuse.y * 255, Mat[MatToReturn].MatData.Diffuse.z * 255, Mat[MatToReturn].MatData.Diffuse.w * 255};
		}

		void SetSpecular(int MatToChange, std::array<float, 4> e) { //set a greater than max number to set all to this value
			e[0] /= 255;
			e[1] /= 255;
			e[2] /= 255;
			e[3] /= 255;

			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.Specular = { e[0],e[1],e[2],e[3] };
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.Specular = { e[0],e[1],e[2],e[3] };
			}
		}
		std::array<float, 4> GetSpecular(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return std::array<float, 4>{-9999, -9999, -9999};
			else return std::array<float, 4>{Mat[MatToReturn].MatData.Specular.x * 255, Mat[MatToReturn].MatData.Specular.y * 255, Mat[MatToReturn].MatData.Specular.z * 255, Mat[MatToReturn].MatData.Specular.w * 255};
		}

		void SetReflectance(int MatToChange, std::array<float, 4> e) { //set a greater than max number to set all to this value
			e[0] /= 255;
			e[1] /= 255;
			e[2] /= 255;
			e[3] /= 255;

			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.Reflectance = { e[0],e[1],e[2],e[3] };
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.Reflectance = { e[0],e[1],e[2],e[3] };
			}
		}
		std::array<float, 4> GetReflectance(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return std::array<float, 4>{-9999, -9999, -9999};
			else return std::array<float, 4>{Mat[MatToReturn].MatData.Reflectance.x * 255, Mat[MatToReturn].MatData.Reflectance.y * 255, Mat[MatToReturn].MatData.Reflectance.z * 255, Mat[MatToReturn].MatData.Reflectance.w * 255};
		}

		void SetOpacity(int MatToChange, float e) { //set a greater than max number to set all to this value
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.Opacity = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.Opacity = e;
			}
		}
		float GetOpacity(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.Opacity;
		}

		void SetSpecularStr(int MatToChange, float e) { //set a greater than max number to set all to this value
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.SpecularStr = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.SpecularStr = e;
			}
		}
		float GetSpecularStr(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.SpecularStr;
		}

		void SetIndexOfRefraction(int MatToChange, float e) { //set a greater than max number to set all to this value
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.IndexOfRefraction = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.IndexOfRefraction = e;
			}
		}
		float GetIndexOfRefraction(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.IndexOfRefraction;
		}

		void SetUseAmbientTexture(int MatToChange, bool e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[0] = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[0] = e;
			}
		}
		bool GetUseAmbientTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.TexOn[0];
		}

		void SetUseEmissiveTexture(int MatToChange, bool e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[1] = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[1] = e;
			}
		}
		bool GetUseEmissiveTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.TexOn[1];
		}
		void SetUseDiffuseTexture(int MatToChange, bool e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[2] = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[2] = e;
			}
		}
		bool GetUseDiffuseTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.TexOn[2];
		}
		void SetUseSpecularTexture(int MatToChange, bool e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[3] = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[3] = e;
			}
		}
		bool GetUseSpecularTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.TexOn[3];
		}
		void SetUseSpecularPowerTexture(int MatToChange, bool e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[4] = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[4] = e;
			}
		}
		bool GetUseSpecularPowerTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.TexOn[4];
		}
		void SetUseNormalTexture(int MatToChange, bool e) {

			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[6] = !e;
					Mat[i].MatData.TexOn[5] = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[6] = !e;
				Mat[MatToChange].MatData.TexOn[5] = e;
			}
		}
		bool GetUseNormalTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return !Mat[MatToReturn].MatData.TexOn[5];
		}

		void SetUseBumpTexture(int MatToChange, bool e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[6] = e;
					Mat[i].MatData.TexOn[5] = !e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[6] = e;
				Mat[MatToChange].MatData.TexOn[5] = !e;
			}
		}
		bool GetUseBumpTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.TexOn[6];
		}

		void SetUseOpacityTexture(int MatToChange, bool e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.TexOn[7] = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.TexOn[7] = e;
			}
		}
		bool GetUseOpacityTexture(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.TexOn[7];
		}

		void SetBumpIntensity(int MatToChange, float e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.BumpIntensity = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.BumpIntensity = e;
			}
		}
		float GetBumpIntensity(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.BumpIntensity;
		}

		void SetSpecularScale(int MatToChange, float e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.SpecularScale = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.SpecularScale = e;
			}
		}
		float GetSpecularScale(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.SpecularScale;
		}

		void SetAlphaThreshold(int MatToChange, float e) {
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.AlphaThreshold = e;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.AlphaThreshold = e;
			}
		}
		float GetAlphaThreshold(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.AlphaThreshold;
		}

		void LitToggle(int MatToChange, bool On) { //On = true means light is used for material
			if (MatToChange >= Mat.size()) {
				for (int i = 0; i < Mat.size(); i++) {
					Mat[i].UpdateMat = true;
					Mat[i].MatData.Lit = On;
				}
			}
			else {
				Mat[MatToChange].UpdateMat = true;
				Mat[MatToChange].MatData.Lit = On;
			}
		}
		bool GetLitToggle(int MatToReturn) {
			if (MatToReturn >= Mat.size()) return 0;
			else return Mat[MatToReturn].MatData.Lit;
		}

		void MatToLightDefault(int i) {
			Mat[i].MatData.Emissive = { 0,0,0,1 };
			Mat[i].MatData.BaseColor = { 1,1,1,1 };
			Mat[i].MatData.Ambient = { 0.1,0.1,0.1,1 };
			Mat[i].MatData.Diffuse = { 1,1,1,1 };
			Mat[i].MatData.Specular = { 1,1,1,1 };

			Mat[i].MatData.SpecularStr = { 128 };
			Mat[i].MatData.Lit = false;
		}

		void ChangeAllMatToLight() {
			for (int i = 0; i < Mat.size(); i++) {
				MatToLightDefault(i);
			}
		}

		void DefaultMatBuf(int i) {
			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(MaterialData);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &Mat[i].MatDataBuf);

			dxDeviceContext->UpdateSubresource(Mat[i].MatDataBuf, 0, nullptr, &Mat[i].MatData, 0, 0);
		}
		void DefaultAllMatBuf() {
			for (int i = 0; i < Mat.size(); i++) {
				DefaultMatBuf(i);
			}
		}
		void UpdateMaterialData(int i) { //index of material to update
			dxDeviceContext->UpdateSubresource(Mat[i].MatDataBuf, 0, nullptr, &Mat[i].MatData, 0, 0);
		}

		void CheckToUpdateMat(int i) {
			if (Mat[i].UpdateMat) {
				UpdateMaterialData(i);
				Mat[i].UpdateMat = false;
			}
		}
		void CheckToUpdateMatAll() {
			for (int i = 0; i < Mat.size(); i++) {
				CheckToUpdateMat(i);
			}
		}


		//FBX dat Stuff
		std::vector<Joint> Bones;
		const ofbx::Object* rootObj;

		XMMATRIX globalInverseTransform;
		XMMATRIX globalTransform;

		std::vector<XMFLOAT4X4> BoneDataTLMA; //adjusted values from animation

		bool ToUpdateCBoneBuf;

		//TODO: make this a bitmap
		std::map<std::string, int> animNameS; //contains anim position in stack
		std::map<int, std::string> animNameI; //contains anim position in stack reverse

		std::vector< const ofbx::AnimationStack* > animStack;
		std::vector< float > animStackMaxTime;
		std::vector< bool > AnimVCacheMade; //VCache is more so a Bone Cache*
		std::vector< std::vector< std::vector<XMFLOAT4X4> > > AnimVCacheData; //per anim, per interval - I have a set of bones

		std::vector<XMMATRIX> animDat; //animation collection

		std::vector<const ofbx::Cluster*> ClusterObject;

		std::vector < std::vector<VertexBoneData> > VboneDat; //TODO: filter to same indices instead of including duplicate verticies part

		ObjTuneStatReg ObjTune;

		ID3D11Buffer* CBuf;

		ID3D11Buffer* ArmatureCBuf;

		std::vector < std::vector<VNT> > modelDat;

		std::vector<XMFLOAT3> ExtractV(int Obj) {
			std::vector<XMFLOAT3> V;

			if (Obj >= modelDat.size()) return V;

			V.resize(modelDat[Obj].size());

			for (int i = 0; i < modelDat[Obj].size(); i++) {
				V[i] = modelDat[Obj][i].Position;
			}


			return V;
		}

		std::vector < std::vector<UINT> > Indice;

		std::vector < ID3D11Buffer* > VBuf;
		std::vector < ID3D11UnorderedAccessView* > VBufUAV;

		std::vector < ID3D11Buffer* > IBuf;
		//

		XMMATRIX GetTMatrix() {
			XMVECTOR O = { 0,0,0 };
			XMVECTOR S = { ObjTune.Scale[0],ObjTune.Scale[1],ObjTune.Scale[2] };
			XMVECTOR quat = XMLoadFloat4(&ObjTune.Quat);
			XMVECTOR T = { ObjTune.Translate[0],ObjTune.Translate[1],ObjTune.Translate[2] };

			return XMMatrixTransformation(O, O, S, O, quat, T);
		}
		XMMATRIX GetTInvM(XMMATRIX tm) {
			return XMMatrixTranspose(XMMatrixInverse(nullptr, tm));
		}
		XMMATRIX GetTInvMObject() {
			return GetTInvM(GetTMatrix());
		}

		bool MakeAnimVCache(int TotalIntervals, int AnimNum) {
			if (AnimNum >= animStack.size()) { return false; }

			else {
				std::vector<XMFLOAT4X4> currBoneDat = BoneDataTLMA;
				AnimVCacheMade[AnimNum] = true;

				float interval = animStackMaxTime[AnimNum] / TotalIntervals;
				int numPass = 0;
				float CurrI = 0.0f;
				AnimVCacheData[AnimNum].resize(TotalIntervals);
				for (int i = 0; i < AnimVCacheData[AnimNum].size(); i++) {
					AnimVCacheData[AnimNum][i].resize(Bones.size());
				}
				while (numPass < TotalIntervals) {

					for (int i = 0; i < Bones.size(); i++) {
						animDat[i] = GetBoneLocalOfAnim(CurrI, i, AnimNum);

					}

					ApplyLocalOfAnim(XMMatrixIdentity(), 0);

					for (int x = 0; x < BoneDataTLMA.size(); x++) {
						AnimVCacheData[AnimNum][numPass][x] = BoneDataTLMA[x];
					}

					CurrI += interval;
					numPass += 1;
				}

				BoneDataTLMA = currBoneDat; //reset bone dat to what it was before incase - stop funky behavior

			}
		}

		float EndTimeOfAnim(int Anim) {
			if (Anim >= animStackMaxTime.size()) { return 0; }
			return animStackMaxTime[Anim];
		}

		void AddBoneChildren(Joint* BoneP) {
			for (int i = 0; i < Bones.size(); i++) {

				if (Bones[i].Bone->getParent() == BoneP->Bone) {
					BoneP->children.push_back(std::make_shared<Joint>(Bones[i]));
				}

			}
		}

		void SetAllBonesChildren() {

			for (int i = 0; i < Bones.size(); i++) {
				AddBoneChildren(&Bones[i]);
			}

		}
		void SetAllBonesParent() {

			for (int i = 0; i < Bones.size(); i++) {
				for (int ii = 0; ii < Bones.size(); ii++) {
					if (Bones[i].Bone->getParent() == Bones[ii].Bone) {
						Bones[i].parent = std::make_shared<Joint>(Bones[ii]);
					}
				}
			}

		}
		void SetAllBonesGetInvBindT() {
			if (Bones.size() > 0) {
				Bones[0].GetInvBindT(XMMatrixIdentity());
			}
		}


		void ReCalcBonesAhead(std::array<float, 3> t, std::array<float, 3> r, std::array<float, 3> s, int BoneParent) {

			ReCalcBonesAheadLogic(t, r, s, BoneParent);

			//Bones[0].GetAnimInvBindT(Bones[0].AnimLBT); //calc

			//BindAnimPoseBones();

		}

		void ReCalcBonesAheadLogic(std::array<float, 3> t, std::array<float, 3> r, std::array<float, 3> s, int BoneParent) { //TODO: fix this bone calculator as a whole and anims

			SetBoneDataWithCurrent(t, r, s, BoneParent); //set


			for (int i = 0; i < Bones[BoneParent].children.size(); i++) {

				ReCalcBonesAheadLogic(t, r, s, Bones[BoneParent].children[i]->id);

			}


		}

		void MSRRootBone(std::array<float, 3> t = { 0.0f,0.0f,0.0f }, std::array<float, 3> s = { 1.0f,1.0f,1.0f }, std::array<float, 3> r = { 0.0f,0.0f,0.0f }) {

			MSRBone(0, t, s, r);

		}

		void MSRBone(int Bone, std::array<float, 3> XYZTranslate = { 0.0f,0.0f,0.0f }, std::array<float, 3> scale = { 1.0f,1.0f,1.0f }, std::array<float, 3> r = { 0.0f,0.0f,0.0f }) {
			if (Bone < Bones.size()) {

				ToUpdateCBoneBuf = true;


				olc::vf2d vInvScreenSize = {
			(1.0f / float(PL.ScreenWidth())),
			(1.0f / float(PL.ScreenHeight()))
				};

				std::array<float, 3> boneT = std::array<float, 3>{ToNotPGESpace(&vInvScreenSize.x, &XYZTranslate[0]), ToNotPGESpace(&vInvScreenSize.y, &XYZTranslate[1]), ToNotPGESpace(&vInvScreenSize.x, &XYZTranslate[2]) };

				r[0] = r[0] * 180 / MyPi;
				r[1] = r[1] * 180 / MyPi;
				r[2] = r[2] * 180 / MyPi;

				ReCalcBonesAhead(boneT, r, scale, Bone);
			}

		}

		int GetAnimationNum(std::string name) {
			return animNameS[name];
		}
		std::string GetAnimationStr(int num) {
			animNameI[num];
		}
		std::vector<std::pair<std::string, int>> GetAllAnims() {
			std::vector<std::pair<std::string, int>> tmp;
			for (const auto& i : animNameS) {
				tmp.push_back(i);
			}
			return tmp;
		}

		void SetBoneDataWithCurrent(std::array<float, 3> t, std::array<float, 3> r, std::array<float, 3> s, int Bone) {

			ofbx::Vec3 tv = { t[0],t[1],t[2] };
			ofbx::Vec3 rv = { r[0],r[1],r[2] };
			ofbx::Vec3 sv = { s[0],s[1],s[2] };

			ofbx::Matrix sm = ofbx::makeIdentity();
			sm.m[0] = sv.x;
			sm.m[5] = sv.y;
			sm.m[10] = sv.z;

			ofbx::Matrix finalM = ofbx::getRotationMatrix(rv, ofbx::RotationOrder::EULER_XYZ) * sm;
			setTranslation(tv, &finalM);

			//ofbx::Matrix finalM = Bones[Bone].Bone->evalLocal({ t[0],t[1],t[2] }, {r[0], r[1],r[2]}, { s[0],s[1],s[2] });

			XMFLOAT4X4 tmp = ofbxMatToXM(&finalM);

			XMMATRIX tmp1 = XMLoadFloat4x4(&tmp);

			XMMATRIX tmp2 = XMLoadFloat4x4(&BoneDataTLMA[Bone]);

			XMStoreFloat4x4(&BoneDataTLMA[Bone], (tmp2 * tmp1));


			//tmp2 += tmp1*tmp2;

			//XMStoreFloat4x4(&BoneDataTLMA[Bone], tmp2);
		}

		void ResizeAllBonesNodeArr() {
			for (int i = 0; i < Bones.size(); i++) {
				Bones[i].tNode.resize(animStack.size());
				Bones[i].rNode.resize(animStack.size());
				Bones[i].sNode.resize(animStack.size());
			}
		}

		void GetAllBoneNodes() {
			for (int i = 0; i < Bones.size(); i++) {
				GetAllLTRSNodeForEveryAnim(i);
			}
		}

		void GetAllLTRSNodeForEveryAnim(int Bone) {
			for (int i = 0; i < animStack.size(); i++) {
				GetLTRSNode(Bone, i);
			}
		}

		void GetLTRSNode(int Bone, int Anim) {
			Bones[Bone].tNode[Anim] = GetNodeCurve(Anim, "Lcl Translation", Bones[Bone].Bone);
			Bones[Bone].rNode[Anim] = GetNodeCurve(Anim, "Lcl Rotation", Bones[Bone].Bone);
			Bones[Bone].sNode[Anim] = GetNodeCurve(Anim, "Lcl Scaling", Bones[Bone].Bone);
		}

		std::array<ofbx::Vec3, 3> GetLocalAnimData(double time, int Bone, int Anim) {
			ofbx::Vec3 t = { 0,0,0 };
			ofbx::Vec3 r = { 0,0,0 };
			ofbx::Vec3 s = { 1,1,1 };



			if (Bones[Bone].tNode[Anim] != nullptr) {
				t = GetDataFromAnimation(time, Bones[Bone].tNode[Anim]);
			}
			if (Bones[Bone].rNode[Anim] != nullptr) {
				r = GetDataFromAnimation(time, Bones[Bone].rNode[Anim]);
			}
			if (Bones[Bone].sNode[Anim] != nullptr) {
				s = GetDataFromAnimation(time, Bones[Bone].sNode[Anim]);
			}

			return std::array<ofbx::Vec3, 3>{t, r, s};

		}

		ofbx::Matrix GetLocalAnimDataMat(double time, int Bone, int Anim) {

			std::array<ofbx::Vec3, 3> tmp = GetLocalAnimData(time, Bone, Anim);

			ofbx::Matrix finalM = Bones[Bone].Bone->evalLocal(tmp[0], tmp[1], tmp[2]);

			return finalM;
		}
		ofbx::Matrix GetGlobalAnimData(double time, int BonePosRoot, int Anim) {

			ofbx::Matrix tmp = GetLocalAnimDataMat(time, BonePosRoot, Anim);

			if (Bones[BonePosRoot].Bone->getParent()) {
				ofbx::Matrix tmp2 = GetGlobalAnimData(time, Bones[BonePosRoot].parent->id, Anim);
				tmp = tmp * tmp2; //OR do I get parent of parent global matrix?
			}


			return tmp;
		}

		const ofbx::AnimationCurveNode* GetNodeCurve(int Anim, std::string valueType, const ofbx::Object* Bone) {


			for (int ii = 0; animStack[Anim]->getLayer(ii); ++ii)
			{

				const ofbx::AnimationLayer* layer = animStack[Anim]->getLayer(ii);

				if (layer->getCurveNode(*Bone, valueType.c_str())) {
					return layer->getCurveNode(*Bone, valueType.c_str());

				}
				else {
					return nullptr;
				}
			}
		}
		std::array<std::array<float, 3>, 3> Vec33ToArrF3(std::array<ofbx::Vec3, 3> t) {
			return std::array<std::array<float, 3>, 3> { std::array<float, 3>{float(t[0].x), float(t[0].y), float(t[0].z)}, std::array<float, 3>{float(t[1].x), float(t[1].y), float(t[1].z)}, std::array<float, 3>{float(t[2].x), float(t[2].y), float(t[2].z)}};
		}
		std::array < std::array<float, 3>, 3> GetLocalAnimDataA(double time, int Bone, int Anim) {
			return Vec33ToArrF3(GetLocalAnimData(time, Bone, Anim));
		}


		void ApplyLocalOfAnim(XMMATRIX Parent, int Bone) {
			XMMATRIX currTrans = animDat[Bone] * Parent;


			for (int i = 0; i < Bones[Bone].children.size(); i++) {
				ApplyLocalOfAnim(currTrans, Bones[Bone].children[i]->id);
			}

			XMStoreFloat4x4(&BoneDataTLMA[Bone], ((Bones[Bone].BoneOffsetMatrix) * (currTrans)));

		}

		XMMATRIX GetBoneLocalOfAnim(double time, int BonePos, int Anim) {

			ofbx::Matrix finalM = GetLocalAnimDataMat(time, BonePos, Anim);
			XMFLOAT4X4 tmp = ofbxMatToXM(&finalM);
			XMMATRIX tmpM = XMLoadFloat4x4(&tmp);//* Bones[BonePos].BoneOffsetMatrix;
			return tmpM;

		}
		int MaxLayer() {
			return animStack.size();
		}

		void ApplyAnimVCache(double time, int AnimNum) {
			float Interval = animStackMaxTime[AnimNum] / AnimVCacheData[AnimNum].size();

			int CurrInterval = std::floor(time / Interval);

			for (int x = 0; x < BoneDataTLMA.size(); x++) {
				BoneDataTLMA[x] = AnimVCacheData[AnimNum][CurrInterval][x];
			}
		}

		int SetAllBoneToAnim(double time, int num, bool UseVCache) {
			if (num >= animStack.size()) {
				return 0;
			}

			ToUpdateCBoneBuf = true;

			if (UseVCache == true && AnimVCacheMade[num] == true) {
				ApplyAnimVCache(time, num);
			}
			else {

				for (int i = 0; i < Bones.size(); i++) {
					animDat[i] = GetBoneLocalOfAnim(time, i, num);
				}

				ApplyLocalOfAnim(XMMatrixIdentity(), 0);
			}
			return 1;
		}
		int SetAllBoneToAnim(double time, std::string name, bool UseVCache) {
			if (animNameS.count(name) == 0) { return 0; }

			SetAllBoneToAnim(time, animNameS[name], UseVCache);

			return 1;
		}

		int SetBoneToBindPose() {
			if (Bones.size() > 0) {
				return 0;
			}
			else {
				BindPoseBones();
				return 1;
			}
		}

		void FillTopBones() { //indice copies bone if same
			//if I need to do vertex all I have a setup from old git history

			for (int B = 0; B < Indice.size(); B++) {

				std::map<int, int> sDubC; //shuffle doubles calc - shuffle through numbered index to reduce sort

				for (int i = 0; i < Indice[B].size(); i++) {
					if (sDubC.count(Indice[B][i]) == 0) {
						sDubC[Indice[B][i]] = i;



						if (VboneDat[B][Indice[B][i]].weights.size() < 4) {
							VboneDat[B][Indice[B][i]].weights.resize(4); VboneDat[B][Indice[B][i]].IDs.resize(4);
							for (int xx = 0; xx < VboneDat[B][Indice[B][i]].weights.size(); xx++) {
								if (VboneDat[B][Indice[B][i]].weights[xx] == 0) {
									VboneDat[B][Indice[B][i]].weights[xx] = 0.0f;
									VboneDat[B][Indice[B][i]].IDs[xx] = 0;
								}
							}
						}

						float tmpWH = 0.0f;
						int tmpIDH = 0;

						for (int ii = 0; ii < VboneDat[B][Indice[B][i]].weights.size(); ii++) {
							for (int iii = VboneDat[B][Indice[B][i]].weights.size() - 1; iii > ii; iii--) {

								if (VboneDat[B][Indice[B][i]].weights[iii] > VboneDat[B][Indice[B][i]].weights[ii]) {
									tmpWH = VboneDat[B][Indice[B][i]].weights[ii];
									VboneDat[B][Indice[B][i]].weights[ii] = VboneDat[B][Indice[B][i]].weights[iii];
									VboneDat[B][Indice[B][i]].weights[iii] = tmpWH;

									tmpIDH = VboneDat[B][Indice[B][i]].IDs[ii];
									VboneDat[B][Indice[B][i]].IDs[ii] = VboneDat[B][Indice[B][i]].IDs[iii];
									VboneDat[B][Indice[B][i]].IDs[iii] = tmpIDH;

									ii = 0;
									iii = VboneDat[B][Indice[B][i]].weights.size() - 1;
								}
							}
						}
						for (int y = 0; y < 4; y++) {
							modelDat[B][Indice[B][i]].tbw.w[y] = VboneDat[B][Indice[B][i]].weights[y];

							modelDat[B][Indice[B][i]].tbi.id[y] = VboneDat[B][Indice[B][i]].IDs[y];
						}
					}

					//}


				}

				//TO FIX ANIMATION TEST IF MAX IS BROKEN OR NOT NEEDED - NORMALIZATION MAY BREAK MODEL ANIM'S?
				for (const std::pair<int, int>& kv : sDubC) {

					float max = 0.0f;

					for (int ii = 0; ii < 4; ii++) {
						max += modelDat[B][kv.first].tbw.w[ii];
					}

					if (max > 0) { //to stop error of 1
						for (int ii = 0; ii < 4; ii++) {
							modelDat[B][kv.first].tbw.w[ii] = modelDat[B][kv.first].tbw.w[ii] / max;
						}
					}



				}
			}
		}

		void CreateArmatureCBuf() {


			if (BoneDataTLMA.size() == 0) {
				XMFLOAT4X4 tmpForFill = { 1.0f,0.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f ,1.0f };

				BoneDataTLMA.push_back(tmpForFill);
			}
			/*
			if (BoneDataTLM.size() == 0) {
				XMFLOAT4X4 tmpForFill = { 0.0f,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f };

				BoneDataTLM.push_back(tmpForFill);
			}
			if (BoneDataTM.size() == 0) {
				XMFLOAT4X4 tmpForFill = { 0.0f,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f };

				BoneDataTM.push_back(tmpForFill);
			}*/

			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(XMFLOAT4X4) * BoneDataTLMA.size(); //for now max 64 bones

			dxDevice->CreateBuffer(&bufDesc, nullptr, &ArmatureCBuf);

			if (BoneDataTLMA.size() != 0) {
				dxDeviceContext->UpdateSubresource(ArmatureCBuf, 0, nullptr, &BoneDataTLMA[0], 0, 0);
			}
			else {

			}
		}


		void updateArmatureCBuf() {
			dxDeviceContext->UpdateSubresource(ArmatureCBuf, 0, nullptr, &BoneDataTLMA[0], 0, 0);
		}

		void CheckToUpdateArmatureCBuf() {
			if (ToUpdateCBoneBuf == true) { updateArmatureCBuf(); ToUpdateCBoneBuf = false; }
		}

		std::array<float, 3> Translate() {
			return GetTranslate(&ObjTune);
		}

		std::array<float, 3> Scale() {
			return GetScale(&ObjTune);
		}
		std::array<float, 4> Quaternion() {
			return GetQuaternion(&ObjTune);
		}
		std::array<float, 3> Radians() { //ObjTune.Quat
			return GetRadians(&ObjTune);
		}


		void DefaultCBuf() {
			D3D11_BUFFER_DESC bufDesc;
			ZeroMemory(&bufDesc, sizeof(bufDesc));
			bufDesc.Usage = D3D11_USAGE_DEFAULT;
			bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
			bufDesc.CPUAccessFlags = 0;
			bufDesc.ByteWidth = sizeof(ObjTuneStatReg);

			dxDevice->CreateBuffer(&bufDesc, nullptr, &CBuf);

			dxDeviceContext->UpdateSubresource(CBuf, 0, nullptr, &ObjTune, 0, 0);
		}


		void SetupTexLinkResource(int MTC, int TypeOfTexture = 0) {

			D3D11_SHADER_RESOURCE_VIEW_DESC SRVdesc;
			SRVdesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
			SRVdesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
			SRVdesc.Buffer.FirstElement = 0;
			SRVdesc.Buffer.NumElements = 1;
			SRVdesc.Texture2D.MostDetailedMip = 0;
			SRVdesc.Texture2D.MipLevels = 1;

			dxDevice->CreateShaderResourceView(Mat[MTC].TexR[TypeOfTexture], &SRVdesc, &Mat[MTC].TexSRV[TypeOfTexture]); //seperate

		//	dxDevice->CreateUnorderedAccessView(gpuTex, &UAVdesc, &UAV);

		}

		void SetupBlendStateDefault() {
			D3D11_BLEND_DESC blendVal;

			blendVal.AlphaToCoverageEnable = false;
			blendVal.IndependentBlendEnable = false;
			blendVal.RenderTarget[0].BlendEnable = true;
			blendVal.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
			blendVal.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
			blendVal.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
			blendVal.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
			blendVal.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
			blendVal.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
			blendVal.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;

			SafeRelease(BlendState);
			dxDevice->CreateBlendState(&blendVal, &BlendState);
		}

		//TODO: options in blend state

		void CreateSampler(bool LinearTOrPoint = true, bool ClampTOrMirror = true) {

			if (Sampler != nullptr)
				SafeRelease(Sampler);

			D3D11_SAMPLER_DESC tmpSampleDesc;

			tmpSampleDesc.AddressU = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_WRAP };
			tmpSampleDesc.AddressV = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_WRAP };
			tmpSampleDesc.AddressW = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_WRAP };
			tmpSampleDesc.MipLODBias = 0;
			tmpSampleDesc.MaxAnisotropy = 8;
			tmpSampleDesc.ComparisonFunc = D3D11_COMPARISON_FUNC{ D3D11_COMPARISON_NEVER }; //never remove model for now - always pass render pass
			tmpSampleDesc.MinLOD = 1;
			tmpSampleDesc.MaxLOD = D3D11_FLOAT32_MAX;

			if (LinearTOrPoint) //don't give an option for mip linear filter for now - testing 
			{
				tmpSampleDesc.Filter = D3D11_FILTER{ D3D11_FILTER_MIN_MAG_MIP_LINEAR };
			}
			else
			{
				tmpSampleDesc.Filter = D3D11_FILTER{ D3D11_FILTER_MIN_MAG_MIP_POINT };
			}

			if (ClampTOrMirror) //no option for mirror tex as well
			{
				tmpSampleDesc.AddressU = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_CLAMP };
				tmpSampleDesc.AddressV = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_CLAMP };
				tmpSampleDesc.AddressW = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_CLAMP };
			}
			else
			{
				tmpSampleDesc.AddressU = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_MIRROR };
				tmpSampleDesc.AddressV = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_MIRROR };
				tmpSampleDesc.AddressW = D3D11_TEXTURE_ADDRESS_MODE{ D3D11_TEXTURE_ADDRESS_MIRROR };
			}

			dxDevice->CreateSamplerState(&tmpSampleDesc, &Sampler);

		}
		void SetTexEqual(olc::Decal* Tex, int MTC = 0, int TypeOfTexture = 0) { //SETS THE TEXTURE EXACTLY TO THE SPECIFIED DECAL, THIS IS HOW YOU INTERPOLATE THIS PROGRAM TO USE ANIMATED DECAL.h THING ECT;
			int end = Mat.size();

			if (MTC > end) {
				MTC = 0;
			}
			else end = MTC + 1;

			for(int i = MTC; i < end; i++) {
				if (Mat[i].TexR[TypeOfTexture] != NULL) {
					SafeRelease(Mat[i].TexR[TypeOfTexture]);
				}

				olc::DecalTSR[Tex->id]->QueryInterface(IID_ID3D11Texture2D, (void**)&Mat[i].TexR[TypeOfTexture]);
				Mat[i].TexSRV[TypeOfTexture] = olc::DecalTSV[Tex->id];
			}
		}
		
		void SetTexEqual(ID3D11ShaderResourceView* Tex, int MTC = 0, int TypeOfTexture = 0) { //SETS THE TEXTURE EXACTLY TO THE SPECIFIED DECAL, THIS IS HOW YOU INTERPOLATE THIS PROGRAM TO USE ANIMATED DECAL.h THING ECT;
			int end = Mat.size();

			if (MTC > end) {
				MTC = 0;
			}
			else end = MTC + 1;

			for (int i = MTC; i < end; i++) {
				if (Mat[i].TexR[TypeOfTexture] != NULL) {
					SafeRelease(Mat[i].TexR[TypeOfTexture]);
				}
				Mat[i].TexSRV[TypeOfTexture] = Tex;
			}
		}

		void SetTexCopy(olc::Decal* Tex, int MTC = 0/*Material to change*/, int TypeOfTexture = 0) {
			int end = Mat.size();

			if (MTC > end) {
				MTC = 0;
			}
			else end = MTC + 1;

			for (int i = MTC; i < end; i++) {

				if (Mat[i].TexR[TypeOfTexture] != NULL)
					SafeRelease(Mat[i].TexR[TypeOfTexture]);

				dxDeviceContext->CopyResource(Mat[i].TexR[TypeOfTexture], olc::DecalTSR[Tex->id]);

				SetupTexLinkResource(i);

			}
		}
		void SetTexCopy(olc::Sprite* Tex, int MTC = 0, int TypeOfTexture = 0) {
			
			int end = Mat.size();

			if (MTC > end) {
				MTC = 0;
			}
			else end = MTC + 1;

			for (int ii = MTC; ii < end; ii++) {

				SafeRelease(Mat[ii].TexR[TypeOfTexture]);


				//			if (Mat[MTC].TexR[TypeOfTexture] != NULL)
				//				SafeRelease(Mat[MTC].TexR[TypeOfTexture]); //TODO: fix this relate in case new 

				D3D11_TEXTURE2D_DESC gpuTexDescS;
				ZeroMemory(&gpuTexDescS, sizeof(gpuTexDescS));
				gpuTexDescS.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				gpuTexDescS.Width = Tex->width;
				gpuTexDescS.Height = Tex->height;
				gpuTexDescS.MipLevels = 1;
				gpuTexDescS.ArraySize = 1;
				gpuTexDescS.BindFlags = D3D11_BIND_SHADER_RESOURCE;
				gpuTexDescS.SampleDesc.Count = 1;
				gpuTexDescS.SampleDesc.Quality = 0;
				gpuTexDescS.MiscFlags = 0;
				gpuTexDescS.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
				gpuTexDescS.Usage = D3D11_USAGE_DYNAMIC;

				D3D11_SHADER_RESOURCE_VIEW_DESC SRVdesc;
				SRVdesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				SRVdesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
				SRVdesc.Buffer.FirstElement = 0;
				SRVdesc.Buffer.NumElements = 1;
				SRVdesc.Texture2D.MostDetailedMip = 0;
				SRVdesc.Texture2D.MipLevels = 1;

				dxDevice->CreateTexture2D(&gpuTexDescS, NULL, &Mat[ii].TexR[TypeOfTexture]);

				dxDevice->CreateShaderResourceView(Mat[ii].TexR[TypeOfTexture], &SRVdesc, &Mat[ii].TexSRV[TypeOfTexture]);

				D3D11_MAPPED_SUBRESOURCE resource;

				dxDeviceContext->Map(Mat[ii].TexR[TypeOfTexture], 0, D3D11_MAP_WRITE_DISCARD, 0, &resource);
				BYTE* mappedData = reinterpret_cast<BYTE*>(resource.pData);
				BYTE* buffer = reinterpret_cast<BYTE*>(Tex->pColData.data());

				for (int i = 0; i < Tex->height; i++) {
					memcpy(mappedData, buffer, Tex->width * sizeof(olc::Pixel));
					mappedData += resource.RowPitch;

					buffer += Tex->width * sizeof(olc::Pixel);
				}

				dxDeviceContext->Unmap(Mat[ii].TexR[TypeOfTexture], 0);
			}
	
		}

		void LoadVertexIndiceData() //also reloads vertex data
		{


			for (int i = 0; i < VBuf.size(); i++) {
				//	if (VBuf != nullptr) {
				SafeRelease(VBuf[i]);
				//	}
				//	if (IBuf != nullptr){
				SafeRelease(IBuf[i]);
				//	}

				D3D11_BUFFER_DESC vertexBufferDesc; //describe buffer we will make
				ZeroMemory(&vertexBufferDesc, sizeof(D3D11_BUFFER_DESC));

				vertexBufferDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_VERTEX_BUFFER; //how to bind buffer 

				vertexBufferDesc.ByteWidth = sizeof(VNT) * (modelDat[i].size()); //size of buffer --> make it the size of verticies*vertexPosColor [since vertex will have pos and color
				vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; // 0 means no CPU acsess

				vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC; //resource flag - 0 means none
				vertexBufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS;

				D3D11_SUBRESOURCE_DATA resourceData; //data for buffer
				ZeroMemory(&resourceData, sizeof(D3D11_SUBRESOURCE_DATA));
				resourceData.pSysMem = &modelDat[i][0]; //Vertex data for sub source

				dxDevice->CreateBuffer(&vertexBufferDesc, &resourceData, &VBuf[i]); //create buffer, using data settings struct, struct of data, and vertex buffer output - this is also used to create other buffer styles

				D3D11_BUFFER_DESC a;
				VBuf[i]->GetDesc(&a);

				ID3D11Buffer* tmpVertex;

				D3D11_BUFFER_DESC vertexBufferDescU; //describe buffer we will make
				ZeroMemory(&vertexBufferDescU, sizeof(D3D11_BUFFER_DESC));

				vertexBufferDescU.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE; //how to bind buffer 

				vertexBufferDescU.ByteWidth = sizeof(VNT) * (modelDat[i].size()); //size of buffer --> make it the size of verticies*vertexPosColor [since vertex will have pos and color
				vertexBufferDescU.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ; // 0 means no CPU acsess

				vertexBufferDescU.Usage = D3D11_USAGE_DEFAULT; //resource flag - 0 means none

				vertexBufferDescU.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
				vertexBufferDescU.StructureByteStride = sizeof(VNT);

				resourceData.pSysMem = &modelDat[i][0]; //Vertex data pos for sub source - use Position?

				dxDevice->CreateBuffer(&vertexBufferDescU, &resourceData, &tmpVertex);

				D3D11_UNORDERED_ACCESS_VIEW_DESC UAVdesc;
				//DXGI_FORMAT_R32_TYPELESS
				UAVdesc.Format = DXGI_FORMAT_UNKNOWN;
				UAVdesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
				UAVdesc.Buffer.FirstElement = 0;
				UAVdesc.Buffer.NumElements = modelDat[i].size();
				UAVdesc.Buffer.Flags = 0;

				dxDevice->CreateUnorderedAccessView(tmpVertex, &UAVdesc, &VBufUAV[i]);

				D3D11_BUFFER_DESC indexBufferDesc; //buffer obj
				ZeroMemory(&indexBufferDesc, sizeof(D3D11_BUFFER_DESC)); //alloc

				indexBufferDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_INDEX_BUFFER; //type of buffer m8 - same logic as vertex
				indexBufferDesc.ByteWidth = sizeof(UINT) * (Indice[i].size());
				indexBufferDesc.CPUAccessFlags = 0;
				indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
				indexBufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS;

				resourceData.pSysMem = &Indice[i][0]; //indice data for sub source

				dxDevice->CreateBuffer(&indexBufferDesc, &resourceData, &IBuf[i]); //make buffer
			}
		}

		/*
		void LoadOBJFile(std::string path)
		{
			tinyobj::attrib_t attrib;
			std::vector<tinyobj::shape_t> shapes;
			std::vector<tinyobj::material_t> materials;
			std::string warn, err;

			if (!tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, path.c_str())) {
				throw std::runtime_error(warn + err);
			}

			modelDat.empty();
			Indice.empty();

			int i = 0;

			VNT tmpV;

			std::map<std::tuple<float, float, float>, int> b;

			for (const auto& shape : shapes) { // combine all faces into 1 model --> they are normally "seperate"
				i = 0;
				for (const auto& index : shape.mesh.indices) { //iterate through each indice in mesh


					tmpV.Position = {
						attrib.vertices[3 * index.vertex_index + 0], //since these are floats I multiply by 3?
						attrib.vertices[3 * index.vertex_index + 1],
						attrib.vertices[3 * index.vertex_index + 2] // move obj pos
					};

					tmpV.Tex = { // flip image vertically to fix model texture
						attrib.texcoords[2 * index.texcoord_index + 0], // this vector does not work if I do not set texcoods when making the obj
						attrib.texcoords[2 * index.texcoord_index + 1]
					};

					tmpV.Normal = { 0,0,0};



					if (b.count((std::make_tuple(tmpV.Position.x, tmpV.Position.y, tmpV.Position.z))) == 0) { //filter out duplicate verticies
						b[std::make_tuple(tmpV.Position.x, tmpV.Position.y, tmpV.Position.z)] = modelDat.size();
						modelDat.push_back(tmpV);
						//i++;
					}
					Indice.push_back(b[std::make_tuple(tmpV.Position.x, tmpV.Position.y, tmpV.Position.z)]);
				}
			}
		}
		*/
		void RESIZE_VECTORS_OBJ_LOAD(int i) {
			IBuf.resize(i);
			VBufUAV.resize(i);
			VBuf.resize(i);
			Indice.resize(i);
			modelDat.resize(i);
			VboneDat.resize(i);
			Mat.resize(i);
		}

		void LoadFBXFile(std::string path) {
			FILE* fp;

			fopen_s(&fp, path.c_str(), "rb");

			if (!fp) { std::cout << "no file found at fbx path"; }
			else {
				fseek(fp, 0, SEEK_END);
				long file_size = ftell(fp);
				fseek(fp, 0, SEEK_SET);
				ofbx::u8* content = new ofbx::u8[file_size];
				fread(content, 1, file_size, fp);

				ofbx::IScene* g_scene = ofbx::load((ofbx::u8*)content, file_size, (ofbx::u64)ofbx::LoadFlags::TRIANGULATE);

				Mat.clear();
				Bones.clear();
				BoneDataTLMA.clear();
				animNameI.clear();
				animNameS.clear();
				animStackMaxTime.clear();
				AnimVCacheData.clear();
				ClusterObject.clear();
				modelDat.clear();
				Indice.clear();
				VboneDat.clear();
				Bones.clear();
				BoneDataTLMA.clear();
				animDat.clear();
				animStack.clear();
				VBufUAV.clear();
				IBuf.clear();

				VNT tmpV;

				XMFLOAT3 TmpPos;
				XMFLOAT3 TmpNor;
				XMFLOAT2 TmpTex;
				UINT TmpInd;

				int obj_idx = 0;
				int indices_offset = 0;
				int normals_offset = 0;
				int mesh_count = g_scene->getMeshCount();
				//				std::map<std::tuple<std::tuple<float, float, float>,std::tuple<float, float>>, int> b;

				RESIZE_VECTORS_OBJ_LOAD(mesh_count);

				rootObj = g_scene->getRoot();
				ofbx::Matrix emp = rootObj->getGlobalTransform();

				XMFLOAT4X4 tmpgl = ofbxMatToXM(&emp);

				globalTransform = XMLoadFloat4x4(&tmpgl);

				globalInverseTransform = XMMatrixInverse(nullptr, globalTransform);

				for (int i = 0; i < mesh_count; i++)
				{

					const ofbx::Mesh& mesh = *g_scene->getMesh(i);
					const ofbx::Geometry& geom = *mesh.getGeometry();
					int vertex_count = geom.getVertexCount();
					const ofbx::Vec3* vertices = geom.getVertices();
					const ofbx::Vec2* uvs = geom.getUVs();
					const int indiceC = geom.getIndexCount();
					const ofbx::Vec3* normals = geom.getNormals();
					const ofbx::Pose* cPose = mesh.getPose();
					//				std::map<int, std::tuple<std::tuple<float, float, float>, std::tuple<float, float>>> bA;
							//POS NORMAL  TEX


					for (int ii = 0; ii < vertex_count; ii++)
					{

						tmpV.Position = { static_cast<float>(vertices[ii].x), static_cast<float>(vertices[ii].y), static_cast<float>(vertices[ii].z) };

						tmpV.Normal = { 0.0f,0.0f,0.0f };
						tmpV.BiNormal = { 0.0f,0.0f,0.0f };
						tmpV.Tangent = { 0.0f,0.0f,0.0f };

						if (uvs != nullptr) {
							tmpV.Tex = { static_cast<float>(uvs[ii].x),1.0f - static_cast<float>(uvs[ii].y) };
						}
						else {
							tmpV.Tex = { 0.0f,0.0f };
						}

						//						std::tuple < std::tuple<float, float, float>, std::tuple<float, float>> tmpTup = std::make_tuple(std::make_tuple(tmpV.Position.x, tmpV.Position.y, tmpV.Position.z), std::make_tuple(tmpV.Tex.x, tmpV.Tex.y));

												//TODO: redo incide stuff for bones to work
									//			if (b.count(tmpTup) == 0) {

						//							b[tmpTup] = modelDat.size();

						modelDat[i].push_back(tmpV);
						//			}

						Indice[i].push_back(Indice[i].size());

						//						Indice.push_back(b[tmpTup]);
									//			bA[Indice.size()] = tmpTup;
					}

					VboneDat[i].resize(modelDat[i].size());

					const ofbx::Skin* skin = geom.getSkin();
					if (skin) {
						int gctR = skin->getClusterCount();
						for (int ii = 0; ii < gctR; ii++)
						{

							const ofbx::Cluster* cluster = skin->getCluster(ii);

							if (cluster) {
								int indiceCount = cluster->getIndicesCount();
								//int counter = 0;
								if (indiceCount > 0) {
									const int* indList = cluster->getIndices();
									const double* tmpW = cluster->getWeights();

									//										std::map<int, bool> GotA; //
									for (int iii = 0; iii < indiceCount; iii++) {
										//											if (GotA[b[bA[indList[iii]]]] == false) { //get indice with bones - but limit to once per indice, all i's share - filter :thumbup:
										VboneDat[i][indList[iii]].weights.push_back(static_cast<float>(tmpW[iii]));
										VboneDat[i][indList[iii]].IDs.push_back(ii); //bone id

//												VboneDat[b[bA[indList[iii]]]].weights.push_back(static_cast<float>(tmpW[iii]));
//												VboneDat[b[bA[indList[iii]]]].IDs.push_back(ii); //bone id
//												GotA[b[bA[indList[iii]]]] = true;
//											}
									}
									//counter += 1;
									//tmpForFill.ID = i; //index is ID of bone
								}
								ofbx::Matrix TMPtm = cluster->getTransformMatrix();


								ofbx::Matrix TMPtlm = cluster->getTransformLinkMatrix(); //correct matrix

								ofbx::Matrix GeoTrans = mesh.getGeometricMatrix();

								ofbx::Matrix ModelMatrix = cluster->getLink()->getGlobalTransform();

								ofbx::Matrix LocalMatrix = cluster->getLink()->getLocalTransform();

								XMFLOAT4X4 XMIB = ofbxMatToXM(&GeoTrans);
								XMMATRIX tmpMMM = XMLoadFloat4x4(&XMIB);
								//		ofbx::Matrix linkGeo = cluster->getLink()->getGlobalTransform();




								ClusterObject.push_back(cluster);
								//TMPtlm = GeoTrans* TMPtlm;
								//TMPtm = TMPtm*linkGeo;

								XMFLOAT4X4 tmpTMtmp = ofbxMatToXM(&LocalMatrix);
								XMMATRIX tmpTM = XMLoadFloat4x4(&tmpTMtmp);

								XMFLOAT4X4 tmpGtmp = ofbxMatToXM(&ModelMatrix);
								XMMATRIX tmpG = XMLoadFloat4x4(&tmpGtmp);


								XMFLOAT4X4 tmpTLMF = ofbxMatToXM(&TMPtlm);
								XMMATRIX tmpTLMM = XMLoadFloat4x4(&tmpTLMF);
								tmpTLMM = XMMatrixInverse(nullptr, tmpTLMM);

								XMFLOAT4X4 tmptmpTLMMma = ofbxMatToXM(&TMPtm);
								XMMATRIX tmpTLMMma = XMLoadFloat4x4(&tmptmpTLMMma);

								//

								Joint nJ;
								nJ.Bone = cluster->getLink();
								nJ.name = nJ.Bone->name;
								nJ.id = Bones.size();
								nJ.LBT = (tmpTM)*XMMatrixInverse(nullptr, tmpG);
								nJ.BoneOffsetMatrix = tmpTLMMma;
								Bones.push_back(nJ);
							}
						}
					}
				}

				BoneDataTLMA.resize(Bones.size());
				animDat.resize(Bones.size());

				int animCount = g_scene->getAnimationStackCount();

				for (int xx = 0; xx < animCount; xx++)
				{
					const ofbx::AnimationStack* astack = g_scene->getAnimationStack(xx);

					animStack.push_back(astack);
					animNameI[xx] = astack->name;
					animNameS[astack->name] = xx;
				}

				//load data from g_scene now
			}

			fclose(fp);
		}

		/*
		void MakeVertexGlobal(XMMATRIX* VERTEX, ) {

			XMMATRIX tmp = XMLoadFloat4x4(&rootObjM);
			for (int i = 0; i < modelDat.size(); i++) {

				XMVECTOR tmp2 = XMLoadFloat3(&modelDat[i].Position);

				tmp2 = XMVector3Transform(tmp2,tmp);

				XMStoreFloat3(&modelDat[i].Position, tmp2);
			}
		}
		*/

		XMMATRIX GetWorldMat(const ofbx::Object* obj, ofbx::Matrix Geo) {

			ofbx::Matrix ModelMatrix = obj->getGlobalTransform();
			ModelMatrix = ModelMatrix * Geo;

			XMFLOAT4X4 tmpGtmp = ofbxMatToXM(&ModelMatrix);
			return XMMatrixInverse(nullptr, XMLoadFloat4x4(&tmpGtmp));

		}


		void BindPoseBones() {

			for (int i = 0; i < Bones.size(); i++) {

				XMStoreFloat4x4(&BoneDataTLMA[i], (Bones[i].SkinM));
				//BoneDataTLMA[i] = rootObjM;
			}
		}

		void GetAnimEndTime(int Anim) {
			float max = 0; // max time getter func - iterate through keys

			for (int i = 0; i < Bones.size(); i++) {

				for (int x = 0; x < 3; x++) {
					ofbx::i64 tcnV = 0.0f;
					ofbx::i64 rcnV = 0.0f;
					ofbx::i64 scnV = 0.0f;

					if (Bones[i].tNode[Anim] != NULL) {
						if (Bones[i].tNode[Anim]->getCurve(x)) {
							const ofbx::AnimationCurve* tc = Bones[i].tNode[Anim]->getCurve(x);
							int tcn = tc->getKeyCount() - 1;
							tcnV = tc->getKeyTime()[tcn];
						}
					}

					if (Bones[i].rNode[Anim] != NULL) {
						if (Bones[i].rNode[Anim]->getCurve(x)) {
							const ofbx::AnimationCurve* rc = Bones[i].rNode[Anim]->getCurve(x);
							int rcn = rc->getKeyCount() - 1;
							rcnV = rc->getKeyTime()[rcn];
						}
					}

					if (Bones[i].sNode[Anim] != NULL) {
						if (Bones[i].sNode[Anim]->getCurve(x)) {
							const ofbx::AnimationCurve* sc = Bones[i].sNode[Anim]->getCurve(x);
							int scn = sc->getKeyCount() - 1;
							scnV = sc->getKeyTime()[scn];
						}
					}


					ofbx::i64 maxTmp = std::max({ tcnV,rcnV,scnV });

					if (max < maxTmp) max = static_cast<float>(ofbx::fbxTimeToSeconds(maxTmp));
				}

			}
			animStackMaxTime[Anim] = max;
		}

		void GetAllAnimEndTime() {
			for (int i = 0; i < animStack.size(); i++) {
				GetAnimEndTime(i);
			}
		}

		void ResizeAndPrepAnimBoneStuff() {
			animStackMaxTime.resize(animStack.size());
			AnimVCacheMade.resize(animStack.size());
			AnimVCacheData.resize(animStack.size());
			//			for (int i = 0; i < AnimVCacheData.size(); i++) {
			//				AnimVCacheData[i].resize(Bones.size());
			//			}
		}

		void PostProcessNormals() {
			for (int i = 0; i < modelDat.size(); i++) {
				for (int x = 0; x < modelDat[i].size(); x += 3) {
					XMVECTOR A = XMLoadFloat3(&modelDat[i][x].Position);
					XMVECTOR B = XMLoadFloat3(&modelDat[i][x + 1].Position);
					XMVECTOR C = XMLoadFloat3(&modelDat[i][x + 2].Position);

					A = XMVector3Cross((B - A), (C - A));

					XMStoreFloat3(&modelDat[i][x].Normal, A);

					XMStoreFloat3(&modelDat[i][x + 1].Normal, A);

					XMStoreFloat3(&modelDat[i][x + 2].Normal, A);

				}
			}
		}


		void PostProcessTangents() {
			for (int i = 0; i < modelDat.size(); i++) {

				XMVECTOR* tan1 = new XMVECTOR[modelDat[i].size() * 2];
				ZeroMemory(tan1, modelDat[i].size() * sizeof(XMFLOAT3) * 2);

				for (int x = 0; x < modelDat[i].size(); x += 3) {


					XMFLOAT3* A = (&modelDat[i][x].Position);
					XMFLOAT3* B = (&modelDat[i][x + 1].Position);
					XMFLOAT3* C = (&modelDat[i][x + 2].Position);

					XMFLOAT2* UA = (&modelDat[i][x].Tex);
					XMFLOAT2* UB = (&modelDat[i][x + 1].Tex);
					XMFLOAT2* UC = (&modelDat[i][x + 2].Tex);

					float x1 = B->x - A->x;
					float x2 = C->x - A->x;
					float y1 = B->y - A->y;
					float y2 = C->y - A->y;
					float z1 = B->z - A->z;
					float z2 = C->z - A->z;

					float s1 = UB->x - UA->x;
					float s2 = UC->x - UA->x;
					float t1 = UB->y - UA->y;
					float t2 = UC->y - UA->y;

					float r = 1.0f / (s1 * t2 - s2 * t1);

					XMFLOAT3 sdir = { (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,
						(t2 * z1 - t1 * z2) * r };

					tan1[x] += XMLoadFloat3(&sdir);
					tan1[x + 1] += XMLoadFloat3(&sdir);
					tan1[x + 2] += XMLoadFloat3(&sdir);

				}
				/*

				XMFLOAT3* A = (&modelDat[i][modelDat[i].size() - 2].Position);
				XMFLOAT3* B = (&modelDat[i][modelDat[i].size() - 1].Position);
				XMFLOAT3* C = (&modelDat[i][0].Position);

				XMFLOAT2* UA = (&modelDat[i][modelDat[i].size() - 2].Tex);
				XMFLOAT2* UB = (&modelDat[i][modelDat[i].size() - 1].Tex);
				XMFLOAT2* UC = (&modelDat[i][0].Tex);

				float x1 = B->x - A->x;
				float x2 = C->x - A->x;
				float y1 = B->y - A->y;
				float y2 = C->y - A->y;
				float z1 = B->z - A->z;
				float z2 = C->z - A->z;

				float s1 = UB->x - UA->x;
				float s2 = UC->x - UA->x;
				float t1 = UB->y - UA->y;
				float t2 = UC->y - UA->y;

				float r = 1.0f / (s1 * t2 - s2 * t1);

				XMFLOAT3 sdir = { (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,
					(t2 * z1 - t1 * z2) * r };

				tan1[modelDat[i].size() - 2] += XMLoadFloat3(&sdir);
				tan1[modelDat[i].size() - 1] += XMLoadFloat3(&sdir);
				tan1[0] += XMLoadFloat3(&sdir);

				////////////////////


				A = (&modelDat[i][modelDat[i].size() - 1].Position);
				B = (&modelDat[i][0].Position);
				C = (&modelDat[i][1].Position);

				UA = (&modelDat[i][modelDat[i].size() - 1].Tex);
				UB = (&modelDat[i][0].Tex);
				UC = (&modelDat[i][1].Tex);

				x1 = B->x - A->x;
				x2 = C->x - A->x;
				y1 = B->y - A->y;
				y2 = C->y - A->y;
				z1 = B->z - A->z;
				z2 = C->z - A->z;

				s1 = UB->x - UA->x;
				s2 = UC->x - UA->x;
				t1 = UB->y - UA->y;
				t2 = UC->y - UA->y;

				r = 1.0f / (s1 * t2 - s2 * t1);

				sdir = { (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,
					(t2 * z1 - t1 * z2) * r };

				tan1[modelDat[i].size() - 1] += XMLoadFloat3(&sdir);
				tan1[0] += XMLoadFloat3(&sdir);
				tan1[1] += XMLoadFloat3(&sdir);

				*/

				for (long a = 0; a < modelDat[i].size(); a++)
				{
					XMVECTOR n = XMLoadFloat3(&modelDat[i][a].Normal);
					XMVECTOR t = tan1[a];

					XMStoreFloat3(&modelDat[i][a].Tangent, XMVector3Normalize((t - n * XMVector3Dot(n, t))));
				}
				delete[] tan1;
			}

		}

		void PostProcessBinormals() {
			for (int i = 0; i < modelDat.size(); i++) {
				for (int x = 0; x < modelDat[i].size(); x++) {

					XMStoreFloat3(&modelDat[i][x].BiNormal, XMVector3Normalize(XMVector3Cross(XMLoadFloat3(&modelDat[i][x].Normal), XMLoadFloat3(&modelDat[i][x].Tangent))));

				}
			}
		}
		void VertexPostProcess() {
			PostProcessNormals();
			PostProcessTangents();
			PostProcessBinormals();
		}


		void LoadFBXFileWithVertex(std::string path) {
			LoadFBXFile(path);

			VertexPostProcess();

			SetAllBonesChildren();
			SetAllBonesParent();
			SetAllBonesGetInvBindT();

			ResizeAllBonesNodeArr();
			GetAllBoneNodes();

			ResizeAndPrepAnimBoneStuff();

			GetAllAnimEndTime();

			BindPoseBones();

			CreateArmatureCBuf();
			FillTopBones();
			LoadVertexIndiceData();
		}
		//TODO: , make translate in pixels for x, y - and z is x depth for pixels

		void PassCBufToGPU() {
			dxDeviceContext->UpdateSubresource(CBuf, 0, nullptr, &ObjTune, 0, 0);
		}

		void MSRObject(std::array<float, 3> XYZTranslate = { 0.0f,0.0f,0.0f }, std::array<float, 3> scale = { 1.0f,1.0f,1.0f }, std::array<float, 3> rotateXYZaxis = { 0.0f,0.0f,0.0f }) { // pass in OG values to not change the ones not wanted to modify
			// radians
			olc::vf2d vInvScreenSize = {
		(1.0f / float(PL.ScreenWidth())),
		(1.0f / float(PL.ScreenHeight()))
			};

			ObjTune.Translate = std::array<float, 3>{ToNotPGESpace(&vInvScreenSize.x, &XYZTranslate[0]), ToNotPGESpace(&vInvScreenSize.y, &XYZTranslate[1]), ToNotPGESpace(&vInvScreenSize.x, &XYZTranslate[2]) };

			ObjTune.Scale = scale;

			XMStoreFloat4(&ObjTune.Quat, XMQuaternionRotationRollPitchYaw(rotateXYZaxis[0], rotateXYZaxis[1], rotateXYZaxis[2]));

			PassCBufToGPU();
		}

		void MSRDefBone(std::array<float, 3> XYZTranslate = { 0.0f,0.0f,0.0f }, std::array<float, 3> scale = { 1.0f,1.0f,1.0f }, std::array<float, 3> rotateXYZaxis = { 0.0f,0.0f,0.0f }) {

		}

		//nullptr means no tex default
		M3DR(olc::Decal* Tex, std::string path = "", bool LinearTOrPoint = true, bool ClampTOrMirror = true) {
			//SetupTexLinkResource();
			SetupBlendStateDefault();
			if (path != "") {
				LoadFBXFileWithVertex(path);
			}
			else {
				std::cout << "no file at path";
			}
			DefaultCBuf();

			CreateSampler(LinearTOrPoint, ClampTOrMirror);

			DefaultAllMatBuf();

			if (Tex != nullptr) {
				for (int i = 0; i < Mat.size(); i++) {
					SetTexCopy(Tex, i, AMBIENT_TEX);
				}
				SetUseAmbientTexture(10000, true);
			}
			
		}
		M3DR(olc::Sprite* Tex, std::string path = "", bool LinearTOrPoint = true, bool ClampTOrMirror = true) {

			//id TexLinkResource();
			SetupBlendStateDefault();
			if (path != "") {
				LoadFBXFileWithVertex(path);
			}
			DefaultCBuf();

			CreateSampler(LinearTOrPoint, ClampTOrMirror);

			DefaultAllMatBuf();

			if (Tex != nullptr) {
				for (int i = 0; i < Mat.size(); i++) {
					SetTexCopy(Tex, i, AMBIENT_TEX);
				}
				SetUseAmbientTexture(10000, true);
			}
		}
		//Empty setup

		void AutoFillIndice(int Obj) {
			if (Obj >= Indice.size()) { Indice.resize(Obj + 1); }
			Indice[Obj].resize(modelDat[Obj].size());
			for (int i = 0; i < modelDat[Obj].size(); i++) {
				Indice[Obj][i] = i;
			}
		}

		M3DR(std::vector<VNT> V, bool LinearTOrPoint = true, bool ClampTOrMirror = true) {

			RESIZE_VECTORS_OBJ_LOAD(1);

			CreateArmatureCBuf();

			modelDat[0] = V;
			AutoFillIndice(0);

			LoadVertexIndiceData();

			DefaultCBuf();
			SetupBlendStateDefault();
			CreateSampler(LinearTOrPoint, ClampTOrMirror);

			ChangeAllMatToLight();


			Mat.resize(1);

			DefaultAllMatBuf();

		}

	};

	struct DebugLights {
		std::vector<M3DR> L;



		void SetLightColor(int i) {
			L[i].Mat[0].MatData.BaseColor = ULPC.ULP.Lights[i].Color;
			L[i].Mat[0].UpdateMat = true;
		}

		void SetLightMSR(int i) {
			olc::vf2d inv = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
			};

			L[i].ObjTune.Translate = std::array<float, 3>{ULPC.ULP.Lights[i].PositionVS.x, ULPC.ULP.Lights[i].PositionVS.y, ULPC.ULP.Lights[i].PositionVS.z};

			float mag = sqrt(pow(ULPC.ULP.Lights[i].DirectionVS.x, 2) + pow(ULPC.ULP.Lights[i].DirectionVS.y, 2) + pow(ULPC.ULP.Lights[i].DirectionVS.z, 2));

			float d = 1;
			float size = ULPC.ULP.Lights[i].Range*0.1;

			std::array <float, 3> angle = { acos(ULPC.ULP.Lights[i].DirectionVS.x / mag),acos(ULPC.ULP.Lights[i].DirectionVS.y / mag),acos(ULPC.ULP.Lights[i].DirectionVS.z / mag) };

			//				angle[0] *= 1;
			//				angle[1] *= 1;
			//				angle[2] *= 1;

			if (ULPC.ULP.Lights[i].LightType == 0) {
				L[i].MSRObject( // I could set and set bool to not change position, but :shrug: 
					L[i].Translate(),
					{ size,size,size },
					angle
				);
			}
			else if (ULPC.ULP.Lights[i].LightType == 1) {
				L[i].MSRObject( // I could set and set bool to not change position, but :shrug: 
					L[i].Translate(),
					{ size,size,size },
					angle
				);
			}
			else if (ULPC.ULP.Lights[i].LightType == 2) {
				L[i].MSRObject( // I could set and set bool to not change position, but :shrug: 
					L[i].Translate(),
					{ size,size,size },
					angle
				);
			}
		}

		void FillLightIndex(int i) {
			if (ULPC.ULP.Lights[i].LightType == 0) {
				L[i] = M3DR(DirectionLightVNT);
				L[i].IsDebugLight = true;
				L[i].DebugLightID = i;
				L[i].DebugLightVType = 0;
			}
			else if (ULPC.ULP.Lights[i].LightType == 1) {
				L[i] = M3DR(PointLightVNT);
				L[i].IsDebugLight = true;
				L[i].DebugLightID = i;
				L[i].DebugLightVType = 1;
			}
			else if (ULPC.ULP.Lights[i].LightType == 2) {
				L[i] = M3DR(SpotLightVNT);
				L[i].IsDebugLight = true;
				L[i].DebugLightID = i;
				L[i].DebugLightVType = 2;
			}
		}
		void CheckAndSetLightTypeV(int i) {
			if (L[i].DebugLightVType != ULPC.ULP.Lights[i].LightType) {
				FillLightIndex(i);
			}
		}
		void ReFillAllL() {
			for (int i = 0; i < ULPC.ULP.Lights.size(); i++) {

				if (ULPC.ULP.Lights[i].LightType == 0) {
					M3DR tmp = M3DR(DirectionLightVNT);
					tmp.IsDebugLight = true;
					tmp.DebugLightID = i;
					tmp.DebugLightVType = 0;
					L.push_back(tmp);
				}
				else if (ULPC.ULP.Lights[i].LightType == 1) {
					M3DR tmp = M3DR(PointLightVNT);
					tmp.IsDebugLight = true;
					tmp.DebugLightID = i;
					tmp.DebugLightVType = 1;
					L.push_back(tmp);
				}
				else if (ULPC.ULP.Lights[i].LightType == 2) {
					M3DR tmp = M3DR(SpotLightVNT);
					tmp.IsDebugLight = true;
					tmp.DebugLightID = i;
					tmp.DebugLightVType = 1;
					L.push_back(tmp);
				}
			}
		}


		DebugLights() {

		}
	}DL;

	struct ShaderCollection { // I got lazy typing public: to a class... why not a class - those programming books and their public: classes... just use structs next time...

		ID3D11VertexShader* BMSVs;
		ID3D11PixelShader* BMSPs;
		ID3D11InputLayout* BMSIl;

		ID3D11VertexShader* CreateShaderStaticM(ID3DBlob* pShaderBlob, ID3D11ClassLinkage* pClassLinkage) //vertex shader - shader type
		{
			ID3D11VertexShader* pVertexShader = nullptr;
			dxDevice->CreateVertexShader(pShaderBlob->GetBufferPointer(), pShaderBlob->GetBufferSize(), pClassLinkage, &pVertexShader); //make a shader based on buffer, buffer size, classtype, and return to pshader object

			D3D11_INPUT_ELEMENT_DESC dxVertexLayoutDesc[] =
			{
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "BINORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				//{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "BLENDID", 0, DXGI_FORMAT_R32G32B32A32_SINT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "BLENDWEIGHT", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			};

			HRESULT hr = dxDevice->CreateInputLayout( //make input layout - global change to input Layout
				dxVertexLayoutDesc, //vertex shader - input assembler data
				_countof(dxVertexLayoutDesc), //number of elements
				pShaderBlob->GetBufferPointer(),  //vertex shader buffer
				pShaderBlob->GetBufferSize(), //vetex shader blob size 
				&BMSIl); //input layout to output to

			if (FAILED(hr))
			{
				OutputDebugStringW(L"failed input layout setup");
			}
			return pVertexShader;
		}

		ID3D11VertexShader* LoadShaderStaticM(const std::string* shaderInfo, const std::string& entryPoint, const std::string& _profile) {

			ID3DBlob* pShaderBlob = nullptr;
			ID3DBlob* pErrorBlob = nullptr;
			ID3D11VertexShader* pShader = nullptr;

			std::string profile = _profile;
			if (profile == "latest")
			{
				profile = GetLatestProfile<ID3D11VertexShader>(); //get shader profiles/settings
			}

			UINT flags = D3DCOMPILE_OPTIMIZATION_LEVEL3;

#if _DEBUG
			flags |= D3DCOMPILE_DEBUG;
#endif
			HRESULT hr = D3DCompile2(shaderInfo->c_str(), shaderInfo->length(), nullptr,
				nullptr, nullptr, entryPoint.c_str(),
				profile.c_str(), flags, 0, 0, 0, 0, &pShaderBlob, &pErrorBlob);
			OutputDebugStringA("\n");
			if (pErrorBlob != nullptr) {
				OutputDebugStringA((const char*)pErrorBlob->GetBufferPointer());
			}

			pShader = CreateShaderStaticM(pShaderBlob, nullptr);

			SafeRelease(pShaderBlob); // no longer need shader mem
			SafeRelease(pErrorBlob); // no longer need shader mem <-- I frogot to safe release to delete and do other stuff... so I need to look back at that

			return pShader;

		}

		void CreateStaticModelShader() {

			//Something I abuse and is key in my PS code: dynamic uniform branching - the only perf hit is one of checking a if statment once if all branches share the same branching - parallel execution can happen like this - so don't worry with my if statment use if it will be the same for every pixel (vertex can hurt if not, but my alt. is to spend unreasonable CPU time setting stuff - unless I work on a new implm. which is not my number 1 priority)
#pragma region PS
			const std::string TestPS = std::string(
				//Lighting based on: https://www.3dgep.com/forward-plus/
				"#define MAX_LIGHTS " + std::to_string(ULPC.ULP.Lights.size()) + "\n"

				"#define BLOCK_SIZE +"+std::to_string(FrustumObj.BLOCK_SIZE)+"\n" // should be defined by the application.\n"

				"#define DIRECTIONAL_LIGHT 0\n"
				"#define POINT_LIGHT 1\n"
				"#define SPOT_LIGHT 2\n"

				"struct Material {\n"
				"float4 Emissive;\n"
				"float4 BaseColor;\n"
				"float4 Ambient;\n"
				"float4 Diffuse;\n"
				"float4 Specular;\n"
				"float4 Reflectance;\n"

				"float Opacity;\n"
				"float SpecularPower;\n"
				"float IndexOfRefraction;\n"
				"bool HasAmbientTexture;\n"

				"bool HasEmissiveTexture;\n"
				"bool HasDiffuseTexture;\n"
				"bool HasSpecularTexture;\n"
				"bool HasSpecularPowerTexture;\n"

				"bool HasNormalTexture;\n"
				"bool HasBumpTexture;\n" //!bump == normal
				"bool HasOpacityTexture;\n"
				"float BumpIntensity;\n"

				"float SpecularScale;\n"
				"float AlphaThreshold;\n"
				"bool Lit;"
				"float pad0;"

				"};\n"

				"cbuffer MatData : register(b0){\n"
				"Material Mat;\n"
				"};"

				"struct Light{\n"
				"float4 PositionWS;\n"
				"float4 PositionVS;\n"
				"float4 DirectionWS;\n"
				"float4 DirectionVS;\n"
				"float4 Color;\n"

				"float SpotAngle;\n"
				"float Range;\n"
				"float Intensity;\n"
				"uint Type;\n"

				"bool On;\n"
				"float3 pad1;\n"
				"};\n"

				"struct Plane\n"
				"{\n"
				"float3 N;   // Plane normal.\n"
				"float  d;\n"
				"};\n"

				"struct Frustum\n"
				"{\n"
				"Plane planes[4];   // left, right, top, bottom frustum planes.\n"
				"};\n"

				"cbuffer LightProperties : register(b10){\n" //TODO: load lights from structured buffer in texture - since then it loads faster and I have more than 64KB
				"Light Lights[MAX_LIGHTS];\n"
				"};\n"
				"cbuffer LightProperties : register(b11){\n"
				"float4 GlobalAmbient;\n"
				"};\n"
				"cbuffer LightProperties : register(b12){\n"
				"float4 EyePosition;\n"
				"};\n"

				"struct PixelShaderInput{\n"
				"float4 position : SV_POSITION;\n"
				"float3 normal: NORMAL;\n"
				"float3 binormal : TEXCOORD2;\n"
				"float3 tangent : TEXCOORD3;\n"
				"float2 tex : TEXCOORD0;\n"
				"float3 PositionWS : TEXCOORD1;\n"
				"}; \n"


				"Texture2D AmbientTexture : register(t0);\n"
				"Texture2D EmissiveTexture : register(t1);\n"
				"Texture2D DiffuseTexture : register(t2);\n"
				"Texture2D SpecularTexture : register(t3);\n"
				"Texture2D SpecularPowerTexture : register(t4);\n"
				"Texture2D NormalTexture : register(t5);\n"
				"Texture2D BumpTexture : register(t6);\n"
				"Texture2D OpacityTexture : register(t7);\n"

				"SamplerState SampleType : register(s0);\n"

				"StructuredBuffer<uint> LightIndexList : register(t9);\n"
				"Texture2D<uint2> LightGrid : register(t10);\n"

				"float3 ExpandNormal(float3 n)\n"
				"{\n"
				"return n * 2.0f - 1.0f;\n"
				"}\n"

				"float4 DoNormalMapping(float3x3 TBN, Texture2D tex, sampler s, float2 uv)\n"
				"{\n"
				"float3 normal = tex.Sample(s, uv).xyz;\n"
				"normal = ExpandNormal(normal);\n"

				// Transform normal from tangent space to view space.
				"normal = mul(normal, TBN);\n"
				"return normalize(float4(normal, 0));\n"
				"}\n"
				"float4 DoBumpMapping(float3x3 TBN, Texture2D tex, sampler s, float2 uv, float bumpScale)\n"
				"{\n"
				// Sample the heightmap at the current texture coordinate.
				"float height = tex.Sample(s, uv).r * bumpScale;\n"
				// Sample the heightmap in the U texture coordinate direction.
				"float heightU = tex.Sample(s, uv, int2(1, 0)).r * bumpScale;\n"
				// Sample the heightmap in the V texture coordinate direction.
				"float heightV = tex.Sample(s, uv, int2(0, 1)).r * bumpScale;\n"

				"float3 p = { 0, 0, height };\n"
				"float3 pU = { 1, 0, heightU };\n"
				"float3 pV = { 0, 1, heightV };\n"

				// normal = tangent x bitangent
				"float3 normal = cross(normalize(pU - p), normalize(pV - p));\n"

				// Transform normal from tangent space to view space.
				"normal = mul(normal, TBN);\n"

				"return float4(normal, 0);\n"
				"}\n"
				// This lighting result is returned by the 
	// lighting functions for each light type.
				"struct LightingResult\n"
				"{\n"
				"float4 Diffuse;\n"
				"float4 Specular;\n"
				"};\n"

				"float4 DoDiffuse(Light light, float4 L, float4 N)\n"
				"{\n"
				"float NdotL = max(dot(N, L), 0);\n"
				"return light.Color * NdotL;\n"
				"}\n"
				"float4 DoSpecular(Light light, Material material, float4 V, float4 L, float4 N)\n"
				"{\n"
				"float4 R = normalize(reflect(-L, N));\n"
				"float RdotV = max(dot(R, V), 0);\n"

				"return light.Color * pow(RdotV, material.SpecularPower);\n"
				"}\n"
				// Compute the attenuation based on the range of the light.
				"float DoAttenuation(Light light, float d)\n"
				"{\n"
				"return 1.0f - smoothstep(light.Range * 0.75f, light.Range, d);\n"
				"}\n"
				"LightingResult DoPointLight(Light light, Material mat, float4 V, float4 P, float4 N)\n"
				"{\n"
				"LightingResult result;\n"

				"float4 L = light.PositionVS - P;\n"
				"float distance = length(L);\n"
				"L = L / distance;\n"

				"float attenuation = DoAttenuation(light, distance);\n"

				"result.Diffuse = DoDiffuse(light, L, N) *\n"
				"attenuation * light.Intensity;\n"
				"result.Specular = DoSpecular(light, mat, V, L, N) *\n"
				"attenuation * light.Intensity;\n"

				"return result;\n"
				"}\n"
				"float DoSpotCone(Light light, float4 L)\n"
				"{\n"
				// If the cosine angle of the light's direction 
				// vector and the vector from the light source to the point being 
				// shaded is less than minCos, then the spotlight contribution will be 0.
				"float minCos = cos(radians(light.SpotAngle));\n"
				// If the cosine angle of the light's direction vector
				// and the vector from the light source to the point being shaded
				// is greater than maxCos, then the spotlight contribution will be 1.
				"float maxCos = lerp(minCos, 1, 0.5f);\n"
				"float cosAngle = dot(light.DirectionVS, -L);\n"
				// Blend between the minimum and maximum cosine angles.
				"return smoothstep(minCos, maxCos, cosAngle);\n"
				"}\n"
				"LightingResult DoSpotLight(Light light, Material mat, float4 V, float4 P, float4 N)\n"
				"{\n"
				"LightingResult result;\n"

				"float4 L = light.PositionVS - P;\n"
				"float distance = length(L);\n"
				"L = L / distance;\n"

				"float attenuation = DoAttenuation(light, distance);\n"
				"float spotIntensity = DoSpotCone(light, L);\n"

				"result.Diffuse = DoDiffuse(light, L, N) *\n"
				"attenuation * spotIntensity * light.Intensity;\n"
				"result.Specular = DoSpecular(light, mat, V, L, N) *\n"
				"attenuation * spotIntensity * light.Intensity;\n"

				"return result;\n"
				"}\n"
				"LightingResult DoDirectionalLight(Light light, Material mat, float4 V, float4 P, float4 N)\n"
				"{\n"
				"LightingResult result;\n"

				"float4 L = normalize(-light.DirectionVS);\n"

				"result.Diffuse = DoDiffuse(light, L, N) * light.Intensity;\n"
				"result.Specular = DoSpecular(light, mat, V, L, N) * light.Intensity;\n"

				"return result;\n"
				"}\n"

				"LightingResult DoLighting(StructuredBuffer<Light> lights, Material mat, float4 eyePos, float4 P, float4 N)\n"
				"{\n"
				"float4 V = normalize(eyePos - P);\n"

				"LightingResult totalResult = (LightingResult)0;\n"

				"for (int i = 0; i < MAX_LIGHTS; ++i)\n"
				"{\n"
				"LightingResult result = (LightingResult)0;\n"

				// Skip lights that are not enabled.
				"if (!lights[i].On) continue;\n"
				// Skip point and spot lights that are out of range of the point being shaded.
				"if (lights[i].Type != DIRECTIONAL_LIGHT &&\n"
				"length(lights[i].PositionVS - P) > lights[i].Range) continue;\n"

				"switch (lights[i].Type)\n"
				"{\n"
				"case DIRECTIONAL_LIGHT:\n"
				"{\n"
				"result = DoDirectionalLight(lights[i], mat, V, P, N);\n"
				"}\n"
				"break;\n"
				"case POINT_LIGHT:\n"
				"{\n"
				"result = DoPointLight(lights[i], mat, V, P, N);\n"
				"}\n"
				"break;\n"
				"case SPOT_LIGHT:\n"
				"{\n"
				"result = DoSpotLight(lights[i], mat, V, P, N);\n"
				"}\n"
				"break;\n"
				"}\n"
				"totalResult.Diffuse += result.Diffuse;\n"
				"totalResult.Specular += result.Specular;\n"
				"}\n"

				"return totalResult;\n"
				"}\n"


				"[earlydepthstencil]\n"
				"float4 SimplePS(PixelShaderInput IN) : SV_TARGET{\n"
				"float4 eyePos = EyePosition; //TODO, set eye pos to eye pos const buffer\n"
				"Material mat = Mat;"
				"float4 N = float4(0,0,0,0);"
				"float4 P = float4(IN.PositionWS, 1);\n" //maybe it was WS I needed?
				"float4 V = normalize(eyePos - P);\n"
				"float4 specular = 0;"
				// Compute ambient, emissive, diffuse, specular, and normal
				// similar to standard forward rendering.
				// That code is omitted here for brevity.

				"float4 diffuse = mat.Diffuse;\n"
				"if (mat.HasDiffuseTexture)\n"
				"{\n"
				"float4 diffuseTex = DiffuseTexture.Sample(SampleType, IN.tex);\n"
				"if (any(diffuse.rgb))\n"
				"{\n"
				"diffuse *= diffuseTex;\n"
				"}\n"
				"else\n"
				"{\n"
				"diffuse = diffuseTex;\n"
				"}\n"
				"}\n"

				"float alpha = diffuse.a;\n"
				"if (mat.HasOpacityTexture)\n"
				"{\n"
				// If the material has an opacity texture, use that to override the diffuse alpha.
				"alpha = OpacityTexture.Sample(SampleType, IN.tex).r;\n"
				"}\n"
				"float4 ambient = mat.Ambient;\n"
				"if (mat.HasAmbientTexture)\n"
				"{\n"
				"float4 ambientTex = AmbientTexture.Sample(SampleType, IN.tex);\n"
				"if (any(ambient.rgb))\n"
				"{\n"
				"ambient *= ambientTex;\n"
				"}\n"
				"else\n"
				"{\n"
				"ambient = ambientTex;\n"
				"}\n"
				"}\n"
				// Combine the global ambient term.

				"float4 emissive = mat.Emissive;\n"
				"if (mat.HasEmissiveTexture)\n"
				"{\n"
				"float4 emissiveTex = EmissiveTexture.Sample(SampleType, IN.tex);\n"
				"if (any(emissive.rgb))\n"
				"{\n"
				"emissive *= emissiveTex;\n"
				"}\n"
				"else\n"
				"{\n"
				"emissive = emissiveTex;\n"
				"}\n"
				"}\n"

				"if (mat.HasSpecularPowerTexture)\n"
				"{\n"
				"mat.SpecularPower = SpecularPowerTexture.Sample(SampleType, IN.tex).r* mat.SpecularScale;\n"
				"}\n"

				// Normal mapping

				"if (mat.HasNormalTexture)\n"
				"{\n"
				// For scenes with normal mapping, I don't have to invert the binormal.
				"float3x3 TBN = float3x3(normalize(IN.tangent),\n"
				"normalize(IN.binormal),\n"
				"normalize(IN.normal));\n"

				"N = DoNormalMapping(TBN, NormalTexture, SampleType, IN.tex);\n"
				"}\n"
				// Bump mapping
				"else if (mat.HasBumpTexture)\n"
				"{\n"
				// For most scenes using bump mapping, I have to invert the binormal.
				"float3x3 TBN = float3x3(normalize(IN.tangent),\n"
				"normalize(-IN.binormal),\n"
				"normalize(IN.normal));\n"

				"N = DoBumpMapping(TBN, BumpTexture, SampleType, IN.tex, mat.BumpIntensity);\n"
				"}\n"
				// Just use the normal from the model.
				"else\n"
				"{\n"
				"N = normalize(float4(IN.normal, 0));\n"
				"}\n"

				"if(mat.Lit==true){\n"
				// Get the index of the current pixel in the light grid.
				"uint2 tileIndex = uint2(floor(IN.position.xy / BLOCK_SIZE));\n"

				// Get the start position and offset of the light in the light index list.
				"uint startOffset = LightGrid[tileIndex].x;\n"
				"uint lightCount = LightGrid[tileIndex].y;\n"

				"LightingResult lit = (LightingResult)0; // DoLighting( Lights, mat, eyePos, P, N );\n"

				"for (uint i = 0; i < lightCount; i++)\n"
				"{\n"
				"uint lightIndex = LightIndexList[startOffset + i];\n"
				"Light light = Lights[lightIndex];\n"

				"LightingResult result = (LightingResult)0;\n"

				"switch (light.Type)\n"
				"{\n"
				"case DIRECTIONAL_LIGHT:\n"
				"{\n"
				"result = DoDirectionalLight(light, mat, V, P, N);\n"
				"}\n"
				"break;\n"
				"case POINT_LIGHT:\n"
				"{\n"
				"result = DoPointLight(light, mat, V, P, N);\n"
				"}\n"
				"break;\n"
				"case SPOT_LIGHT:\n"
				"{\n"
				"result = DoSpotLight(light, mat, V, P, N);\n"
				"}\n"
				"break;\n"
				"}\n"
				"lit.Diffuse += result.Diffuse;\n"
				"lit.Specular += result.Specular;\n"
				"}\n"

				"diffuse *= float4(lit.Diffuse.rgb, 1.0f); // Discard the alpha value from the lighting calculations.\n"
				"specular *= lit.Specular;\n"
				"return float4((ambient*GlobalAmbient + emissive + diffuse + specular).rgb, alpha * mat.Opacity);\n"

				"}\n"
				"return float4((ambient + emissive + diffuse + specular).rgb, alpha * mat.Opacity);\n"

			"}\n"
		//		"}\n"
			);
#pragma endregion PS

			const std::string TestVS = std::string(
				"cbuffer MyObjD : register(b6){\n"
				"float3 Translate;\n"
				"float pad1 = 0.0f;\n"
				"float3 Scale;\n"
				"float pad2;\n"
				"float4 Quat;\n"
				"}\n"

				"cbuffer PerApplication : register(b0){\n"
				"matrix projectionMatrix;\n"
				"}\n"

				"cbuffer PerFrame : register(b1){\n"
				"matrix viewMatrix;\n"
				"}\n"

				"cbuffer PerObject : register(b2){\n"
				"matrix worldMatrix;\n" //technically this is junk, but maybe someone else will use this in an extension - I personally don't want to use this for transform
				"}\n"

				"cbuffer Armature : register(b7){\n"
				"matrix armature[90];\n"
				"}\n"

				"struct AppData{\n"
				"float3 position : POSITION;\n"
				"float3 normal : NORMAL;\n"
				"float3 binormal : BINORMAL;\n"
				"float3 tangent : TANGENT;\n"

				"float2 tex : TEXCOORD;\n"
				"int4 bID : BLENDID;\n"
				"float4 bW : BLENDWEIGHT;\n"
				"};\n"

				"struct VertexShaderOutput{\n"
				"float4 position : SV_POSITION;\n"
				"float3 normal: NORMAL;\n"
				"float3 binormal : TEXCOORD2;\n"
				"float3 tangent : TEXCOORD3;\n"
				"float2 tex : TEXCOORD0;\n"
				"float3 PositionWS : TEXCOORD1;\n"
				"}; \n"

				"float3 QuatRotate(float3 pos, float4 quat){\n"
				"return pos + 2.0 * cross(quat.xyz, cross(quat.xyz, pos) + quat.w * pos);\n"
				"}\n"


				"VertexShaderOutput SimpleVS(AppData IN){\n"

				"VertexShaderOutput OUT;\n"
				"float4 bP = float4(0,0,0,0);\n"
				"float4 nF = float4(0,0,0,0);\n" //normals
				"float4 bn = float4(0,0,0,0);\n"
				"float4 tang = float4(0,0,0,0);\n"

				"if(!any(IN.bW)) { bP = float4(IN.position,1); nF = float4(IN.normal,1); bn = float4(IN.binormal,1); tang = float4(IN.tangent,1);}\n"
				"else{\n"
				"matrix tmpM = armature[IN.bID[0]]*IN.bW[0]+armature[IN.bID[1]]*IN.bW[1]+armature[IN.bID[2]]*IN.bW[2]+armature[IN.bID[3]]*IN.bW[3];\n"
				"bP = mul(tmpM,float4(IN.position,1));\n"
				"nF = mul(tmpM,float4(IN.normal,1));\n"
				"bn = mul(tmpM,float4(IN.binormal,1));\n"
				"tang = mul(tmpM,float4(IN.tangent,1));\n"

				"}\n"

				"float3 adjust = ((QuatRotate(bP.xyz, Quat)*Scale)+Translate);\n"
				"bP = float4(adjust,1);\n"

				"adjust = ((QuatRotate(nF.xyz, Quat)*(Scale))+Translate);\n"
				"nF = float4(adjust,1);\n"

				"adjust = ((QuatRotate(bn.xyz, Quat)*(Scale))+Translate);\n"
				"bn = float4(adjust,1);\n"

				"adjust = ((QuatRotate(tang.xyz, Quat)*(Scale))+Translate);\n"
				"tang = float4(adjust,1);\n"

				"matrix mvp = mul(projectionMatrix,viewMatrix);\n"

				"OUT.position = mul(mvp, bP);\n"
				"OUT.normal = nF.xyz;\n"
				"OUT.binormal = bn.xyz;"
				"OUT.tangent = tang.xyz;"
				"OUT.PositionWS = bP.xyz;\n"// TODO: I think this determiens light distance - TODO : try changing
				"OUT.tex = IN.tex;\n"
				"return OUT;\n"

				"}");

			if (BMSVs != nullptr) {
				SafeRelease(BMSVs);
				SafeRelease(BMSPs);
			}

			BMSVs = LoadShaderStaticM(&TestVS, "SimpleVS", "latest");

			BMSPs = LoadShader<ID3D11PixelShader>(&TestPS, "SimplePS", "latest");

		}

		ID3D11VertexShader* BMS2dVs;
		ID3D11PixelShader* BMS2dPs;
		ID3D11InputLayout* BMS2dIl;

		ID3D11VertexShader* CreateShaderStaticM2d(ID3DBlob* pShaderBlob, ID3D11ClassLinkage* pClassLinkage) //vertex shader - shader type
		{
			ID3D11VertexShader* pVertexShader = nullptr;
			dxDevice->CreateVertexShader(pShaderBlob->GetBufferPointer(), pShaderBlob->GetBufferSize(), pClassLinkage, &pVertexShader); //make a shader based on buffer, buffer size, classtype, and return to pshader object

			D3D11_INPUT_ELEMENT_DESC dxVertexLayoutDesc[] =
			{
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				//	{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
					{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
					{ "BLENDID", 0, DXGI_FORMAT_R32G32B32A32_SINT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
					{ "BLENDWEIGHT", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			};

			HRESULT hr = dxDevice->CreateInputLayout( //make input layout - global change to input Layout
				dxVertexLayoutDesc, //vertex shader - input assembler data
				_countof(dxVertexLayoutDesc), //number of elements
				pShaderBlob->GetBufferPointer(),  //vertex shader buffer
				pShaderBlob->GetBufferSize(), //vetex shader blob size 
				&BMSIl); //input layout to output to

			if (FAILED(hr))
			{
				OutputDebugStringW(L"failed input layout setup");
			}
			return pVertexShader;
		}

		ID3D11VertexShader* LoadShaderStaticM2d(const std::string* shaderInfo, const std::string& entryPoint, const std::string& _profile) {

			ID3DBlob* pShaderBlob = nullptr;
			ID3DBlob* pErrorBlob = nullptr;
			ID3D11VertexShader* pShader = nullptr;

			std::string profile = _profile;
			if (profile == "latest")
			{
				profile = GetLatestProfile<ID3D11VertexShader>(); //get shader profiles/settings
			}

			UINT flags = D3DCOMPILE_OPTIMIZATION_LEVEL3;

#if _DEBUG
			flags |= D3DCOMPILE_DEBUG;
#endif
			HRESULT hr = D3DCompile2(shaderInfo->c_str(), shaderInfo->length(), nullptr,
				nullptr, nullptr, entryPoint.c_str(),
				profile.c_str(), flags, 0, 0, 0, 0, &pShaderBlob, &pErrorBlob);
			OutputDebugStringA("\n");
			if (pErrorBlob != nullptr) {
				OutputDebugStringA((const char*)pErrorBlob->GetBufferPointer());
			}

			pShader = CreateShaderStaticM(pShaderBlob, nullptr);

			SafeRelease(pShaderBlob); // no longer need shader mem
			SafeRelease(pErrorBlob); // no longer need shader mem <-- I frogot to safe release to delete and do other stuff... so I need to look back at that

			return pShader;

		}

		void CreateStaticModel2dShader() {
#pragma region PS


			const std::string TestPS = std::string(
				"#define MAX_LIGHTS " + std::to_string(ULPC.ULP.Lights.size()) + "\n"

				"#define DIRECTIONAL_LIGHT 0\n"
				"#define POINT_LIGHT 1\n"
				"#define SPOT_LIGHT 2\n"

				"cbuffer MatData : register(b0){\n"
				"float4 Emissive;\n"
				"float4 BaseColor;\n"
				"float4 Ambient;\n"
				"float4 Diffuse;\n"
				"float4 Specular;\n"
				"float SpecularPower;\n"
				"bool HasTexture;\n"
				"bool Lit;"
				"float pad1;"
				"};"

				"struct Light{\n"
				"float4 Position;\n"
				"float4 Direction;\n"
				"float4 Color;\n"
				"float SpotAngle;\n"
				"float ConstantAttenuation;\n"
				"float LinearAttenuation;\n"
				"float QuadraticAttenuation;\n"
				"uint LightType;\n"
				"bool On;\n"
				"uint2 pad2;\n"
				"};\n"

				"cbuffer LightProperties : register(b10){\n"
				"Light Lights[MAX_LIGHTS];\n"
				"};\n"
				"cbuffer LightProperties : register(b11){\n"
				"float4 GlobalAmbient;\n"
				"};\n"
				"cbuffer LightProperties : register(b12){\n"
				"float4 EyePosition;\n"
				"};\n"

				"struct PixelShaderInput{\n"
				"float4 position : SV_POSITION;\n"
				"float3 normal: NORMAL;\n"
				"float2 tex : TEXCOORD0;\n"
				"float3 PositionWS : TEXCOORD1;\n"
				"};\n"

				"Texture2D shaderTexture : register(t0);\n"
				"SamplerState SampleType : register(s0);\n"


				"float4 MathDiffuse(Light light, float3 L, float3 N){\n"
				"float NdotL = max(0,dot(N,L));\n"
				"return light.Color*NdotL;\n"
				"}\n"

				"float4 MathSpecular(Light light, float3 V, float3 L, float3 N){\n"
				"float3 R = normalize(reflect(-L, N));\n"
				"float RdotV = max(0, dot(R, V));\n"
				"return light.Color * pow(RdotV, SpecularPower);\n"
				"}\n"

				"float MathAttenuation(Light light, float d){\n"
				"return 1.0f/( light.ConstantAttenuation + light.LinearAttenuation * d + light.QuadraticAttenuation * d * d );\n"
				"}\n"

				"struct LightingResult\n"
				"{\n"
				"float4 Diffuse;\n"
				"float4 Specular;\n"
				"};\n"

				"LightingResult MathPointLight(Light light, float3 V, float4 P, float3 N){\n"
				"LightingResult result;\n"
				"float3 L = (light.Position - P).xyz;\n"
				"float distance = length(L);\n"
				"L = L / distance;\n"
				"float attenuation = MathAttenuation(light, distance);\n"
				"result.Diffuse = MathDiffuse(light, L, N) * attenuation;\n"
				"result.Specular = MathSpecular(light, V, L, N) * attenuation;\n"
				"return result;\n"
				"}\n"

				"LightingResult MathDirectionalLight( Light light, float3 V, float4 P, float3 N ){\n"
				"LightingResult result; \n"
				"float3 L = -light.Direction.xyz; \n"
				"result.Diffuse = MathDiffuse(light, L, N); \n"
				"result.Specular = MathSpecular(light, V, L, N); \n"
				"return result; \n"
				"}\n"

				"float MathSpotCone(Light light, float3 L){\n"
				"float minCos = cos(light.SpotAngle);\n"
				"float maxCos = (minCos + 1.0f) / 2.0f;\n"
				"float cosAngle = dot(light.Direction.xyz, -L);\n"
				"return smoothstep(minCos, maxCos, cosAngle);\n"
				"}\n"

				"LightingResult MathSpotLight(Light light, float3 V, float4 P, float3 N){\n"
				"LightingResult result; \n"
				"float3 L = (light.Position - P).xyz; \n"
				"float distance = length(L); \n"
				"L = L / distance; \n"
				"float attenuation = MathAttenuation(light, distance); \n"
				"float spotIntensity = MathSpotCone(light, L); \n"
				"result.Diffuse = MathDiffuse(light, L, N) * attenuation * spotIntensity; \n"
				"result.Specular = MathSpecular(light, V, L, N) * attenuation * spotIntensity; \n"
				"return result; \n"
				"}\n"

				"LightingResult ComputeLighting(float4 P, float3 N){\n"
				"float3 V = normalize(EyePosition - P).xyz;\n"
				"LightingResult totalResult = { {0, 0, 0, 0}, {0, 0, 0, 0} }; \n"
				"[unroll]\n"
				"for (int i = 0; i < MAX_LIGHTS; ++i)\n"
				"{\n"
				"LightingResult result = { {0, 0, 0, 0}, {0, 0, 0, 0} }; \n"
				"if (!Lights[i].On) continue; \n"
				"switch (Lights[i].LightType)\n"
				"{\n"
				"case DIRECTIONAL_LIGHT:\n"
				"{\n"
				"result = MathDirectionalLight(Lights[i], V, P, N); \n"
				"}\n"
				"break; \n"
				"case POINT_LIGHT:\n"
				"{\n"
				"result = MathPointLight(Lights[i], V, P, N); \n"
				"}\n"
				"break; \n"
				"case SPOT_LIGHT:\n"
				"{\n"
				"result = MathSpotLight(Lights[i], V, P, N); \n"
				"}\n"
				"break; \n"
				"}\n"
				"totalResult.Diffuse += result.Diffuse; \n"
				"totalResult.Specular += result.Specular; \n"
				"}\n"
				"totalResult.Diffuse = saturate(totalResult.Diffuse); \n"
				"totalResult.Specular = saturate(totalResult.Specular); \n"
				"return totalResult; \n"
				"} \n"

				"float4 SimplePS(PixelShaderInput IN) : SV_TARGET{\n"



				"if(Lit == false){\n"
				"float4 textureColor = BaseColor;"
				"if(HasTexture){textureColor = shaderTexture.Sample(SampleType, IN.tex);}\n"
				"return textureColor; \n"
				"}\n"

				"else{\n"
				"LightingResult lit = ComputeLighting(IN.PositionWS, normalize(IN.normal));"
				"float4 emissive = Emissive;\n"
				"float4 ambient = Ambient * GlobalAmbient;\n"
				"float4 diffuse = Diffuse * lit.Diffuse; \n"
				"float4 specular = Specular * lit.Specular; \n"
				"float4 texColor = BaseColor; \n"
				"if (HasTexture){\n"
				"texColor = shaderTexture.Sample(SampleType, IN.tex); \n"
				"}\n"
				"float4 finalColor = (emissive + ambient + diffuse + specular) * texColor; \n"
				"return finalColor; \n"
				"}\n"

				"}\n"
			);
#pragma endregion PS

			const std::string TestVS = std::string(
				"cbuffer MyObjD : register(b6){\n"
				"float3 Translate;\n"
				"float pad1 = 0.0f;\n"
				"float3 Scale;\n"
				"float pad2;\n"
				"float4 Quat;\n"
				"}\n"

				"cbuffer PerApplication : register(b0){\n"
				"matrix projectionMatrix;\n"
				"}\n"

				"cbuffer PerFrame : register(b1){\n"
				"matrix viewMatrix;\n"
				"}\n"

				"cbuffer PerObject : register(b2){\n"
				"matrix worldMatrix;\n" //technically this is junk, but maybe someone else will use this in an extension - I personally don't want to use this for transform
				"}\n"

				"cbuffer Armature : register(b7){\n"
				"matrix armature[90];\n"
				"}\n"

				"struct AppData{\n"
				"float3 position : POSITION;\n"
				"float3 normal : NORMAL;\n"
				"float2 tex : TEXCOORD;\n"
				"int4 bID : BLENDID;\n"
				"float4 bW : BLENDWEIGHT;\n"
				"};\n"

				"struct VertexShaderOutput{\n"
				"float4 position : SV_POSITION;\n"
				"float3 normal: NORMAL;\n"
				"float2 tex : TEXCOORD0;\n"
				"float4 PositionWS : TEXCOORD1;\n"
				"}; \n"

				"float3 QuatRotate(float3 pos, float4 quat){\n"
				"return pos + 2.0 * cross(quat.xyz, cross(quat.xyz, pos) + quat.w * pos);\n"
				"}\n"


				"VertexShaderOutput SimpleVS(AppData IN){\n"

				"VertexShaderOutput OUT;\n"
				"float4 bP = float4(0,0,0,0);\n"
				"float4 nF = float4(0,0,0,0);\n" //normals
				"if(!any(IN.bW)) { bP = float4(IN.position,1); nF = float4(IN.normal,1);}\n"
				"else{\n"
				"matrix tmpM = armature[IN.bID[0]]*IN.bW[0]+armature[IN.bID[1]]*IN.bW[1]+armature[IN.bID[2]]*IN.bW[2]+armature[IN.bID[3]]*IN.bW[3];\n"
				"bP = mul(tmpM,float4(IN.position,1));\n"
				"nF = mul(tmpM,float4(IN.normal,1));\n"
				"}\n"
				"float3 adjust = ((QuatRotate(bP.xyz, Quat)*Scale)+Translate);\n"
				"bP = float4(adjust,1);\n"

				"adjust = ((QuatRotate(nF.xyz, Quat)*(Scale))+Translate);\n"
				"nF = float4(adjust,1);\n"

				"matrix mvp = mul(projectionMatrix,viewMatrix);\n"

				"OUT.position = float4(bP[0]+viewMatrix[0][3],bP[1]+viewMatrix[1][3],bP[2]+viewMatrix[2][3],1);\n" //+viewMatrix[3][0] 
				"OUT.normal = nF.xyz;\n"
				"OUT.PositionWS = bP;\n"
				"OUT.tex = IN.tex;\n"
				"return OUT;}");

			if (BMS2dVs != nullptr) {
				SafeRelease(BMS2dVs);
				SafeRelease(BMS2dPs);
			}

			BMS2dVs = LoadShaderStaticM(&TestVS, "SimpleVS", "latest");

			BMS2dPs = LoadShader<ID3D11PixelShader>(&TestPS, "SimplePS", "latest");

		}

		ID3D11ComputeShader* LightCullCompute;
		ID3D11ComputeShader* FrustumCalcCompute;

		void CreateTiledForwardRenderComputeShaders() {

			const std::string CSLightCullC = std::string(
			
			"#define BLOCK_SIZE " + std::to_string(FrustumObj.BLOCK_SIZE) + "\n" // should be defined by the application.\n"
			
			"#define MAX_LIGHTS " + std::to_string(ULPC.ULP.Lights.size()) + "\n"

			"#define DIRECTIONAL_LIGHT 0\n"
			"#define POINT_LIGHT 1\n"
			"#define SPOT_LIGHT 2\n"


			"struct Plane\n"
			"{\n"
			"float3 N;   // Plane normal.\n"
			"float  d;\n"
			"};\n"


			"struct Frustum\n"
			"{\n"
			"Plane planes[4];   // left, right, top, bottom frustum planes.\n"
			"};\n"

			"struct Sphere\n"
			"{\n"
			"float3 c; \n"   // Center point.
			"float  r; \n"   // Radius.
			"}; \n"
			"struct Cone\n"
			"{\n"
			"float3 T; \n"   // Cone tip.
			"float  h; \n"   // Height of the cone.
			"float3 d; \n"   // Direction of the cone.
			"float  r; \n"   // bottom radius of the cone.
			"}; \n"

			"RWStructuredBuffer<Frustum> out_Frustums : register(u0);\n"

			"struct ComputeShaderInput\n"

			"{\n"
			"uint3 groupID : SV_GroupID;           // 3D index of the thread group in the dispatch.\n"
			"uint3 groupThreadID : SV_GroupThreadID;     // 3D index of local thread ID in a thread group.\n"
			"uint3 dispatchThreadID : SV_DispatchThreadID;  // 3D index of global thread ID in the dispatch.\n"
			"uint  groupIndex : SV_GroupIndex;        // Flattened local index of the thread within a thread group.\n"
			"};\n"
			

			"struct Light{\n"
			"float4 PositionWS;\n"
			"float4 PositionVS;\n"
			"float4 DirectionWS;\n"
			"float4 DirectionVS;\n"
			"float4 Color;\n"

			"float SpotAngle;\n"
			"float Range;\n"
			"float Intensity;\n"
			"uint Type;\n"

			"bool On;\n"
			"float3 pad1;\n"
			"};\n"

			"cbuffer LightProperties : register(b12){\n"
			"float4 EyePosition;\n"
			"};\n"

	"cbuffer ScreenToViewParams : register(b3)\n"
			"{\n"
			"float4x4 InverseProjection;\n"
			"float2 ScreenDimensions;\n"
			"}\n"

			"cbuffer LightProperties : register(b10){\n" //TODO: load lights from structured buffer in texture - since then it loads faster and I have more than 64KB
			"Light Lights[MAX_LIGHTS];\n"
			"};\n"

			// Global variables
			"cbuffer DispatchParams : register(b4)\n"
				"{\n"
				// Number of groups dispatched. (This parameter is not available as an HLSL system value!)
				"uint3   numThreadGroups;\n"
				"uint pad1C;"
				// uint padding // implicit padding to 16 bytes.
				// Total number of threads dispatched. (Also not available as an HLSL system value!)
				// Note: This value may be less than the actual number of threads executed 
				// if the screen size is not evenly divisible by the block size.
				"uint3   numThreads;\n"
				"uint pad2C;"
				// uint padding // implicit padding to 16 bytes.
				"}\n"

			// The depth from the screen space texture.
			"Texture2D DepthTextureVS : register(t3);\n"
			// Precomputed frustums for the grid.
			"StructuredBuffer<Frustum> in_Frustums : register(t9);\n"

			// Debug texture for debugging purposes.
#ifdef _DEBUG
			//"Texture2D LightCountHeatMap : register(t10);\n"
			"RWTexture2D<float4> DebugTexture : register(u0);\n"
#endif
			// Global counter for current index into the light index list.
			// "o_" prefix indicates light lists for opaque geometry while 
			// "t_" prefix indicates light lists for transparent geometry.
			"globallycoherent RWStructuredBuffer<uint> o_LightIndexCounter : register(u1);\n"
			"globallycoherent RWStructuredBuffer<uint> t_LightIndexCounter : register(u2);\n"

			// Light index lists and light grids.
			"RWStructuredBuffer<uint> o_LightIndexList : register(u3);\n"
			"RWStructuredBuffer<uint> t_LightIndexList : register(u4);\n"
			"RWTexture2D<uint2> o_LightGrid : register(u5);\n"
			"RWTexture2D<uint2> t_LightGrid : register(u6);\n"

			// Group shared variables.
			"groupshared uint uMinDepth;\n"
			"groupshared uint uMaxDepth;\n"
			"groupshared Frustum GroupFrustum;\n"

			// Opaque geometry light lists.
			"groupshared uint o_LightCount;\n"
			"groupshared uint o_LightIndexStartOffset;\n"
			"groupshared uint o_LightList[1024];\n"

			// Transparent geometry light lists.
			"groupshared uint t_LightCount;\n"
			"groupshared uint t_LightIndexStartOffset;\n"
			"groupshared uint t_LightList[1024];\n"

			"SamplerState SampleType : register(s0);\n"


				// Check to see if a sphere is fully behind (inside the negative halfspace of) a plane.
// Source: Real-time collision detection, Christer Ericson (2005)
"bool SphereInsidePlane(Sphere sphere, Plane plane)\n"
"{\n"
				"return dot(plane.N, sphere.c) - plane.d < -sphere.r; \n"
					"}\n"
			
				// Check to see of a light is partially contained within the frustum.
			"bool SphereInsideFrustum(Sphere sphere, Frustum frustum, float zNear, float zFar)\n"
					"{\n"
					"bool result = true; \n"

				// First check depth
				// Note: Here, the view vector points in the -Z axis so the 
				// far depth value will be approaching -infinity.
					"if (sphere.c.z - sphere.r > zNear || sphere.c.z + sphere.r < zFar)\n"
					"{\n"
					"result = false; \n"
					"}\n"

				// Then check frustum planes
					"for (int i = 0; i < 4 && result; i++)\n"
					"{\n"
					"if (SphereInsidePlane(sphere, frustum.planes[i]))\n"
						"{\n"
						"result = false; \n"
						"}\n"
						"}\n"

					"return result; \n"
						"}\n"



						"bool PointInsidePlane(float3 p, Plane plane)\n"
						"{\n"
						"return dot(plane.N, p) - plane.d < 0; \n"
						"}\n"

				// Check to see if a cone if fully behind (inside the negative halfspace of) a plane.
// Source: Real-time collision detection, Christer Ericson (2005)
"bool ConeInsidePlane(Cone cone, Plane plane)\n"
"{\n"
				// Compute the farthest point on the end of the cone to the positive space of the plane.
						"	float3 m = cross(cross(plane.N, cone.d), cone.d); \n"
						"	float3 Q = cone.T + cone.d * cone.h - m * cone.r; \n"

				// The cone is in the negative halfspace of the plane if both
				// the tip of the cone and the farthest point on the end of the cone to the 
				// positive halfspace of the plane are both inside the negative halfspace 
				// of the plane.
						"	return PointInsidePlane(cone.T, plane) && PointInsidePlane(Q, plane); \n"
						"}\n"

						"	bool ConeInsideFrustum(Cone cone, Frustum frustum, float zNear, float zFar)\n"
						"	{\n"
						"	bool result = true; \n"

						"	Plane nearPlane = { float3(0, 0, -1), -zNear }; \n"
						"	Plane farPlane = { float3(0, 0, 1), zFar }; \n"

				// First check the near and far clipping planes.
						"	if (ConeInsidePlane(cone, nearPlane) || ConeInsidePlane(cone, farPlane))\n"
					"	{\n"
					"		result = false; \n"
					"	}\n"

				// Then check frustum planes
					"	for (int i = 0; i < 4 && result; i++)\n"
					"	{\n"
					"	if (ConeInsidePlane(cone, frustum.planes[i]))\n"
						"{\n"
						"result = false; \n"
						"}\n"
						"}\n"

					"return result; \n"
						"}\n"

			// Add the light to the visible light list for opaque geometry.
			"void o_AppendLight(uint lightIndex)\n"
				"{\n"
				"uint index; // Index into the visible lights array.\n"
				"InterlockedAdd(o_LightCount, 1, index);\n"
				"if (index < 1024)\n"
					"{\n"
					"o_LightList[index] = lightIndex;\n"
					"}\n"
				"}\n"

			// Add the light to the visible light list for transparent geometry.
			"void t_AppendLight(uint lightIndex)\n"
				"{\n"
				"uint index; // Index into the visible lights array.\n"
				"InterlockedAdd(t_LightCount, 1, index);\n"
				"if (index < 1024)\n"
					"{\n"
					"t_LightList[index] = lightIndex;\n"
					"}\n"
				"}\n"

	"float4 ClipToView(float4 clip)\n"
	"{\n"
	// View space position.
	"float4 view = mul(InverseProjection, clip);\n"
	// Perspective projection.
	"view = view / view.w;\n"

	"return view;\n"
	"}\n"
				// Convert screen space coordinates to view space.
				"float4 ScreenToView(float4 screen)\n"
				"{\n"
				// Convert to normalized texture coordinates
				"float2 texCoord = screen.xy / ScreenDimensions;\n"

				// Convert to clip space
				"float4 clip = float4(float2(texCoord.x, 1.0f - texCoord.y) * 2.0f - 1.0f, screen.z, screen.w);\n"

				"return ClipToView(clip);\n"
				"}\n"

				// Compute a plane from 3 noncollinear points that form a triangle.
// This equation assumes a right-handed (counter-clockwise winding order) 
// coordinate system to determine the direction of the plane normal.
"Plane ComputePlane(float3 p0, float3 p1, float3 p2)\n"
"{\n"
"Plane plane;\n"

"float3 v0 = p1 - p0;\n"
"float3 v2 = p2 - p0;\n"

"plane.N = normalize(cross(v0, v2));\n"

// Compute the distance to the origin using p0.
"plane.d = dot(plane.N, p0);\n"

"return plane;\n"
"}\n"
// Convert clip space coordinates to view space


			"[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]\n"
			"void CS_main(ComputeShaderInput IN)\n"
				"{\n"
				// Calculate min & max depth in threadgroup / tile.
				"int2 texCoord = IN.dispatchThreadID.xy;\n"
				"float fDepth = DepthTextureVS.Load(int3(texCoord, 0)).r;\n"

				"uint uDepth = asuint(fDepth);\n"

				"if (IN.groupIndex == 0) // Avoid contention by other threads in the group.\n"
					"{\n"
					"uMinDepth = 0xffffffff;\n"
					"uMaxDepth = 0;\n"
					"o_LightCount = 0;\n"
					"t_LightCount = 0;\n"
					"GroupFrustum = in_Frustums[IN.groupID.x + (IN.groupID.y * numThreadGroups.x)];\n"
					"}\n"

				"GroupMemoryBarrierWithGroupSync();\n"

				"InterlockedMin(uMinDepth, uDepth);\n"
				"InterlockedMax(uMaxDepth, uDepth);\n"

				"GroupMemoryBarrierWithGroupSync();\n"

				"float fMinDepth = asfloat(uMinDepth);\n"
				"float fMaxDepth = asfloat(uMaxDepth);\n"

				// Convert depth values to view space.
				"float minDepthVS = ScreenToView(float4(0, 0, fMinDepth, 1)).z;\n"
				"float maxDepthVS = ScreenToView(float4(0, 0, fMaxDepth, 1)).z;\n"
				"float nearClipVS = ScreenToView(float4(0, 0, 0, 1)).z;\n"

				// Clipping plane for minimum depth value 
				// (used for testing lights within the bounds of opaque geometry).
				"Plane minPlane = { float3(0, 0, -1), -minDepthVS };\n"

				// Cull lights
				// Each thread in a group will cull 1 light until all lights have been culled.
				"for (uint i = IN.groupIndex; i < MAX_LIGHTS; i += BLOCK_SIZE * BLOCK_SIZE)\n"
					"{\n"
					"if (Lights[i].On)\n"
						"{\n"
						"Light light = Lights[i];\n"

						"switch (light.Type)\n"
							"{\n"
							"case POINT_LIGHT:\n"
							"{\n"
							"Sphere sphere = { light.PositionVS.xyz, light.Range };\n"
							"if (SphereInsideFrustum(sphere, GroupFrustum, nearClipVS, maxDepthVS))\n"
								"{\n"
								// Add light to light list for transparent geometry.
								"t_AppendLight(i);\n"

								"if (!SphereInsidePlane(sphere, minPlane))\n"
									"{\n"
									// Add light to light list for opaque geometry.
									"o_AppendLight(i);\n"
									"}\n"
								"}\n"
							"}\n"
						"break;\n"
						"case SPOT_LIGHT:\n"
							"{\n"
							"float coneRadius = tan(radians(light.SpotAngle)) * light.Range;\n"
							"Cone cone = { light.PositionVS.xyz, light.Range, light.DirectionVS.xyz, coneRadius };\n"
							"if (ConeInsideFrustum(cone, GroupFrustum, nearClipVS, maxDepthVS))\n"
								"{\n"
								// Add light to light list for transparent geometry.
								"t_AppendLight(i);\n"

								"if (!ConeInsidePlane(cone, minPlane))\n"
									"{\n"
									// Add light to light list for opaque geometry.
									"o_AppendLight(i);\n"
									"}\n"
								"}\n"
							"}\n"
						"break;\n"
						"case DIRECTIONAL_LIGHT:\n"
							"{\n"
							// Directional lights always get added to our light list.
							// (Hopefully there are not too many directional lights!)
							"t_AppendLight(i);\n"
							"o_AppendLight(i);\n"
							"}\n"
						"break;\n"
						"}\n"
						"}\n"
					"}\n"

				// Wait till all threads in group have caught up.
				"GroupMemoryBarrierWithGroupSync();\n"

				// Update global memory with visible light buffer.
				// First update the light grid (only thread 0 in group needs to do this)
				"if (IN.groupIndex == 0)\n"
					"{\n"
					// Update light grid for opaque geometry.
					"InterlockedAdd(o_LightIndexCounter[0], o_LightCount, o_LightIndexStartOffset);\n"
					"o_LightGrid[IN.groupID.xy] = uint2(o_LightIndexStartOffset, o_LightCount);\n"
					
					// Update light grid for transparent geometry.
					"InterlockedAdd(t_LightIndexCounter[0], t_LightCount, t_LightIndexStartOffset);\n"
					"t_LightGrid[IN.groupID.xy] = uint2(t_LightIndexStartOffset, t_LightCount);\n"
					"}\n"

				"GroupMemoryBarrierWithGroupSync();\n"

				// Now update the light index list (all threads).
				// For opaque goemetry.
				"for (i = IN.groupIndex; i < o_LightCount; i += BLOCK_SIZE * BLOCK_SIZE)\n"
					"{\n"
					"o_LightIndexList[o_LightIndexStartOffset + i] = o_LightList[i];\n"
					"}\n"
				// For transparent geometry.
				"for (i = IN.groupIndex; i < t_LightCount; i += BLOCK_SIZE * BLOCK_SIZE)\n"
					"{\n"
					"t_LightIndexList[t_LightIndexStartOffset + i] = t_LightList[i];\n"
					"}\n"
#ifdef _DEBUG
				// Update the debug texture output.
				"if (IN.groupThreadID.x == 0 || IN.groupThreadID.y == 0)\n"
					"{\n"
					"DebugTexture[texCoord] = float4(0.0f, 0.0f, 0.0f, 0.9f);\n"
					"}\n"
				"else if (IN.groupThreadID.x == 1 || IN.groupThreadID.y == 1)\n"
					"{\n"
					"DebugTexture[texCoord] = float4(1.0f, 1.0f, 1.0f, 0.5f);\n"
					"}\n"
				"else if (o_LightCount > 0)\n"
					"{\n"
				//	"float normalizedLightCountColorV = o_LightCount / 5.0f;\n"
					"float4 lightCountHeatMapColor = float4(o_LightCount / 10.0f,0.0f,0.0f,1.0f);\n"
					"DebugTexture[texCoord] = lightCountHeatMapColor;\n"
					"}\n"
				"else\n"
					"{\n"
					"DebugTexture[texCoord] = float4(0.0f, 0.0f, 0.0f, 1.0f);\n"
					"}\n"
#endif

					"}\n"
							"[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]\n"
							"void CS_ComputeFrustums(ComputeShaderInput IN)\n"
							"{\n"
							// View space eye position is always at the origin.
							"const float3 eyePos = EyePosition.xyz;\n"
							// Compute 4 points on the far clipping plane to use as the 
							// frustum vertices.
							"float4 screenSpace[4];\n"
							// Top left point
							"screenSpace[0] = float4(IN.dispatchThreadID.xy * BLOCK_SIZE, -1.0f, 1.0f);\n"
							// Top right point
							"screenSpace[1] = float4(float2(IN.dispatchThreadID.x + 1, IN.dispatchThreadID.y) * BLOCK_SIZE, -1.0f, 1.0f);\n"
							// Bottom left point
							"screenSpace[2] = float4(float2(IN.dispatchThreadID.x, IN.dispatchThreadID.y + 1) * BLOCK_SIZE, -1.0f, 1.0f);\n"
							// Bottom right point
							"screenSpace[3] = float4(float2(IN.dispatchThreadID.x + 1, IN.dispatchThreadID.y + 1) * BLOCK_SIZE, -1.0f, 1.0f);\n"

							"float3 viewSpace[4];\n"
							// Now convert the screen space points to view space
							"for (int i = 0; i < 4; i++)\n"
							"{\n"
							"viewSpace[i] = ScreenToView(screenSpace[i]).xyz;\n"
							"}\n"

							// Now build the frustum planes from the view space points
							"Frustum frustum;\n"

							// Left plane
							"frustum.planes[0] = ComputePlane(eyePos, viewSpace[2], viewSpace[0]);\n"
							// Right plane
							"frustum.planes[1] = ComputePlane(eyePos, viewSpace[1], viewSpace[3]);\n"
							// Top plane
							"frustum.planes[2] = ComputePlane(eyePos, viewSpace[0], viewSpace[1]);\n"
							// Bottom plane
							"frustum.planes[3] = ComputePlane(eyePos, viewSpace[3], viewSpace[2]);\n"

							// Store the computed frustum in global memory (if our thread ID is in bounds of the grid).
							"if (IN.dispatchThreadID.x < numThreads.x && IN.dispatchThreadID.y < numThreads.y) { \n"
							"uint index = IN.dispatchThreadID.x + (IN.dispatchThreadID.y * numThreads.x); \n"
							"out_Frustums[index] = frustum; \n"
							"}\n"
							"}\n");


			LightCullCompute = LoadShader<ID3D11ComputeShader>(&CSLightCullC, "CS_main", "latest");

			FrustumCalcCompute = LoadShader<ID3D11ComputeShader>(&CSLightCullC, "CS_ComputeFrustums", "latest");

		}

		void PostCreate() {
			CreateStaticModelShader();
			//CreateStaticModel2dShader();
			CreateTiledForwardRenderComputeShaders();
		}

		void ClearShaders() {
			SafeRelease(BMSVs);
			SafeRelease(BMSPs);

			SafeRelease(BMS2dVs);
			SafeRelease(BMS2dPs);
		}

		void RecompileShaders() {
			LastVSUsed = 0;
			LastPSUsed = 0;

			//ClearShaders();

			PostCreate();
		}

	}ShaderData;


	void UniversalLightProperties::SetMaxLights(int Num) {
		Lights.resize(Num);
		Lights.shrink_to_fit();
		ShaderData.RecompileShaders();
		ULPC.DefaultULP(); //could be more efficent by creating and not packing right away - just flag to make at end
		//ULPC.ToUpdateULP = true;

		if (DL.L.size()) {
			DL.L.clear();
			DL.ReFillAllL();
		}
	}
	void SetMaxLights(int Num) {
		ULPC.ULP.SetMaxLights(Num);
	}

	void Initialize3DMode(olc::PixelGameEngine* pge);

	void Initialize3DShaders(int LayersToUse = 0) {
		PL.Initialize3DShadersPL(LayersToUse);
	}

	void ProgramLink_3D_DX::Initialize3DShadersPL(int LayersToUse) {
		if (IniSAndB == false) {
			IniSAndB = true;

			currentLayer = LayersToUse;

			if (LayersToUse < pge->GetLayers().size() && pge->GetLayers()[LayersToUse].bShow == true) {

			}
			else {
				currentLayer = 0;
			}

			pge->SetLayerCustomRenderFunction(currentLayer, DrawerHandle);

			ShaderData.PostCreate();

			FrustumObj.Setup();

		}
	}

	int CheckForDebugLightLogic(M3DR* Light) {
		if (Light->IsDebugLight == false) return 0;
		if (Light->DebugLightID >= DL.L.size()) return 0;
		DL.CheckAndSetLightTypeV(Light->DebugLightID);
		DL.SetLightMSR(Light->DebugLightID);
		DL.SetLightColor(Light->DebugLightID);
		return 1;
	}

	struct ModelDrawFuncs {

		std::vector<ID3D11Buffer*> CBufTmp;

		void SetGenericLightBuffersForDrawM() {

			//if() //transparent or opaque check - TODO
			dxDeviceContext->PSSetShaderResources(9, 1, &FrustumObj.o_LightIndexListSRV); //LightIndexList
			dxDeviceContext->PSSetShaderResources(10, 1, &FrustumObj.o_LightGridSRV); //LightGrid

		}
		void UnSetGenericLightBuffersForDrawM() {
			ID3D11ShaderResourceView* tmpSRV = nullptr;

			dxDeviceContext->PSSetShaderResources(9, 1, &tmpSRV); //LightIndexList
			dxDeviceContext->PSSetShaderResources(10, 1, &tmpSRV); //LightGrid
		}

		void DrawM(M3DR* Model, bool usingTmps = false, std::array<float, 3> XYZtmpTranslate = { 0.0f,0.0f,0.0f }, std::array<float, 3> tmpScale = { 1.0f,1.0f,1.0f }, std::array<float, 3> TmpRotateXYZaxis = { 0.0f,0.0f,0.0f }) {

			Model->CheckToUpdateArmatureCBuf();
			Model->CheckToUpdateMatAll();

			Model->CheckToSetFaceRasterizer();
			Model->CheckToSetDepthRasterizer();

			ID3D11Buffer* CBufTmpOne;

			ObjTuneStatReg ObjTuneTmp;

			if (usingTmps == true) {

				CBufTmp.push_back(CBufTmpOne);

				ObjTuneTmp.Scale = tmpScale;
				ObjTuneTmp.Translate = XYZtmpTranslate;
				XMStoreFloat4(&ObjTuneTmp.Quat, XMQuaternionRotationRollPitchYaw(TmpRotateXYZaxis[0], TmpRotateXYZaxis[1], TmpRotateXYZaxis[2]));

				D3D11_BUFFER_DESC bufDesc;
				ZeroMemory(&bufDesc, sizeof(bufDesc));
				bufDesc.Usage = D3D11_USAGE_DEFAULT;
				bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
				bufDesc.CPUAccessFlags = 0;
				bufDesc.ByteWidth = sizeof(ObjTuneStatReg);
				dxDevice->CreateBuffer(&bufDesc, nullptr, &CBufTmp[CBufTmp.size() - 1]);

				dxDeviceContext->UpdateSubresource(CBufTmp[CBufTmp.size() - 1], 0, nullptr, &ObjTuneTmp, 0, 0);

			}


			const UINT vertexStride = sizeof(VNT);
			const UINT offset = 0;


			dxDeviceContext->VSSetConstantBuffers( //in case no decals were drawn I need to fill const buf with the proper matrix's
				0,
				3,
				dxConstantBuffers
			);
			if (usingTmps == false) {
				dxDeviceContext->VSSetConstantBuffers(6, 1, &Model->CBuf);
			}
			else {
				dxDeviceContext->VSSetConstantBuffers(6, 1, &CBufTmp[CBufTmp.size() - 1]);
			}
			dxDeviceContext->VSSetConstantBuffers( //in case no decals were drawn I need to fill const buf with the proper matrix's
				7,
				1,
				&Model->ArmatureCBuf
			);


			dxDeviceContext->IASetInputLayout(
				ShaderData.BMSIl);

			dxDeviceContext->IASetPrimitiveTopology(
				D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); //D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ

			if (LastVSUsed != 1) {
				dxDeviceContext->VSSetShader(
					ShaderData.BMSVs,
					nullptr,
					0);
			}

			ID3D11PixelShader* tmpPS = nullptr;

			if (DepthPrePass == false) {
				dxDeviceContext->PSSetShader(
					tmpPS,
					nullptr,
					0); 

				LastPSUsed = -1;

				for (int i = 0; i < Model->VBuf.size(); i++) {
					
					dxDeviceContext->IASetVertexBuffers(0, 1, &Model->VBuf[i], &vertexStride, &offset);
					dxDeviceContext->IASetIndexBuffer(
						Model->IBuf[i],
						DXGI_FORMAT_R32_UINT,
						0);

					dxDeviceContext->DrawIndexed(
						Model->Indice[i].size(),
						0,
						0);
				}

			}
			else{ //done pre pass
				PGEX3DGeneralDepthStateIgnore();

				float bState[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
				dxDeviceContext->OMSetBlendState(Model->BlendState, bState, 0xffffffff);

				//dxDeviceContext->OMSetDepthStencilState(dxDepthStencilStateDefault, 1);

				dxDeviceContext->PSSetSamplers(0, 1, &Model->Sampler);


				if (LastPSUsed != 1) {
					dxDeviceContext->PSSetShader(
						ShaderData.BMSPs,
						nullptr,
						0);
				}

				SetGenericLightBuffersForDrawM();


				for (int i = 0; i < Model->VBuf.size(); i++) {
					dxDeviceContext->IASetVertexBuffers(0, 1, &Model->VBuf[i], &vertexStride, &offset);
					dxDeviceContext->IASetIndexBuffer(
						Model->IBuf[i],
						DXGI_FORMAT_R32_UINT,
						0);

					dxDeviceContext->PSSetConstantBuffers(0, 1, &Model->Mat[i].MatDataBuf);

					for (int x = 0; x < sizeof(Model->Mat[i].MatData.TexOn) / sizeof(UINT*); x++) {
						if (Model->Mat[i].MatData.TexOn[x] == 1) {
							dxDeviceContext->PSSetShaderResources(x, 1, &Model->Mat[i].TexSRV[x]);
						}
					}

					dxDeviceContext->DrawIndexed(
						Model->Indice[i].size(),
						0,
						0);
				}
				LastVSUsed = 1;
				LastPSUsed = 1;
				UnSetGenericLightBuffersForDrawM();
			}

		}
		void DrawM2D(M3DR* Model, bool usingTmps = false, std::array<float, 3> XYZtmpTranslate = { 0.0f,0.0f,0.0f }, std::array<float, 3> tmpScale = { 1.0f,1.0f,1.0f }, std::array<float, 3> TmpRotateXYZaxis = { 0.0f,0.0f,0.0f }) {

			Model->CheckToUpdateArmatureCBuf();
			Model->CheckToUpdateMatAll();

			Model->CheckToSetFaceRasterizer();
			Model->CheckToSetDepthRasterizer();

			ID3D11Buffer* CBufTmpOne;

			ObjTuneStatReg ObjTuneTmp;

			if (usingTmps == true) {

				CBufTmp.push_back(CBufTmpOne);

				ObjTuneTmp.Scale = tmpScale;
				ObjTuneTmp.Translate = XYZtmpTranslate;
				XMStoreFloat4(&ObjTuneTmp.Quat, XMQuaternionRotationRollPitchYaw(TmpRotateXYZaxis[0], TmpRotateXYZaxis[1], TmpRotateXYZaxis[2]));

				D3D11_BUFFER_DESC bufDesc;
				ZeroMemory(&bufDesc, sizeof(bufDesc));
				bufDesc.Usage = D3D11_USAGE_DEFAULT;
				bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
				bufDesc.CPUAccessFlags = 0;
				bufDesc.ByteWidth = sizeof(ObjTuneStatReg);
				dxDevice->CreateBuffer(&bufDesc, nullptr, &CBufTmp[CBufTmp.size() - 1]);

				dxDeviceContext->UpdateSubresource(CBufTmp[CBufTmp.size() - 1], 0, nullptr, &ObjTuneTmp, 0, 0);

			}

			const UINT vertexStride = sizeof(VNT);
			const UINT offset = 0;
			dxDeviceContext->VSSetConstantBuffers( //in case no decals were drawn I need to fill const buf with the proper matrix's
				0,
				3,
				dxConstantBuffers
			);
			if (usingTmps == false) {
				dxDeviceContext->VSSetConstantBuffers(6, 1, &Model->CBuf);
			}
			else {
				dxDeviceContext->VSSetConstantBuffers(6, 1, &CBufTmp[CBufTmp.size() - 1]);
			}
			dxDeviceContext->VSSetConstantBuffers( //in case no decals were drawn I need to fill const buf with the proper matrix's
				7,
				1,
				&Model->ArmatureCBuf
			);


			dxDeviceContext->IASetInputLayout(
				ShaderData.BMSIl);

			dxDeviceContext->IASetPrimitiveTopology(
				D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); //D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ

			//dxDeviceContext->RSSetState(dxRasterizerStateF);

			float bState[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
			dxDeviceContext->OMSetBlendState(Model->BlendState, bState, 0xffffffff);

			//dxDeviceContext->OMSetDepthStencilState(dxDepthStencilStateDefault, 1);

			dxDeviceContext->PSSetSamplers(0, 1, &Model->Sampler);

			if (LastVSUsed != 2) {//last VS/PS has no need to be reset
				dxDeviceContext->VSSetShader(
					ShaderData.BMS2dVs,
					nullptr,
					0);
			}
			if (LastPSUsed != 2) {
				dxDeviceContext->PSSetShader(
					ShaderData.BMS2dPs,
					nullptr,
					0);
			}

			for (int i = 0; i < Model->VBuf.size(); i++) {
				dxDeviceContext->IASetVertexBuffers(0, 1, &Model->VBuf[i], &vertexStride, &offset);
				dxDeviceContext->IASetIndexBuffer(
					Model->IBuf[i],
					DXGI_FORMAT_R32_UINT,
					0);

				dxDeviceContext->PSSetConstantBuffers(0, 1, &Model->Mat[i].MatDataBuf);

				for (int x = 0; x < sizeof(Model->Mat[i].TexSRV) / sizeof(ID3D11ShaderResourceView*); x++) {
					if (Model->Mat[i].MatData.TexOn[x]) dxDeviceContext->PSSetShaderResources(x, 1, &Model->Mat[i].TexSRV[x]);
				}

				dxDeviceContext->DrawIndexed(
					Model->Indice[i].size(),
					0,
					0);
			}

			LastVSUsed = 2;
			LastPSUsed = 2;
		}

		void LerpModelPosLogic(DataLerpFunc* tmp, M3DR* mod) {

			float LaS = PL.LastSec();
			float TimeLeft = tmp->MaxTime - tmp->CurTime;
			float ratio = TimeLeft / LaS;

			//std::cout <<"ratio:"<< ratio << "\n";
			//std::cout << "time left:" << TimeLeft << "\n";


			if (TimeLeft > 0) { //should always pass through - for now for debug I keep - but I can trash this later - TODO:

				//camXRot

				if (tmp->useX) {
					float DXLeftRatio = (tmp->X - mod->ObjTune.Translate[0]) / ratio;

					camXRot += mod->ObjTune.Translate[0];
				}
				if (tmp->useY) {
					float DYLeftRatio = (tmp->Y - mod->ObjTune.Translate[1]) / ratio;

					camYRot += mod->ObjTune.Translate[1];
				}
				if (tmp->useZ) {
					float DZLeftRatio = (tmp->Z - mod->ObjTune.Translate[2]) / ratio;

					camZRot += mod->ObjTune.Translate[2];

				}

				//UpdateCamForce = true;

				tmp->CurTime += LaS;

				mod->PassCBufToGPU();
			}
		}
		void LerpModelRotLogic(DataLerpFunc* tmp, M3DR* mod) {

			float LaS = PL.LastSec();
			float TimeLeft = tmp->MaxTime - tmp->CurTime;
			float ratio = TimeLeft / LaS;

			//std::cout <<"ratio:"<< ratio << "\n";
			//std::cout << "time left:" << TimeLeft << "\n";


			if (TimeLeft > 0) { //should always pass through - for now for debug I keep - but I can trash this later - TODO:

				//camXRot
				float quatDiv = sqrt(1 - mod->ObjTune.Quat.w * mod->ObjTune.Quat.w);

				float xRad;
				float yRad;
				float zRad;

				if (tmp->useX) {
					xRad = (mod->ObjTune.Quat.x / quatDiv);

					xRad += (tmp->X - xRad) / ratio;
				}
				if (tmp->useY) {
					yRad = (mod->ObjTune.Quat.y / quatDiv);

					yRad += (tmp->Y - yRad) / ratio;
				}
				if (tmp->useZ) {
					zRad = (mod->ObjTune.Quat.z / quatDiv);

					zRad += (tmp->Z - zRad) / ratio;
				}

				//UpdateCamForce = true;
				XMStoreFloat4(&mod->ObjTune.Quat, XMQuaternionRotationRollPitchYaw(xRad, yRad, yRad));

				tmp->CurTime += LaS;

				mod->PassCBufToGPU();
			}
		}

	}MDFs;

	void DrawM(M3DR* Model, bool before = false, bool usingTmps = false, std::array<float, 3> XYZtmpTranslate = { 0.0f,0.0f,0.0f }, std::array<float, 3> tmpScale = { 1.0f,1.0f,1.0f }, std::array<float, 3> rotateXYZaxis = { 0.0f,0.0f,0.0f }) {
		if (Model != nullptr) {
			CheckForDebugLightLogic(Model);

			DataDrawOrderAndFunc tmp;

			olc::vf2d inv = {
	(1.0f / float(PL.ScreenWidth())),
	(1.0f / float(PL.ScreenHeight()))
			};

			std::array<float, 3> tmpd = { ToNotPGESpace(&inv.x, &XYZtmpTranslate[0]), ToNotPGESpace(&inv.y, &XYZtmpTranslate[1]), ToNotPGESpace(&inv.x, &XYZtmpTranslate[2]) };

			tmp.func = [=]() {MDFs.DrawM(Model, usingTmps, tmpd, tmpScale, rotateXYZaxis); };

			if (before == false) {
				DrawOrder.push_back(tmp);
			}
			else {
				DrawOrderBefore.push_back(tmp);
			}
		}
	}

	void DrawM2D(M3DR* Model, bool before = false, bool usingTmps = false, std::array<float, 3> XYZtmpTranslate = { 0.0f,0.0f,0.0f }, std::array<float, 3> tmpScale = { 1.0f,1.0f,1.0f }, std::array<float, 3> rotateXYZaxis = { 0.0f,0.0f,0.0f }) {
		if (Model != nullptr) {
			CheckForDebugLightLogic(Model);

			DataDrawOrderAndFunc tmp;

			olc::vf2d inv = {
	(1.0f / float(PL.ScreenWidth())),
	(1.0f / float(PL.ScreenHeight()))
			};

			std::array<float, 3> tmpd = { ToNotPGESpace(&inv.x, &XYZtmpTranslate[0]), ToNotPGESpace(&inv.y, &XYZtmpTranslate[1]), ToNotPGESpace(&inv.x, &XYZtmpTranslate[2]) };

			tmp.func = [=]() {MDFs.DrawM2D(Model, usingTmps, tmpd, tmpScale, rotateXYZaxis); };

			if (before == false) {
				DrawOrder.push_back(tmp);
			}
			else {
				DrawOrderBefore.push_back(tmp);
			}
		}
	}
	M3DR* GetDebugLightObject(int LightNum) {	
		if (LightNum < DL.L.size()) {
			return &DL.L[LightNum];
		}
		else {
			return nullptr;
		}
	}



	/*

	FUN CAM STUFF

	*/

	//everything moves at the end of 1 loop, so set and add are independent - faster this way
	void SetEndFrameMoveCam(float StrafeLeftRight, float UpDown, float ForwardBackward) { //all in pge pixel size this cam movement
		//StrafeLeftRight --> + is move right, - is move left
		//UpDown --> + is up, - is down
		//ForwardBackward --> + is forward towards screen, - is backward
		olc::vf2d vInvScreenSize = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
		};

		moveLeftRight = ToNotPGESpace(&vInvScreenSize.x, &StrafeLeftRight);
		moveBackForward = ToNotPGESpace(&vInvScreenSize.x, &ForwardBackward);;
		moveUpDown = ToNotPGESpace(&vInvScreenSize.y, &UpDown);
	}
	void AddToEndFrameMoveCam(float StrafeLeftRight, float UpDown, float ForwardBackward) { //all in pge pixel size this cam movement
	//StrafeLeftRight --> + is move right, - is move left
	//UpDown --> + is up, - is down
	//ForwardBackward --> + is forward towards screen, - is backward
		olc::vf2d vInvScreenSize = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
		};

		moveLeftRight += ToNotPGESpace(&vInvScreenSize.x, &StrafeLeftRight);
		moveBackForward += ToNotPGESpace(&vInvScreenSize.x, &ForwardBackward);;
		moveUpDown += ToNotPGESpace(&vInvScreenSize.y, &UpDown);
	}
	void SetCamPos(float X, float Y, float Z) {
		UpdateCamForce = true;

		olc::vf2d vInvScreenSize = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
		};

		camRotationMatrix = XMMatrixRotationRollPitchYaw(0, 0, 0);
		camRight = XMVector3TransformCoord(DefaultRight, camRotationMatrix);
		camForward = XMVector3TransformCoord(DefaultForward, camRotationMatrix);
		camVertical = XMVector3TransformCoord(DefaultUp, camRotationMatrix);

		camPosition += XMVectorScale(camRight, ToNotPGESpace(&vInvScreenSize.x, &X));
		camPosition += XMVectorScale(camForward, ToNotPGESpace(&vInvScreenSize.x, &Z));
		camPosition += XMVectorScale(camVertical, ToNotPGESpace(&vInvScreenSize.y, &Y));
	}
	void MoveCamNowAsIfRotationIs(float PretendXRotateRad, float PretendYRotateRad, float PretendZRollRad, float StrafeLeftRight, float UpDown, float ForwardBackward) { //keeps normal rotation, just pretends when applying cam position mod that the rotation is already something (or 0,0,0 - so this can be used to move as if rest position if used - allowing normal strafing while looking up for example)
		UpdateCamForce = true;

		olc::vf2d vInvScreenSize = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
		};

		camRotationMatrix = XMMatrixRotationRollPitchYaw(PretendYRotateRad, PretendXRotateRad, PretendZRollRad);
		camRight = XMVector3TransformCoord(DefaultRight, camRotationMatrix);
		camForward = XMVector3TransformCoord(DefaultForward, camRotationMatrix);
		camVertical = XMVector3TransformCoord(DefaultUp, camRotationMatrix);

		camPosition += XMVectorScale(camForward, ToNotPGESpace(&vInvScreenSize.x, &ForwardBackward));
		camPosition += XMVectorScale(camRight, ToNotPGESpace(&vInvScreenSize.x, &StrafeLeftRight));
		camPosition += XMVectorScale(camVertical, ToNotPGESpace(&vInvScreenSize.y, &UpDown));
	}
	void MoveCamNowWithCurrentRotation(float StrafeLeftRight, float UpDown, float ForwardBackward) { //keeps normal rotation, just pretends when applying cam position mod that the rotation is already something (or 0,0,0 - so this can be used to move as if rest position if used - allowing normal strafing while looking up for example)
		UpdateCamForce = true;

		olc::vf2d vInvScreenSize = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
		};

		camRotationMatrix = XMMatrixRotationRollPitchYaw(camYRot, camXRot, camZRot);
		camRight = XMVector3TransformCoord(DefaultRight, camRotationMatrix);
		camForward = XMVector3TransformCoord(DefaultForward, camRotationMatrix);
		camVertical = XMVector3TransformCoord(DefaultUp, camRotationMatrix);

		camPosition += XMVectorScale(camForward, ToNotPGESpace(&vInvScreenSize.x, &ForwardBackward));
		camPosition += XMVectorScale(camRight, ToNotPGESpace(&vInvScreenSize.x, &StrafeLeftRight));
		camPosition += XMVectorScale(camVertical, ToNotPGESpace(&vInvScreenSize.y, &UpDown));
	}

	void SetCamAngle(float X, float Y, float Z) { //SwivelSideWays, tilt up down, or roll with z - easy names for the unaffiliated with cam terms of pitch, yaw, roll
		camXRot = X;
		camYRot = Y;
		camZRot = Z;
	}
	void AddToCamAngle(float X, float Y, float Z) { //add also allows subtract
		camXRot += X;
		camYRot += Y;
		camZRot += Z;
	}

	std::array<float, 3> ReturnCamAngle() {
		return std::array<float, 3> {camXRot, camYRot, camZRot};
	}

	std::array<float, 3> ReturnCamPosition() {
		olc::vf2d Inv = {
(1.0f / float(PL.ScreenWidth())),
(1.0f / float(PL.ScreenHeight()))
		};

		float xP = XMVectorGetByIndex(camPosition, 0);
		float yP = XMVectorGetByIndex(camPosition, 1);
		float zP = XMVectorGetByIndex(camPosition, 2);

		return std::array<float, 3>{
			ToPGESpace(&Inv.x, &xP),
				ToPGESpace(&Inv.y, &yP),
				ToPGESpace(&Inv.x, &zP)};
		//TODO: test
	}

	struct camFuncLogic {

		void LerpCamPosLogic(DataLerpFunc* tmp) {
			//use fLastElapsed to get steps

			float LaS = PL.LastSec();
			float TimeLeft = tmp->MaxTime - tmp->CurTime;
			float ratio = TimeLeft / LaS;

			//std::cout <<"ratio:"<< ratio << "\n";
			//std::cout << "time left:" << TimeLeft << "\n";


			if (TimeLeft > 0) { //should always pass through - for now for debug I keep - but I can trash this later - TODO:

				camRotationMatrix = XMMatrixRotationRollPitchYaw(0, 0, 0);

				if (tmp->useX) {

					camRight = XMVector3TransformCoord(DefaultRight, camRotationMatrix);

					float xP = XMVectorGetByIndex(camPosition, 0);

					float DXLeftRatio = (tmp->X - xP) / ratio;

					camPosition += XMVectorScale(camRight, DXLeftRatio);
				}
				if (tmp->useY) {

					camVertical = XMVector3TransformCoord(DefaultUp, camRotationMatrix);

					float yP = XMVectorGetByIndex(camPosition, 1);

					float DYLeftRatio = (tmp->Y - yP) / ratio;

					camPosition += XMVectorScale(camVertical, DYLeftRatio);
				}
				if (tmp->useZ) {

					camForward = XMVector3TransformCoord(DefaultForward, camRotationMatrix);

					float zP = XMVectorGetByIndex(camPosition, 2);

					float DZLeftRatio = (tmp->Z - zP) / ratio;

					camPosition += XMVectorScale(camForward, DZLeftRatio);

				}

				UpdateCamForce = true;

				tmp->CurTime += LaS;

			}
		}
		void LerpCamRotLogic(DataLerpFunc* tmp) {
			//use fLastElapsed to get steps

			float LaS = PL.LastSec();
			float TimeLeft = tmp->MaxTime - tmp->CurTime;
			float ratio = TimeLeft / LaS;

			//std::cout <<"ratio:"<< ratio << "\n";
			//std::cout << "time left:" << TimeLeft << "\n";


			if (TimeLeft > 0) { //should always pass through - for now for debug I keep - but I can trash this later - TODO:

				//camXRot

				if (tmp->useX) {
					float DXLeftRatio = (tmp->X - camXRot) / ratio;

					camXRot += DXLeftRatio;
				}
				if (tmp->useY) {
					float DYLeftRatio = (tmp->Y - camYRot) / ratio;

					camYRot += DYLeftRatio;
				}
				if (tmp->useZ) {
					float DZLeftRatio = (tmp->Z - camZRot) / ratio;

					camZRot += DZLeftRatio;

				}

				//UpdateCamForce = true;

				tmp->CurTime += LaS;
			}
		}
	}CFL;

	void LerpCamPos(bool useX = false, bool useY = false, bool useZ = false, float X2 = 0, float Y2 = 0, float Z2 = 0, float MaxTime = 3.0f) {
		DataLerpFunc tmp;
		LerpCamFunc.push_back(tmp);

		olc::vf2d vInvScreenSize = {
	(1.0f / float(PL.ScreenWidth())),
	(1.0f / float(PL.ScreenHeight()))
		};

		LerpCamFunc[LerpCamFunc.size() - 1].X = ToNotPGESpace(&vInvScreenSize.x, &X2);
		LerpCamFunc[LerpCamFunc.size() - 1].useX = useX;

		LerpCamFunc[LerpCamFunc.size() - 1].Y = ToNotPGESpace(&vInvScreenSize.y, &Y2);
		LerpCamFunc[LerpCamFunc.size() - 1].useY = useY;

		LerpCamFunc[LerpCamFunc.size() - 1].Z = ToNotPGESpace(&vInvScreenSize.x, &Z2);
		LerpCamFunc[LerpCamFunc.size() - 1].useZ = useZ;

		LerpCamFunc[LerpCamFunc.size() - 1].CurTime = 0.0f;
		LerpCamFunc[LerpCamFunc.size() - 1].MaxTime = MaxTime;

		LerpCamFunc[LerpCamFunc.size() - 1].func = [&]() {CFL.LerpCamPosLogic(LerpCamFunc[LerpCamFunc.size() - 1].me()); };

	}
	void LerpCamRot(bool useX = false, bool useY = false, bool useZ = false, float X2 = 0, float Y2 = 0, float Z2 = 0, float MaxTime = 3.0f) {

		DataLerpFunc tmp;
		LerpCamFunc.push_back(tmp);

		LerpCamFunc[LerpCamFunc.size() - 1].X = X2;
		LerpCamFunc[LerpCamFunc.size() - 1].useX = useX;

		LerpCamFunc[LerpCamFunc.size() - 1].Y = Y2;
		LerpCamFunc[LerpCamFunc.size() - 1].useY = useY;

		LerpCamFunc[LerpCamFunc.size() - 1].Z = Z2;
		LerpCamFunc[LerpCamFunc.size() - 1].useZ = useZ;

		LerpCamFunc[LerpCamFunc.size() - 1].CurTime = 0.0f;
		LerpCamFunc[LerpCamFunc.size() - 1].MaxTime = MaxTime;

		LerpCamFunc[LerpCamFunc.size() - 1].func = [&]() {CFL.LerpCamRotLogic(LerpCamFunc[LerpCamFunc.size() - 1].me()); };

	}

	void LerpModelPos(M3DR* mod, bool useX = false, bool useY = false, bool useZ = false, float X2 = 0, float Y2 = 0, float Z2 = 0, float MaxTime = 3.0f) {
		DataLerpFunc tmp;
		LerpModelFunc.push_back(tmp);

		olc::vf2d vInvScreenSize = {
	(1.0f / float(PL.ScreenWidth())),
	(1.0f / float(PL.ScreenHeight()))
		};

		LerpModelFunc[LerpModelFunc.size() - 1].X = ToNotPGESpace(&vInvScreenSize.x, &X2);
		LerpModelFunc[LerpModelFunc.size() - 1].useX = useX;

		LerpModelFunc[LerpModelFunc.size() - 1].Y = ToNotPGESpace(&vInvScreenSize.y, &Y2);
		LerpModelFunc[LerpModelFunc.size() - 1].useY = useY;

		LerpModelFunc[LerpModelFunc.size() - 1].Z = ToNotPGESpace(&vInvScreenSize.x, &Z2);
		LerpModelFunc[LerpModelFunc.size() - 1].useZ = useZ;

		LerpModelFunc[LerpModelFunc.size() - 1].CurTime = 0.0f;
		LerpModelFunc[LerpModelFunc.size() - 1].MaxTime = MaxTime;

		LerpModelFunc[LerpModelFunc.size() - 1].func = [&]() {MDFs.LerpModelPosLogic(LerpModelFunc[LerpCamFunc.size() - 1].me(), mod); };

	}
	void LerpModelRot(M3DR* mod, bool useX = false, bool useY = false, bool useZ = false, float X2 = 0, float Y2 = 0, float Z2 = 0, float MaxTime = 3.0f) {

		DataLerpFunc tmp;
		LerpModelFunc.push_back(tmp);

		LerpModelFunc[LerpModelFunc.size() - 1].X = X2;
		LerpModelFunc[LerpModelFunc.size() - 1].useX = useX;

		LerpModelFunc[LerpModelFunc.size() - 1].Y = Y2;
		LerpModelFunc[LerpModelFunc.size() - 1].useY = useY;

		LerpModelFunc[LerpModelFunc.size() - 1].Z = Z2;
		LerpModelFunc[LerpModelFunc.size() - 1].useZ = useZ;

		LerpModelFunc[LerpModelFunc.size() - 1].CurTime = 0.0f;
		LerpModelFunc[LerpModelFunc.size() - 1].MaxTime = MaxTime;

		LerpModelFunc[LerpModelFunc.size() - 1].func = [&]() {MDFs.LerpModelRotLogic(LerpModelFunc[LerpModelFunc.size() - 1].me(), mod); };

	}

	//void ChainedLerpCamPoves() {
		//TODO: when done lerp it starts next in chain like linked list - which can start another, ect- and can loop the chain as option when done until stopped
	//}
	//void ChainedLerpCamRotation() {
		//TODO: when done lerp it starts next in chain like linked list - which can start another, ect- and can loop the chain as option when done until stopped
	//}

	/*

	END OF FUN CAM STUFF

	*/










	void CamLerpFunctionMacro() {
		for (int i = 0; i < LerpCamFunc.size(); i++) {
			if (LerpCamFunc[i].CurTime < LerpCamFunc[i].MaxTime) {
				LerpCamFunc[i].func();
			}
			else {
				LerpCamFunc.erase(LerpCamFunc.begin() + i);
				i -= 1;
			}
		}
	}

	void ProgramLink_3D_DX::DrawFuncMain() {

		DepthPrePass = false;

		CamLerpFunctionMacro();
		
		PGEX3DGeneralRenderStateSet();
		for (int i = 0; i < DrawOrderBefore.size(); i++) {
			DrawOrderBefore[i].func();
		}
		for (int i = 0; i < DrawOrder.size(); i++) {
			DrawOrder[i].func();
		}
		DepthPrePass = true;

		ULPC.CheckToUpdateULP(); //update light if needed
		ULPC.CheckToUpdateGA();
		ULPC.CheckToUpdateEP();

		FrustumObj.CheckToSetupAndRunComputeFrustum();
		FrustumObj.SetupAndRunLightCompute();

		ULPC.SetLightToPixelShaderSlotTen(); //pray that b10 is not used - else, perf is gonna tank with my next change :sob:



		if (pge->GetLayers()[currentLayer].bUpdate)
		{
			pge->GetLayers()[currentLayer].pDrawTarget.Decal()->Update();
			pge->GetLayers()[currentLayer].bUpdate = false;
		}

		olc::renderer->DrawLayerQuad(pge->GetLayers()[currentLayer].vOffset, pge->GetLayers()[currentLayer].vScale, pge->GetLayers()[currentLayer].tint);

		PGEX3DGeneralRenderStateSet();
		for (int i = 0; i < DrawOrderBefore.size(); i++) {
			DrawOrderBefore[i].func();
		}

		RegularRasterState();
		DefaultLastVSPSUsed();

		for (auto& decal : pge->GetLayers()[currentLayer].vecDecalInstance)
			olc::renderer->DrawDecal(decal);
		pge->GetLayers()[currentLayer].vecDecalInstance.clear();

		PGEX3DGeneralRenderStateSet();
		for (int i = 0; i < DrawOrder.size(); i++) {
			DrawOrder[i].func();
		}

		RegularRasterState();
		DefaultLastVSPSUsed();

		DrawOrder.clear();
		DrawOrderBefore.clear();

		//clear tmp buf : start
		for (int i = 0; i < MDFs.CBufTmp.size(); i++) {
			SafeRelease(MDFs.CBufTmp[i]);
		}
		MDFs.CBufTmp.clear();
		//clear tmp buf : end
	}

	void Initialize3DMode(olc::PixelGameEngine* pge)
	{
		pge->pgex_Register(&PL);


		Create3dRasterDesc();
		LoadDirectionLightVNT();
		LoadPointLightVNT();
		LoadSpotLightVNT();
		ULPC.DefaultULP();
		ULPC.DefaultGA();
		ULPC.DefaultEP();

	}


	void FrustumObjectAndShaderLight::SetupAndRunComputeFrustum() {
		UpdateMathOfSVParamAndBuf();
		
		FOVCheck = FOV;

		UINT xG = floor(float(PL.ScreenWidth()) / BLOCK_SIZE);
		UINT yG = floor(float(PL.ScreenHeight()) / BLOCK_SIZE);

		UpdateDispatchParamAndBuf({ xG,	yG, 1 }, { xG*BLOCK_SIZE,yG*BLOCK_SIZE,1 });
		

		dxDeviceContext->CSSetUnorderedAccessViews(0,1,&FOutDat,0);
		dxDeviceContext->CSSetConstantBuffers(12,1,&ULPC.EyePositionBuffer);
		dxDeviceContext->CSSetConstantBuffers(3, 1, &ScreenToViewParamsBuf);
//		dxDeviceContext->CSSetConstantBuffers(10, 1, &ULPC.ULPBuffer);
		dxDeviceContext->CSSetConstantBuffers(4, 1, &DispatchParamsBuf);

//		dxDeviceContext->CSSetShaderResources();

		
//		dxDeviceContext->CSSetConstantBuffers();

//		dxDeviceContext->CSSetSamplers();

		dxDeviceContext->CSSetShader(
			ShaderData.FrustumCalcCompute,
			nullptr,
			0);


		dxDeviceContext->Dispatch(DispatchParams.numThreadGroups[0], DispatchParams.numThreadGroups[1], DispatchParams.numThreadGroups[2]);

	}

	void FrustumObjectAndShaderLight::SetupAndRunLightCompute() {
		
		ID3D11UnorderedAccessView* tmpUAV = nullptr;
		ID3D11ShaderResourceView* tmpSRV = nullptr;
		ID3D11Resource* r1;
		ID3D11Resource* r2;
		DepthStencilRLink->GetResource(&r1);
		dxDepthStencilView->GetResource(&r2);
		if (r1 != r2) {
			SafeRelease(r1);
			LinkDepthStencil();
		}
		SafeRelease(r1);
		SafeRelease(r2);

		dxDeviceContext->CSSetUnorderedAccessViews(0, 1, &tmpUAV, 0); //unbind FOutDat

		if (DepthSizeX != PL.ScreenWidth() || DepthSizeY != PL.ScreenHeight()) {
			LightIndexBufDefault();
			LightGridBufDefault();
#ifdef _DEBUG
			DebugTexBufDefault();
#endif
		}

#ifdef _DEBUG
		dxDeviceContext->CSSetUnorderedAccessViews(0, 1, &DebugTextureUAV, 0);
#endif

		ID3D11RenderTargetView* tmprtv = nullptr;
		ID3D11DepthStencilView* tmpdtv = nullptr;
		dxDeviceContext->OMSetRenderTargets(
			1,
			&tmprtv,
			tmpdtv);

		dxDeviceContext->CSSetShaderResources(3, 1, &DepthStencilRLink);
		dxDeviceContext->CSSetShaderResources(9, 1, &FInDat);
		dxDeviceContext->CSSetSamplers(0, 1, &Sampler);
		//dxDeviceContext->CSSetUnorderedAccessViews(0, 1, nullptr, 0);
		dxDeviceContext->CSSetConstantBuffers(12, 1, &ULPC.EyePositionBuffer);
		dxDeviceContext->CSSetConstantBuffers(10, 1, &ULPC.ULPBuffer);

		dxDeviceContext->CSSetConstantBuffers(3, 1, &ScreenToViewParamsBuf);
		dxDeviceContext->CSSetConstantBuffers(4, 1, &DispatchParamsBuf);
		dxDeviceContext->CSSetUnorderedAccessViews(1, 1, &o_LightIndexCounterUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(2, 1, &t_LightIndexCounterUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(3, 1, &o_LightIndexListUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(4, 1, &t_LightIndexListUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(5, 1, &o_LightGridUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(6, 1, &t_LightGridUAV, 0);


		dxDeviceContext->CSSetShader(
			ShaderData.LightCullCompute,
			nullptr,
			0);


		dxDeviceContext->Dispatch(DispatchParams.numThreadGroups[0], DispatchParams.numThreadGroups[1], DispatchParams.numThreadGroups[2]);

		dxDeviceContext->CSSetShaderResources(9, 1, &tmpSRV);
		dxDeviceContext->CSSetShaderResources(3, 1, &tmpSRV);

		dxDeviceContext->CSSetUnorderedAccessViews(1, 1, &tmpUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(2, 1, &tmpUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(3, 1, &tmpUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(4, 1, &tmpUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(5, 1, &tmpUAV, 0);
		dxDeviceContext->CSSetUnorderedAccessViews(6, 1, &tmpUAV, 0);

		
	}

	///////////////////////////
	void EnableDebugLights() {
		DL.ReFillAllL();
	}

	void SetLightDirection(int Num, float x, float y, float z) { //radian variant
		ULPC.ULP.Lights[Num].SetDirection(x, y, z);
	}

	void SetLightDirection(int Num, std::array<float, 3> t = { 0, 0, 0 }) { //Direction vector variant
		ULPC.ULP.Lights[Num].SetDirection(t);
	}
	void SetLightPosition(int Num, float x, float y, float z) { //PGE space points
		ULPC.ULP.Lights[Num].SetPosition(x, y, z);
	}
	void SetLightColor(int Num, float r, float g, float b, float a) { //0-255
		ULPC.ULP.Lights[Num].SetColor(r / 255, g / 255, b / 255, a / 255);
	}
	void SetLightSpotAngle(int Num, float a) { //radian of spot angle
		ULPC.ULP.Lights[Num].SetSpotAngle(a);
	}
	void SetLightRange(int Num, float a) {
		ULPC.ULP.Lights[Num].SetRange(a);
	}
	void SetLightIntensity(int Num, float a) {
		ULPC.ULP.Lights[Num].SetIntensity(a);
	}
	void SetLightOn(int Num, bool a) {
		ULPC.ULP.Lights[Num].SetLightOn(a);
	}
	void ChangeLightType(int Num, int type) { //0 == dir, 1 == point, 2 == spot
		if (type > 2)type = 0;
		ULPC.ULP.Lights[Num].SetLightType(type);
	}
	std::array<float, 3> GetLightPosition(int Num) {
		return ULPC.ULP.Lights[Num].GetPosition();
	}
	std::array<float, 3> GetLightDirectionVector(int Num) {
		return ULPC.ULP.Lights[Num].GetDirectionVector();
	}
	std::array<float, 3> GetLightDirectionRadians(int Num) {
		return ULPC.ULP.Lights[Num].GetDirectionRadians();
	}
	std::array<float, 4> GetLightColor(int Num) {
		return ULPC.ULP.Lights[Num].GetColor();
	}
	int GetLightType(int Num) {
		return ULPC.ULP.Lights[Num].GetLightType();
	}
	float GetLightRange(int Num) {
		return ULPC.ULP.Lights[Num].GetLightRange();
	}
	float GetLightIntensity(int Num) {
		return ULPC.ULP.Lights[Num].GetLightIntensity();
	}
	bool GetLightOn(int Num) {
		return ULPC.ULP.Lights[Num].GetLightOn();
	}

	///////////////////////////


}


#endif
